<!doctype html>
<html lang="en">
    <head>
        <meta charset="utf-8"/>
        <meta name="viewport" content="width=device-width"/>
        <title>Tokudae 1.0 Reference Manual</title>
        <link rel="stylesheet" type="text/css" href="manual.css">
    </head>
    <body>
        <h1>Tokudae 1.0 Reference Manual</h1>
        <small>
            <p>
            Copyright &copy; 1994&ndash;2024 Lua.org, PUC-Rio
            <br/>
            Copyright &copy; 2024&ndash;2025 Jure Bagić
            </p>
        </small>
        <div class="menubar">
            <a href="contents.html#contents">contents</a>
            &middot;
            <a href="contents.html#index">index</a>
        </div>




        <h1>1 &ndash; <a name="1">Introduction</a></h1>
        <p>
        <a href="https://en.wikipedia.org/wiki/Guam_flying_fox">Tokudae</a>
        is a lightweight fully embeddable scripting language.
        <br/><br/>
        Tokudae is dynamically typed, it runs by interpreting bytecode with
        a stack-based virtual machine, and it's memory is automatically
        managed by the incremental garbage collector.
        <br/><br/>
        Tokudae is implemented as a library fully written in C, and to be
        compiled with any ISO C99 compliant C compiler.
        Tokudae distribution includes a host program called
        <a href="#7"><code>tokudae</code></a>,
        which is the interpreter that uses Tokudae library.
        Tokudae is intended to be primarily used as lightweight embeddable
        scripting language but also as a stand-alone language that is easy
        to learn as it shares most of its syntax with the C programming
        language and has the semantics of
        <a href="https://www.lua.org/">Lua</a>.
        <br/><br/>
        Tokudae is free software, and is provided with no guarantees,
        as stated in its license.
        <br/><br/>
        This manual is subject to changes, as the language itself changes.
        However the reference manual is always valid for the same version of
        Tokudae distribution. If you spot a mistake or you think the manual
        is lacking in various places, please let me know
        <a href="https://github.com/b-jure/tokudae">here</a>
        (github repository).
        </p>




        <h1>2 &ndash; <a name="2">Basic Concepts</a></h1>
        <p>
        This section describes the basic concepts of the language.
        </p>


        <h2>2.1 &ndash; <a name="2.1">Values and Types</a></h2>
        <p>
        Tokudae is a dynamically typed language.
        This means that variables do not have types; only values do.
        There are no type definitions in the language,
        instead all values carry their own type.
        <br/><br/>
        All values in Tokudae are first-class values, meaning all values
        can be stored in variables (as is expected), passed as arguments
        to other functions and returned as results.
        <br/><br/>
        There are thirteen basic types in Tokudae:
        <code>nil</code>, <code>boolean</code>, <code>number</code>,
        <code>string</code>, <code>function</code>, <code>userdata</code>,
        <code>light userdata</code>, <code>thread</code>, <code>table</code>,
        <code>list</code>, <code>class</code>, <code>bound method</code> and
        <code>instance</code>.
        <br/><br/>
        <!-- nil -->
        The type <code>nil</code> has one single value, <b>nil</b>, and is
        intended to represent absence of value.
        <br/><br/>
        <!-- boolean -->
        The type <code>boolean</code> has two values, <b>true</b> and <b>false</b>.
        Both <b>nil</b> and <b>false</b> make a condition false; they are
        collectively called <em>false values</em>
        (for example in C, we would consider <b>0</b> value as the
        <em>false value</em>).
        Any other value makes a condition true.
        So what is the difference between the <b>false</b> and <b>nil</b>?
        Here is a simple example, if we were to index a table with <b>nil</b>
        it would raise a runtime error; as said, use <b>nil</b> to indicate
        absence of value.
        <br/><br/>
        <!-- number -->
        The type <code>number</code> represents both integer and real
        (floating-point) numbers, using two subtypes: <em>integer</em> and
        <em>float</em> (as is indicated in the C&nbsp;API header).
        <br/>
        Standard Tokudae uses 64-bit integers and double-precision (64-bit)
        floats. Configuration header can be tinkered to allow 32-bit integers
        and/or single-precision (32-bit) floats, but this would probably
        require internal patches (see <code>tokudaeconf.h</code> if interested).
        <br/>
        Unless stated otherwise,
        any overflow when manipulating integer values <em>wrap around</em>,
        according to the usual rules of two-complement arithmetics.
        <br/>
        The conversion between the two subtypes mimics C standard.
        For example, if we were to do a mathematical operation between the two
        numbers, one of them is <em>integer</em> and the other is
        <em>float</em>, before the operation <em>integer</em> would be
        converted to a <em>float</em>.
        Additionally before the operation if the both numbers are of type
        <em>float</em> but both have <em>integer</em> representation, then
        they would be converted to <em>integers</em> before the operation.
        However operations such as division and exponentiation always convert
        their operands to <em>float</em> subtype (the exception being the
        integer division '<code>//</code>').
        <br/><br/>
        <!-- string -->
        The type <code>string</code> represents immutable sequence of bytes.
        Strings can contain any 8-bit value, including embedded zeros
        ('<code>\0</code>').
        Internally Tokudae is encoding-agnostic; it makes no assumptions
        about the contents of a string.
        The length of any string in Tokudae must fit in a Tokudae integer.
        <br/><br/>
        <!-- function -->
        The type <code>function</code> can be a function written in Tokudae or
        C, both of which can be manipulated and called.
        <br/><br/>
        <!-- bound method -->
        The type <code>bound method</code> is an object comprised of a method
        object and a receiver object usually referred to as <em>self</em>
        in OOP-lingo. <em>self</em> is either a <em>full userdata</em>
        or <em>instance</em>, and the method object is usually a callable
        object, but can be any value. Usually <em>instance bound method</em>
        object is created each time you index an <em>instance</em>,
        where the index value (a key) is entry in a method table,
        but not found in the fields table.
        The <em>full userdata bound method</em> is created via C API.
        <br/><br/>
        <!-- userdata and light userdata -->
        The types <code>userdata</code> and <code>light userdata</code>
        are provided to allow arbitrary C&nbsp;data to be stored in a variable.
        Full/Light userdata value represents a block of raw memory.
        <em>full userdata</em> is an object with a block of memory managed
        by Tokudae, and <em>light userdata</em>, is simply a C&nbsp;pointer
        value. Userdata has no predefined operations in Tokudae except
        assignment and identity test (<code>==</code>).
        By using <em>metatables</em>, the programmer can define operations
        for <em>full userdata</em> values (see <a href="#2.4">&sect;2.4</a>).
        Userdata values cannot be created or modified in Tokudae, only
        through the C&nbsp;API.
        This guarantees the integrity of data owned by the host program
        and C&nbsp;libraries.
        <br/><br/>
        <!-- table -->
        The type <code>table</code> implements associative arrays,
        that is, arrays that can have as indices not only numbers,
        but any Tokudae value except <b>nil</b> and NaN
        (<em>Not a Number</em> is a special floating-point value
        used by the IEEE 754 standard to represent undefined numerical
        results, such as <code>0/0</code>).
        <br/>
        Tables can contain values of all types (except <b>nil</b>).
        Any key associated to the value <b>nil</b> is not considered part of
        the table. Conversely, any key that is not part of a table has
        an associated value <b>nil</b>.
        <br/>
        Tables can be indexed two different ways, given the key
        <code>name</code> we index the table <code>t</code> either as
        <code>t.name</code> or <code>t["name"]</code>.
        The array-like indexing is useful when we want to index the table
        with the value of the variable.
        <br/><br/>
        <!-- list -->
        The type <code>list</code> is a dynamic array of Tokudae values, each
        identified by an <b>index</b>. Each <b>index</b> is an integer
        value starting from <code>0</code>, which is used to index the
        <em>list</em> in order to retrieve the value (variable values can
        also be used in place of literal integers). Negative integer indices
        <em>wrap around</em> and floats convertible to integers are also
        allowed.
        <br/>
        Additionally the list has special built-in fields.
        The fields <code>x</code>, <code>y</code>, <code>z</code> access the
        first, second and third list elements respectively.
        Given the list <code>l</code>, we index it as <code>l.x</code> or
        <code>l["x"]</code>, which is equivalent to <code>l[0]</code>,
        and <code>l.x&nbsp;=&nbsp;"ok"</code> is equivalent to
        <code>l[0]&nbsp;=&nbsp;"ok"</code>.
        The field <code>y</code> corresponds to index&nbsp;<code>1</code> and
        field <code>z</code> to index&nbsp;<code>2</code>.
        <br/>
        Field <code>size</code> is an immutable field that accesses the array
        size of the list.
        The array of the list is the internal memory block where the values
        are stored.
        This number is always a positive integer bigger than or equal to the
        list length. For example, if the list length is equal to the size
        and we are appending a value onto the list, then the list size will
        need to grow in order to fit this new element. This field is useful
        when deciding if it is a good idea to shrink the list. Imagine you
        have a list has been through a lot of insertions and truncations,
        and now the size of the list is multiple times larger than the
        length of the list. Meaning, you have lot's of unused space in the
        underlying array that is just wasting your memory, you should then
        probably shrink the list
        (see <a href="#list.shrink"><code>list.shrink</code></a>).
        <br/>
        The field <code>last</code> accesses the last element in the list.
        If the list length is <code>5</code>, then <code>l.last = 1</code>
        is equivalent to <code>l[4]&nbsp;=&nbsp;1</code>.
        Additionally in order to retrieve the last value you do
        <code>l.last</code> or <code>l["last"]</code>.
        <br/>
        Field <code>len</code> accesses the length of the list. It is an
        immutable field, meaning it can't be set, so the <code>l.len</code>
        or <code>l["len"]</code>, retrieve the list length, but
        <code>l.len&nbsp;=&nbsp;6</code> is an error.
        The list length is a number of non-nil values in a sequence
        starting from the index <code>0</code> (with few exceptions).
        For example, given the list <code>[5,&nbsp;2,&nbsp;nil,&nbsp;7]</code>,
        the length of this list would be <code>2</code>.
        Inserting elements past the list length is an error.
        Appending to the list (inserting at the current length) is allowed,
        if appending <em>nil</em> value, this is a no-op, otherwise the value
        is appended and length is incremented by <code>1</code>.
        Inserting <em>nil</em> into the non-empty list in the range
        <code>[0,&nbsp;len)</code>, truncates the list and the length is set
        to the index which was assigned the <em>nil</em> value.
        <br/>
        Finally in cases where append of non-<em>nil</em> value would fill
        a gap that separated two sequences, the length of the list would still
        be incremented only by <code>1</code>, meaning the two sequences
        are not coalesced. For example, given the list
        <code>[nil,&nbsp;2,&nbsp;3]</code> (length <code>0</code>),
        after the <code>l[0]&nbsp;=&nbsp;5</code>, we would have
        <code>[5,&nbsp;2,&nbsp;3]</code>, but the length would be
        <code>1</code>.
        This is because every value after the list length is unreachable, thus
        subject to GC collection, although this does not affect simple values
        such as numbers, nevertheless the rule is that you can't access any
        value past the length of the list.
        <br/><br/>
        <!-- class -->
        The type <code>class</code> is an abstraction that provides a way to
        bundle data and functionality.
        Class contains <em>methods</em> and <em>metatable</em>.
        Each time you call a <em>class</em> value, it creates a new
        <em>instance</em> of that class value.
        Class values can inherit from other class values, the name of the
        <em>class</em> from which we inherit is called a <em>superclass</em>.
        When inheriting all of the <em>methods</em> and <em>metatable</em>
        entries are copied over from the <em>superclass</em> to the
        <em>class</em> that is inheriting. However after the inherit is done,
        the class being created overrides the superclass methods and metatable
        entries with it's own definitions (in case they collide).
        When defining <em>class</em> methods and <em>metalist</em> entries,
        a class that inherited has access to the <em>superclass</em> object
        through the <code>super</code> keyword.
        <br/>
        As mentioned, classes can also make use of <em>metatables</em> to
        define operations on their instances, besides the already
        defined operations of identity test (<code>==</code>) and the
        assignment.
        <br/><br/>
        <!-- instance -->
        The type <code>instance</code> is similar to <em>table</em>,
        meaning they can be indexed in the same way as tables and therefore
        can hold values (a state), these values are called
        <em>instance fields</em>.
        Each <em>instance</em> is constructed from a <em>class</em>.
        When <em>instance</em> is indexed, first the <em>metatable</em>
        <code>__getidx</code> entry is checked, if not found then the
        <em>instance fields</em> are checked, finally the
        <em>methods table</em> of the <em>instance</em> class is checked.
        <br/><br/>
        <!-- thread -->
        The type <code>thread</code> represents independent threads of execution.
        Tokudae threads are not related to operating-system threads.
        <br/><br/>
        Tables, functions, threads, lists, instances, classes, bound methods
        and full userdata values are objects:
        variables do not actually contain these values,
        only references to them.
        Assignment, parameter passing, and function returns always manipulate
        references to such values; these operations do not imply any kind of
        copy. 
        <br/><br/>
        The library function <a href=#typeof><code>typeof</code></a> returns
        a string describing the type of a given value.
        </p>


        <h2>2.2 &ndash; <a name="2.2">Environments and the Global Environment</a></h2>
        <p>
        As we will discuss further in <a href="#3.2">&sect;3.2</a> and
        <a href="#3.3.3">&sect;3.3.3</a>, any reference to a free name
        (that is, a name not bound to any declaration) <code>var</code>
        is syntactically translated to <code>__ENV.var</code>.
        Moreover, every chunk is compiled in the scope of an external local
        variable named <code>__ENV</code>
        (see <a href="#3.3.2">&sect;3.3.2</a>), so <code>__ENV</code> itself
        is never a free name in a chunk.
        <br/><br/>
        Despite the existence of this external <code>__ENV</code> variable and
        the translation of free names, <code>__ENV</code> is a completely
        regular name.
        In particular, you can define new variables and parameters with
        that name.
        Each reference to a free name uses the <code>__ENV</code> that is
        visible at that point in the program, following the usual visibility
        rules of Tokudae (see <a href="#3.5">&sect;3.5</a>).
        <br/><br/>
        Any table used as the value of <code>__ENV</code> is called an
        <em>environment</em>.
        <br/><br/>
        Tokudae keeps a distinguished environment called the
        <em>global environment</em>.
        This value is kept at a special index in the C&nbsp;table
        (see <a href="#4.3">&sect;4.3</a>).
        In Tokudae, the global variable <a href="#__G"><code>__G</code></a>
        is initialized with this same value.
        (<a href="#__G"><code>__G</code></a> is never used internally,
        so changing its value will affect only your own code.)
        <br/><br/>
        When Tokudae loads a chunk, the default value for its
        <code>__ENV</code> variable is the global environment
        (see <a href="#load"><code>load</code></a>).
        Therefore, by default, free names in Tokudae code refer to entries
        in the global environment and, therefore, they are also called
        <em>global variables</em>.
        Moreover, all standard libraries are loaded in the global environment
        and some functions there operate on that environment.
        You can use <a href="#load"><code>load</code></a>
        (or <a href="#loadfile"><code>loadfile</code></a>) to load a chunk
        with a different environment. (In C, you have to load the chunk and
        then change the value of its first upvalue;
        see <a href="#toku_setupvalue"><code>toku_setupvalue</code></a>.)
        </p>


        <h2>2.3 &ndash; <a name="2.3">Error Handling</a></h2>
        <p>
        Several operations in Tokudae can <em>raise</em> an error.
        An error interrupts the normal flow of the program,
        which can continue by <em>catching</em> the error.
        <br/><br/>
        Tokudae code can explicitly raise an error by calling the
        <a href="#error"><code>error</code></a> function.
        (This function never returns.)
        <br/><br/>
        To catch errors in Tokudae, you can do a <em>protected call</em>,
        using <a href="#pcall"><code>pcall</code></a>
        (or <a href="#xpcall"><code>xpcall</code></a>).
        The function <a href="#pcall"><code>pcall</code></a> calls a
        given function in <em>protected mode</em>.
        Any error while running the function stops its execution,
        and control returns immediately to <code>pcall</code>,
        which returns a status code.
        <br/><br/>
        Because Tokudae is an embedded extension language, Tokudae code
        starts running by a call from C&nbsp;code in the host program.
        (When you use Tokudae standalone, the <code>tokudae</code>
        application is the host program.)
        Usually, this call is protected; so, when an otherwise unprotected
        error occurs during the compilation or execution of a Tokudae chunk,
        control returns to the host, which can take appropriate measures,
        such as printing an error message.
        <br/><br/>
        Whenever there is an error, an <em>error object</em> is propagated
        with information about the error.
        Tokudae itself only generates errors whose error object is a string,
        but programs can generate errors with any value as the error object.
        It is up to the Tokudae program or its host to handle such error
        objects.
        An error object is often called an <em>error message</em>,
        even though it does not have to be a string.
        <br/><br/>
        When you use <a href="#xpcall"><code>xpcall</code></a>
        (or <a href="#toku_pcall"><code>toku_pcall</code></a>, in C)
        you can give a <em>message handler</em> to be called in case of
        errors.
        This function is called with the original error object and returns
        a new error object.
        It is called before the error unwinds the stack, so that it can
        gather more information about the error, for instance by inspecting
        the stack and creating a stack traceback.
        This message handler is still protected by the protected call;
        so, an error inside the message handler will call the message handler
        again.
        If this loop goes on for too long, Tokudae breaks it and returns an
        appropriate message.
        The message handler is called only for regular runtime errors.
        It is not called for memory-allocation errors
        nor for errors while running finalizers or other message handlers.
        <br/><br/>
        Tokudae also offers a system of <em>warnings</em>
        (see <a href="#warn"><code>warn</code></a>).
        Unlike errors, warnings do not interfere in any way with program
        execution.
        They typically only generate a message to the user, although this
        behavior can be adapted from C
        (see <a href="#toku_setwarnf"><code>toku_setwarnf</code></a>).
        </p>


        <h2>2.4 &ndash; <a name="2.4">Metatables and Metamethods</a></h2>
        <p>
        Every value in Tokudae can have a <em>metatable</em>.
        This <em>metatable</em> is an ordinary Tokudae <em>table</em> that
        defines the behaviour of the original value under certain events.
        The values that can have a <em>metatable</em> are <em>classes</em>
        and <em>full userdata</em>. In case of a <em>class</em>, it's
        metatable defines operations on the <em>instance</em> value of
        that class. You can change several aspects of the behaviour of a
        value by setting specific fields in its metatable.
        For example, when a non-numeric values are the operands of an
        addition, Tokudae checks for a function at field <code>__add</code>
        of the value's metatable. In case both operands are <em>instance</em>
        values and both of them belong to the same <em>class</em> which
        contains the <code>__add</code> field in it's <em>metatable</em>,
        then Tokudae calls this function to perform the addition.
        Similarly for <em>full userdata</em>, both operands need to be
        <em>full userdata</em> values and at least one of them has to
        have <code>__add</code> field in it's <em>metatable</em> for the
        Tokudae to call that function to perform the addition.
        <br/><br/>
        The key for each event in a metatable is a string with the event
        name prefixed by two underscores;
        the corresponding value is called a <em>metavalue</em>.
        For most events, the metavalue must be a function, which is then
        called a <em>metamethod</em>.
        In the previous example, the key is the string "<code>__add</code>"
        and the metamethod is the function that performs the addition.
        Unless stated otherwise, a metamethod can in fact be any callable
        value, which is either a function or a value with
        a&nbsp;<code>__call</code> metamethod.
        <details class = "example">
            <summary>
        You can query the metatable of any value using the
        <a href="#getmetatable"><code>getmetatable</code></a> function.</summary>
            <pre>
class Example { 
    __init = || {
        self.name = "Example";
        return self;
    }
    __add = fn(other) {
        assert(getclass(self) == getclass(other));
        assert(getmetatable(self) == getmetatable(other));
        return self.name .. other.name;
    }
}
local init = getmetatable(Example).__init;  /* get '__init' metamethod */
local add = getmetatable(Example).__add;  /* get '__add' metamethod */</pre>
        </details>
        <br/>
        <details class = "example">
            <summary>
        You can replace the metatable of a <em>class</em>
        (or <em>instance</em>) using the
        <a href="#setmetatable"><code>setmetatable</code></a> function.</summary>
            <pre>
class Example {}
assert(getmetatable(Example) == nil);
local mt = {  /* metatable with '__init' key and metamethod value */
    __init = |self| {
        self.name = "Example";
        return self;
    }
};
setmetatable(Example, mt);  /* set 'Example' class metatable */
assert(getmetatable(Example).__init);</pre>
        </details>
        <br/>
        You cannot change the metatable of <em>full userdata</em> from
        Tokudae code, except by using the debug library
        (see <a href="#6.11">&sect;6.11</a>).
        <br/><br/>
        Classes and full userdata have individual metatables, although
        multiple classes and full userdata can share their metatables.
        Naturally all of the instances of the same class share their
        metatable, so by changing the metatable of an instance or
        the underlying class, you change the metatable of all other instances
        of that class. To be more precise, the instances do not have
        metatables, their classes do.
        <br/><br/>
        A detailed list of operations controlled by metatable is given next.
        By convention, all metamethod keys used by Tokudae are composed by
        two underscores followed by lowercase Latin letters.
        <ul>
            <li>
                <b><code>__add</code>: </b>
                the addition (<code>+</code>) operation.
                If only one operand for an addition is not a number,
                Tokudae raises an error. If both operand for an addition are
                not numbers, Tokudae will try to call a metamethod.
                It first checks that the types of the operands match.
                Then if the operands are instances, it checks if they are
                the instances of the same class, and finally it checks for
                the presence of <code>__add</code> in metatable of the class
                (if any).
                In case operands are full userdata, first it checks for the
                presence of <code>__add</code> in the first full userdata
                metatable, if the metamethod is not found it tries to get
                it from the metatable of the second full userdata.
                Finally if the metamethod is found, it will call it with the
                two operands as arguments (order of operands is left intact).
                It returns a single result, otherwise, if no metamethod is
                found, or the conditions mentioned above do not hold, Tokudae
                raises an error.
            </li>
            <li>
                <b><code>__sub</code>: </b>
                the subtraction (<code>-</code>) operation.
                Behavior similar to the addition operation.
            </li>
            <li>
                <b><code>__mul</code>: </b>
                the multiplication (<code>*</code>) operation.
                Behavior similar to the addition operation.
            </li>
            <li>
                <b><code>__div</code>: </b>
                the float division (<code>/</code>) operation.
                Behavior similar to the addition operation.
            </li>
            <li>
                <b><code>__idiv</code>: </b>
                the integer division (<code>//</code>) operation.
                Behavior similar to the addition operation.
            </li>
            <li>
                <b><code>__mod</code>: </b>
                the modulo (<code>%</code>) operation.
                Behavior similar to the addition operation.
            </li>
            <li>
                <b><code>__pow</code>: </b>
                the exponentiation (<code>**</code>) operation.
                Behavior similar to the addition operation.
            </li>
            <li>
                <b><code>__unm</code>: </b>
                the negation (unary <code>-</code>) operation.
                Behavior similar to the addition operation, except
                the function is called with a single argument.
            </li>
            <li>
                <b><code>__band</code>: </b>
                the bitwise AND (<code>&amp;</code>) operation.
                Behavior similar to the addition operation, except that
                in case both operands are numbers but one of them is a float
                not coercible to integer, Tokudae raises an error.
                (see <a href="#3.4.3">&sect;3.4.3</a>).
            </li>
            <li>
                <b><code>__bor</code>: </b>
                the bitwise OR (<code>|</code>) operation.
                Behavior similar to the bitwise AND operation.
            </li>
            <li>
                <b><code>__bxor</code>: </b>
                the bitwise exclusive OR (binary <code>^</code>) operation.
                Behavior similar to the bitwise AND operation.
            </li>
            <li>
                <b><code>__bnot</code>: </b>
                the bitwise NOT (unary <code>~</code>) operation.
                Behavior similar to the bitwise AND operation, except
                the function is called with a single argument.
            </li>
            <li>
                <b><code>__shl</code>: </b>
                the bitwise left shift (<code>&lt;&lt;</code>) operation.
                Behavior similar to the bitwise AND operation.
            </li>
            <li>
                <b><code>__shr</code>: </b>
                the bitwise right shift (<code>&gt;&gt;</code>) operation.
                Behavior similar to the bitwise AND operation.
            </li>
            <li>
                <b><code>__concat</code>: </b>
                the concatenation (<code>..</code>) operation.
                Behavior similar to the addition operation, except that
                Tokudae will try a metamethod if either operand is not
                a string.
            </li>
            <li>
                <b><code>__eq</code>: </b>
                the equal (<code>==</code>) operation.
                Behavior similar to the addition operation.
                The result of the call is always converted to a boolean.
            </li>
            <li>
                <b><code>__lt</code>: </b>
                the less than (<code>&lt;</code>) operation.
                Behavior similar to the addition operation,
                except that Tokudae will try a metamethod when both
                of the values are neither a number nor string, 
                Moreover, the result of the call is always converted to
                a boolean.
            </li>
            <li>
                <b><code>__le</code>: </b>
                the less equal (<code>&lt;=</code>) operation.
                Behavior similar to the less than operation.
            </li>
            <li>
                <b><code>__getidx</code>: </b>
                The indexing access operation <code>v[key]</code>.
                This event happens when value <code>v</code> is an instance
                or full userdata that implements this metamethod.
                This function is called with <code>v</code> and
                <code>key</code> as arguments, and returns a single result.
            </li>
            <li>
                <b><code>__setidx</code>: </b>
                The indexing assignment <code>v[key] = value</code>.
                Like the <code>__getidx</code> event, this event happens
                when value <code>v</code> is an instance or full userdata
                that implements this metamethod.
                This function is called with <code>v</code>, <code>key</code>
                and <code>value</code> as arguments, and returns no results.
            </li>
            <li>
                <b><code>__call</code>: </b>
                The call operation <code>func(args)</code>.
                This event happens when Tokudae tries to call a value that
                is not a function, a bound method or a class.
                The metamethod is looked up in <code>func</code>.
                If present, the metamethod is called with <code>func</code>
                as its first argument, followed by the arguments of the
                original call (<code>args</code>).
                All results of the call are the results of the operation.
                This is the only metamethod that allows multiple results.
            </li>
            <li>
                <b><code>__init</code>: </b>
                This is special call operation. This event occurs when class
                value is called, such as <code>MyClass(args)</code>
                (where <code>MyClass</code> is a class value).
                If present, newly created instance of the class that was
                called is passed as the argument to this function, followed
                by the arguments of the original call (<code>args</code>).
                This function returns a single result, usually the instance
                object that was created (the first argument).
                This is a useful event for initializing the newly created
                instance (as the name suggests).
            </li>
        </ul>
        In addition to the previous list, the interpreter also implements
        the following events:
        <code>__gc</code> (see <a href="#2.5.2">&sect;2.5.2</a>),
        <code>__close</code> (see <a href="#3.3.8">&sect;3.3.8</a>),
        and <code>__name</code>.
        The entry <code>__name</code>, when it contains a string, may be
        used by <a href="#tostr"><code>tostr</code></a> and in error messages.
        <br/><br/>
        Because metatables are regular tables, they can contain arbitrary
        fields, not only the event names defined above.
        Some functions in the standard library
        (e.g., <a href="#tostr"><code>tostr</code></a>)
        use other fields in metatables for their own purposes.
        <br/><br/>
        It is a good practice to add all needed metamethods to a table
        before setting it as a metatable of some object.
        In particular, the <code>__gc</code> metamethod works only when this
        order is followed (see <a href="#2.5.2">&sect;2.5.2</a>).
        It is also a good practice to set the metatable of an object
        right after its creation or in the constructor in case of class.
        </p>


        <h2>2.5 &ndash; <a name="2.5">Garbage Collection</a></h2>
        <p>
        Tokudae performs automatic memory management.
        This means that you do not have to worry about allocating memory
        for new objects or freeing it when the objects are no longer needed.
        Tokudae manages memory automatically by running a
        <em>garbage collector</em> to collect all <em>dead</em> objects.
        All memory used by Tokudae is subject to automatic management:
        strings, tables, lists, userdata, functions, threads, classes,
        instances, internal structures, etc.
        <br/><br/>
        An object is considered <em>dead</em> as soon as the collector
        can be sure the object will not be accessed again in the normal
        execution of the program.
        ("Normal execution" here excludes finalizers, which can resurrect
        dead objects (see <a href="#2.5.2">&sect;2.5.2</a>).)
        Note that the time when the collector can be sure that an object
        is dead may not coincide with the programmer's expectations.
        The only guarantees are that Tokudae will not collect an object
        that may still be accessed in the normal execution of the program,
        and it will eventually collect an object that is inaccessible from
        Tokudae.
        (Here, <em>inaccessible from Tokudae</em> means that neither a
        variable nor another live object refer to the object.)
        Because Tokudae has no knowledge about C&nbsp;code, it never
        collects objects accessible through the C&nbsp;table or C&nbsp;list
        (see <a href="#4.3">&sect;4.3</a>),
        which includes the global environment
        (see <a href="#2.2">&sect;2.2</a>).
        <br/><br/>
        The garbage collector (GC) in Tokudae is incremental.
        <br/><br/>
        Default GC parameters are adequate for most uses.
        However, programs that waste a large proportion of their time
        allocating and freeing memory can benefit from other settings.
        Keep in mind that the GC behavior is non-portable both across
        platforms and across different Tokudae releases; therefore,
        optimal settings are also non-portable.
        <br/><br/>
        You can change the GC parameters by calling
        <a href="#toku_gc"><code>toku_gc</code></a> in&nbsp;C or
        <a href="#gc"><code>gc</code></a> in Tokudae.
        You can also use these functions to control the collector directly
        (e.g., to stop and restart it).
        </p>


        <h3>2.5.1 &ndash; <a name="2.5.1">Incremental Garbage Collection</a></h3>
        <p>
        In incremental mode, each GC cycle performs a mark-and-sweep
        collection in small steps interleaved with the program's execution.
        In this mode, the collector uses three numbers to control its
        garbage-collection cycles:
        the <em>garbage-collector pause</em>,
        the <em>garbage-collector step multiplier</em>,
        and the <em>garbage-collector step size</em>.
        <br/><br/>
        The garbage-collector pause controls how long the collector waits
        before starting a new cycle.
        The collector starts a new cycle when the use of memory hits
        <em>n%</em> of the use after the previous collection.
        Larger values make the collector less aggressive.
        Values equal to or less than 100 mean the collector will not wait
        to start a new cycle.
        A value of 200 means that the collector waits for the total memory
        in use to double before starting a new cycle.
        The default value is 200; the maximum value is 1000.
        <br/><br/>
        The garbage-collector step multiplier controls the speed of the
        collector relative to memory allocation, that is, how many elements
        it marks or sweeps for each kilobyte of memory allocated.
        Larger values make the collector more aggressive but also increase
        the size of each incremental step.
        You should not use values less than 100, because they make the
        collector too slow and can result in the collector never finishing
        a cycle.
        The default value is 100; the maximum value is 1000.
        <br/><br/>
        The garbage-collector step size controls the size of each incremental
        step, specifically how many bytes the interpreter allocates before
        performing a step.
        This parameter is logarithmic:
        A value of <em>n</em> means the interpreter will allocate
        <em>2<sup>n</sup></em> bytes between steps and perform equivalent
        work during the step.
        A large value (e.g., 60) makes the collector a stop-the-world
        (non-incremental) collector.
        The default value is 13, which means steps of approximately
        8&nbsp;Kbytes.


        <h3>2.5.2 &ndash; <a name="2.5.2">Garbage-Collection Metamethods</a></h3>
        <p>
        You can set garbage-collector metamethods for classes and, using the
        C&nbsp;API, for full&nbsp;userdata (see <a href="#2.4">&sect;2.4</a>).
        These metamethods, called <em>finalizers</em>, are called when
        the garbage collector detects that the corresponding instance or
        userdata is dead.
        Finalizers allow you to coordinate Tokudae's garbage collection
        with external resource management such as closing files, network
        or database connections, or freeing your own memory.
        <br/><br/>
        For an object (instance or userdata) to be finalized when collected,
        you must <em>mark</em> it for finalization.
        You mark an object for finalization when you set its metatable and
        metatable has <code>__gc</code> field.
        Note that if you set a metatable without setting <code>__gc</code>
        field and later set that field in the metatable, the object will
        not be marked for finalization.
        <br/><br/>
        When a marked object becomes dead, it is not collected immediately
        by the garbage collector.
        Instead, Tokudae puts it in a (linked)list.
        After the collection, Tokudae goes through that list.
        For each object in the list, it checks the object's
        <code>__gc</code> metamethod:
        If it is present, Tokudae calls it with the object as its single
        argument.
        <br/><br/>
        At the end of each garbage-collection cycle, the finalizers are
        called in the reverse order that the objects were marked for
        finalization, among those collected in that cycle;
        that is, the first finalizer to be called is the one associated
        with the object marked last in the program.
        The execution of each finalizer may occur at any point during
        the execution of the regular code.
        <br/><br/>
        Because the object being collected must still be used by the finalizer,
        that object (and other objects accessible only through it) must be
        <em>resurrected</em> by Tokudae.
        Usually, this resurrection is transient, and the object memory is
        freed in the next garbage-collection cycle.
        However, if the finalizer stores the object in some global place
        (e.g., a global variable), then the resurrection is permanent.
        Moreover, if the finalizer marks a finalizing object for finalization
        again, its finalizer will be called again in the next cycle where
        the object is dead.
        In any case, the object memory is freed only in a GC cycle where
        the object is dead and not marked for finalization.
        <br/><br/>
        When you close a state
        (see <a href="#toku_close"><code>toku_close</code></a>), Tokudae calls
        the finalizers of all objects marked for finalization,
        following the reverse order that they were marked.
        If any finalizer marks objects for collection during that phase,
        these marks have no effect.
        <br/><br/>
        Finalizers cannot run the garbage collector.
        Because they can run in unpredictable times, it is good practice
        to restrict each finalizer to the minimum necessary to properly
        release its associated resource.
        <br/><br/>
        Any error while running a finalizer generates a warning;
        the error is not propagated.
        </p>




        <h1>3 &ndash; <a name="3">The Language</h1>
        <p>
        This section describes the lexis, the syntax, and the semantics
        of Tokudae.
        In other words, this section describes which tokens are valid,
        how they can be combined, and what their combinations mean.
        <br/><br/>
        Language constructs will be explained using the usual extended
        BNF notation, in which
        {<em>a</em>}&nbsp;means&nbsp;0 or more <em>a</em>'s, and
        [<em>a</em>]&nbsp;means an optional <em>a</em>.
        Non-terminals are shown like non-terminal, keywords are shown
        like <b>kword</b>, and other terminal symbols are shown like
        &lsquo;<b>=</b>&rsquo;.
        The complete syntax of Tokudae can be found in
        <a href="#9">&sect;9</a> at the end of this manual.
        </p>


        <h2>3.1 &ndash; <a name="3.1">Lexical Conventions</a></h2>
        <p>
        Tokudae is a free-form language.
        It ignores spaces and comments between lexical elements (tokens),
        except as delimiters between two tokens.
        In source code, Tokudae recognizes as spaces the standard ASCII
        whitespace characters space, form feed, newline, carriage return,
        horizontal tab, and vertical tab.
        <br/><br/>
        <em>Names</em> (also called <em>identifiers</em>) in Tokudae can be
        any string of Latin letters, Arabic-Indic digits, and underscores,
        not beginning with a digit and not being a reserved word.
        Identifiers are used to name variables and table or instance
        fields.
        <br/><br/>
        The following <em>keywords</em> are reserved and cannot be used as
        names:

        <pre>
    and       or        break     continue  if        else
    false     true      for       foreach   in        while
    do        loop      fn        switch    case      default
    class     inherits  local     nil       super     return</pre>

        Tokudae is a case-sensitive language:
        <code>and</code> is a reserved word, but <code>And</code> and
        <code>AND</code> are two different, valid names.
        As a convention, programs should avoid creating names that start
        with two underscores followed by one or more uppercase letters
        (such as <a href="#__VERSION"><code>__VERSION</code></a>).
        <br/><br/>
        The following strings denote other tokens:

        <pre>
    +     -     *     /     //    %
    ^     !     &amp;     |     &lt;&lt;    &gt;&gt;    **
    ==    !=    &lt;=    &gt;=    &lt;     &gt;     =
    +=    -=    *=    /=    //=   %=    ^=
    ..=   &amp;=    !=    |=    &lt;&lt;=   &gt;&gt;=   **=
    (     )     {     }     [     ]     ?
    ;     ,     .     ..    ...</pre>

        A <em>short literal string</em> can be delimited by matching single
        or double quotes, and can contain the following C-like escape
        sequences:
        '<code>\a</code>' (bell),
        '<code>\b</code>' (backspace),
        '<code>\f</code>' (form feed),
        '<code>\n</code>' (newline),
        '<code>\r</code>' (carriage return),
        '<code>\t</code>' (horizontal tab),
        '<code>\v</code>' (vertical tab),
        '<code>\e</code>' (ANSI escape),
        <br/>
        '<code>\\</code>' (backslash),
        '<code>\"</code>' (quotation mark [double quote]),
        and '<code>\'</code>' (apostrophe [single quote]).
        A backslash followed by a line break results in a newline in the
        string.
        A short literal string cannot contain unescaped line breaks
        nor escapes not forming a valid escape sequence.
        <br/><br/>
        We can specify any byte in a short literal string, including
        embedded zeros, by its numeric value.
        This can be done with the escape sequence <code>\x<em>XX</em></code>,
        where <em>XX</em> is a sequence of exactly two hexadecimal digits,
        or with the escape sequence <code>\<em>ddd</em></code>,
        where <em>ddd</em> is a sequence of up to three decimal digits.
        (Note that if a decimal escape sequence is to be followed by a digit,
        it must be expressed using exactly three digits.)
        <br/><br/>
        The UTF-8 encoding of a Unicode character can be inserted in a
        literal string with the escape sequence <code>\u{<em>XXX</em>}</code>
        (with mandatory enclosing braces), where <em>XXX</em> is a sequence
        of one or more hexadecimal digits representing the character code
        point.
        This code point can be any value less than <em>2<sup>31</sup></em>.
        (Tokudae uses the original UTF-8 specification here, which is not
        restricted to valid Unicode code points.)
        Additionally you can specify UTF-8 encoding with
        <code>\u[<em>XXX</em>]</code>, which is identical to the previous
        example but this will additionally check if the sequence is a
        valid Unicode code point (according to the UTF-8 RFC 3629) and throw
        syntax error otherwise.
        <br/><br/>
        Literal strings can also be defined using a long format
        enclosed by <em>long brackets</em>.
        We define an <em>opening long bracket of level <em>n</em></em> as an
        opening square bracket followed by <em>1+n</em>&nbsp;'<code>=</code>'
        signs followed by another opening square bracket.
        So, an opening long bracket of level&nbsp;0 is written as
        <code>[=[</code>, an opening long bracket of level&nbsp;1 is
        written as <code>[==[</code>, and so on.
        A <em>closing long bracket</em> is defined similarly; for instance,
        a closing long bracket of level&nbsp;4 is written as <code>]=====]</code>.
        A <em>long literal</em> starts with an opening long bracket of any
        level and ends at the first closing long bracket of the same level.
        It can contain any text except a closing bracket of the same level.
        Literals in this bracketed form can run for several lines,
        do not interpret any escape sequences, and ignore long brackets of
        any other level. Any kind of end-of-line sequence
        (carriage return, newline, carriage return followed by newline,
        or newline followed by carriage return)
        is converted to a simple newline.
        When the opening long bracket is immediately followed by a newline,
        the newline is not included in the string.
        <br/><br/>
        As an example, in a system using ASCII
        (in which '<code>a</code>' is coded as&nbsp;97, newline is coded
        as&nbsp;10, and '<code>1</code>' is coded as&nbsp;49),
        the four literal strings below denote the same string:

        <pre>
     a = "alo\n123\"";
     a = "\97lo\10\04923\"";
     a = [=[alo
     123"]=];
     a = [==[
     alo
     123"]==];</pre>

        Any byte in a literal string not explicitly affected by the
        previous rules represents itself.
        However, Tokudae opens files for parsing in text mode, and the
        system's file functions may have problems with some control
        characters.
        So, it is safer to represent binary data as a quoted literal with
        explicit escape sequences for the non-text characters.
        <br/><br/>
        A <em>numeric constant</em> (or <em>numeral</em>) can be written
        with an optional fractional part and an optional decimal exponent,
        marked by a letter '<code>e</code>' or '<code>E</code>'.
        Tokudae also accepts hexadecimal constants, which start with
        <code>0x</code> or <code>0X</code>, also the octal constants, which
        start with <code>0</code>, and binary constants which start with
        <code>0b</code> or <code>0B</code>.
        Octal constants (integers that start with leading zero) that contain
        decimal digit(s) are interpreted as decimal numbers.
        A <em>constant</em> <code>inf</code> or <code>infinity</code>
        represent positive infinity (putting '<code>-</code>' in front denotes
        negative infinity).
        Additionally all <em>numeric constants</em> can have '<code>_</code>'
        in between digits (after first digit), this acts as a separator,
        however this separator is not allowed in fractional part.
        Hexadecimal constants also accept an optional fractional part
        plus an optional binary exponent, marked by a letter
        '<code>p</code>' or '<code>P</code>' and written in decimal.
        (For instance, <code>0x1.fp10</code> denotes 1984,
        which is <em>0x1f / 16</em> multiplied by <em>2<sup>10</sup></em>.)
        Hexadecimal constants that have the fractional part, must also have
        the binary exponent.
        If you wish to declare a hexadecimal float constant, but do not
        need the binary exponent, you can just set the binary exponent to
        <code>p0</code> or <code>P0</code>
        (which is <em>2<sup>0</sup> == 1</em>).
        <br/><br/>
        A numeric constant with a radix point or an exponent denotes a float;
        otherwise, if its value fits in an integer or it is a hexadecimal,
        octal or binary constant, it denotes an integer.
        Hexadecimal numerals with neither a radix point nor an exponent
        always denote an integer value.
        If the <em>numeric integer constant</em> overflows or underflows,
        Tokudae will convert it to a float. If it still overflows,
        it will be set to the positive or negative infinity or in case if it
        still underflows, it will be set to the float value with magnitude
        no larger than
        <a name="TOKU_NUMBER_MIN"><code>TOKU_NUMBER_MIN</code></a>
        (see <code>tokudaeconf.h</code> header), and finally Tokudae will
        throw a warning (if warnings are enabled).
        <br/><br/>
        Examples of valid integer constants are

        <pre>
    3   345   0xff   0xBEBADA   015   000   15_523_123   0b1111_0011</pre>

        Examples of valid float constants are

        <pre>
    3.0      3.1416      .153      14.16e-2      15_001.31416E1      34e1
    0x.1Ep0  0xA23p-4    0X1.921FB54442D18P+1    0x82_3A5.1124BFP1
    inf      infinity</pre>

        A <em>short comment</em> starts with either a pound sign
        (<code>#</code>) or triple forward slash (<code>///</code>)
        and runs until the end of the line.
        A <em>long comment</em> starts with a forward slash and
        asterisk sign (<code>/*</code>) and is delimited by asterisk sign and
        forward slash (<code>*/</code>).
        These <em>comments</em> are valid anywhere outside of a string.


        <h2>3.2 &ndash; <a name="3.2">Variables</a></h2>
        <p>
        Variables are places that store values.
        There are three kinds of variables in Tokudae:
        global variables, local variables and table or instance fields.
        <br/><br/>
        A single name can denote a global variable or a local variable
        (or a function's formal parameter, which is a particular kind
        of local variable):

        <pre>
    var ::= Name</pre>

        Name denotes identifiers (see <a href="#3.1">&sect;3.1</a>).
        <br/><br/>
        Any variable name is assumed to be global unless explicitly declared
        as a local (see <a href="#3.3.7">&sect;3.3.7</a>).
        Local variables are <em>lexically scoped</em>:
        local variables can be freely accessed by functions
        defined inside their scope (see <a href="#3.5">&sect;3.5</a>).
        <br/><br/>
        Before the first assignment to a variable, its value is <b>nil</b>.
        <br/><br/>
        Square brackets are used to index a table, list or instance:

        <pre>
    var ::= prefixexp &lsquo;<b>[</b>&rsquo; exp &lsquo;<b>]</b>&rsquo;</pre>

        The meaning of accesses to instance fields can be changed via
        metamethods (see <a href="#2.4">&sect;2.4</a>).
        <br/><br/>
        The syntax <code>var.Name</code> is just syntactic sugar for
        <code>var["Name"]</code>:

        <pre>
    var ::= prefixexp &lsquo;<b>.</b>&rsquo; Name</pre>

        An access to a global variable <code>x</code> is equivalent to
        <code>__ENV.x</code>. Due to the way that chunks are compiled,
        the variable <code>__ENV</code> itself is never global
        (see <a href="#2.2">&sect;2.2</a>).
        </p>


        <h2>3.3 &ndash; <a name="3.3">Declarations and Statements</a></h2>
        <p>
        Tokudae supports (almost) identical set of statements as found in C.
        This set includes blocks, assignments, control structures, function calls.
        In order to define new local variables, Tokudae syntax defines
        declarations (see <a href="#3.3.7">&sect;3.3.7</a>).
        Statement is considered to be a declaration, while declaration is
        not considered to be a statement.
        </p>


        <h3>3.3.1 &ndash; <a name="3.3.1">Blocks</a></h3>
        <p>
        A block is a list of declarations with its own scope enclosed in
        between curly braces.
        These declarations are executed sequentially:

        <pre>
    stm ::= blockstm
    blockstm ::= &lsquo;<b>{</b>&rsquo; loopblock &lsquo;<b>}</b>&rsquo;
    loopblock ::= {decl} [continuestm] | switchblock
    switchblock ::= {decl} [breakstm] | block
    block ::= {decl} [returnstm]</pre>
        </p>


        <h3>3.3.2 &ndash; <a name="3.3.2">Chunks</a></h3>
        <p>
        The unit of compilation of Tokudae is called a <em>chunk</em>.
        Syntactically, a chunk is simply a block without curly braces:

        <pre>
    chunk ::= block</pre>

        Tokudae handles a chunk as the body of an anonymous function
        with a variable number of arguments
        (see <a href="#3.4.11">&sect;3.4.11</a>).
        As such, chunks can define local variables, receive arguments,
        and return values.
        Moreover, such anonymous function is compiled as in the global scope
        (see <a href="#2.2">&sect;2.2</a>).
        <br/><br/>
        A chunk can be stored in a file or in a string inside the host program.
        To execute a chunk, Tokudae first <em>loads</em> it, precompiling the
        chunk's code into instructions for a virtual machine, and then Tokudae
        executes the compiled code with an interpreter for the virtual machine.
        </p>


        <h3>3.3.3 &ndash; <a name="3.3.3">Compound and Regular Assignment</a></h3>
        <p>
        Tokudae allows multiple compound or regular assignments.
        Therefore, the syntax for assignment defines a list of variables
        on the left side and a list of expressions on the right side.
        The elements in both lists are separated by commas and the statement
        is terminated by a semicolon:

        <pre>
    stm ::= expstm &lsquo;<b>;</b>&rsquo;
    expstm ::= varlist assignop explist
    assignop ::= &lsquo;<b>=</b>&rsquo; | &lsquo;<b>+=</b>&rsquo; | &lsquo;<b>-=</b>&rsquo; | &lsquo;<b>*=</b>&rsquo; 
               | &lsquo;<b>/=</b>&rsquo; | &lsquo;<b>//=</b>&rsquo; | &lsquo;<b>**=</b>&rsquo; | &lsquo;<b>%=</b>&rsquo; 
               | &lsquo;<b>&=</b>&rsquo; | &lsquo;<b>|=</b>&rsquo; | &lsquo;<b>^=</b>&rsquo; | &lsquo;<b>&gt;&gt;=</b>&rsquo; 
               | &lsquo;<b>&lt;&lt;=</b>&rsquo; | &lsquo;<b>..=</b>&rsquo;
    varlist ::= var {&lsquo;<b>,</b>&rsquo; var}
    explist ::= exp {&lsquo;<b>,</b>&rsquo; exp}</pre>

        Expressions are discussed in <a href="#3.4">&sect;3.4</a>.
        <br/>
        There is also increment/decrement assignment:

        <pre>
    expstm ::= var &lsquo;<b>++</b>&rsquo; | var &lsquo;<b>--</b>&rsquo;</pre>

        Before the compound or regular assignment,
        the list of values is <em>adjusted</em> to the length of
        the list of variables (see <a href="#3.4.12">&sect;3.4.12</a>).
        <br/><br/>
        If a variable is both assigned and read inside a multiple assignment,
        Tokudae ensures that all reads get the value of the variable
        before the assignment.
        Thus the code

        <pre>
    i = 3;
    i, a[i] = i+1, 20;</pre>

        sets <code>a[3]</code> to 20, without affecting <code>a[4]</code>
        because the <code>i</code> in <code>a[i]</code> is evaluated (to 3)
        before it is assigned&nbsp;4.
        Similarly, the line

        <pre>
     x, y = y, x;</pre>

        exchanges the values of <code>x</code> and <code>y</code>,
        and

        <pre>
     x, y, z = y, z, x;</pre>

        cyclically permutes the values of <code>x</code>, <code>y</code>
        and <code>z</code>.
        <br/><br/>
        Note that this guarantee covers only accesses syntactically inside
        the assignment statement.
        If a function or a metamethod called during the assignment
        changes the value of a variable, Tokudae gives no guarantees about
        the order of that access.
        <br/><br/>
        The meaning of assignments to instance fields can be changed via
        metamethods (see <a href="#2.4">&sect;2.4</a>).
        <br/><br/>
        Additionally, this compound assignment:

        <pre>
    a, b += 2, 3;</pre>

        is equivalent to:

        <pre>
    a, b = a + 2, b + 3;</pre>

        and this one:

        <pre>
    a++;
    b--;</pre>

        is equivalent to:

        <pre>
    a = a + 1;
    b = b - 1;</pre>
        </p>


        <h3>3.3.4 &ndash; <a name="3.3.4">Control Structures</a></h3>
        <p>
        The control structures <b>if</b>, <b>do</b>/<b>while</b>, <b>for</b>,
        <b>loop</b> and <b>switch</b> have the usual meaning and
        familiar syntax:

        <pre>
    stm ::= dowhilestm | whilestm | forstm | loopstm | ifstm | switchstm
    whilestm ::= <b>while</b> exp stm
    dowhilestm ::= <b>do</b> stm <b>while</b> exp &lsquo;<b>;</b>&rsquo;
    forstm ::= <b>for</b> forclauses stm
    forclauses ::= &lsquo;<b>(</b>&rsquo; forinfix &lsquo;<b>)</b>&rsquo; | forinfix &lsquo;<b>;</b>&rsquo;
    forinfix ::= [forinit] &lsquo;<b>;</b>&rsquo; [exp] &lsquo;<b>;</b>&rsquo; [expstm]
    forinit ::= localstm | expstm
    loopstm ::= <b>loop</b> stm
    ifstm ::= <b>if</b> exp stm [<b>else</b> stm]
    switchstm ::= <b>switch</b> exp switchbody
    switchbody ::= &lsquo;<b>{</b>&rsquo; {<b>case</b> exp &rsquo;<b>:</b>&lsquo; {stm}} [<b>default</b> &rsquo;<b>:</b>&lsquo; {stm}] &lsquo;<b>}</b>&rsquo;</pre>

        Tokudae also has a generic <b>foreach</b> loop
        (see <a href="#3.3.5">&sect;3.3.5</a>).
        <br/><br/>
        The condition expression of a control structure can return any value.
        Both <b>false</b> and <b>nil</b> test false.
        All values different from <b>nil</b> and <b>false</b> test true.
        In particular, the number 0 and the empty string also test true.
        <br/><br/>
        The <b>break</b> statement terminates the execution of a
        <b>switch</b> statement and <b>do</b>/<b>while</b>, <b>loop</b>,
        or <b>for</b> loops, skipping to the next statement
        (after the loop or switch):

        <pre>
    stm ::= breakstm
    breakstm ::= <b>break</b> &lsquo;<b>;</b>&rsquo;</pre>

        A <b>break</b> ends the innermost enclosing loop or switch statement,
        and as such it must be written as the last statement of a block.
        <br/><br/>
        The <b>continue</b> statement is used to skip the current iteration
        and proceed to the next iteration of the loop:

        <pre>
    stm ::= continuestm
    continuestm ::= <b>continue</b> &lsquo;<b>;</b>&rsquo;</pre>

        When a <b>continue</b> statement is encountered, the remaining
        statements in the loop body are skipped, and control is transferred
        to the loop's next iteration (wherever that might be).
        <b>break</b> also must be written as the last statement of the
        current block.

        The <b>return</b> statement is used to return values from a function
        or a chunk (which is handled as an anonymous function).
        Functions can return more than one value, so the syntax for the
        <b>return</b> statement is

        <pre>
    stm ::= returnstm
    returnstm ::= <b>return</b> [explist] [&lsquo;<b>;</b>&rsquo;]</pre>

        Finally the <b>return</b> statement can also only be written as the
        last statement of a block or a chunk.
        If it is necessary to <b>return</b> in the middle of a block,
        then an explicit inner block can be used: <code>{ return; }</code>,
        because now <b>return</b> is the last statement in its (inner) block
        (this also applies to <b>break</b> and <b>continue</b>).
        </p>


        <h3>3.3.5 &ndash; <a name="3.3.5">Foreach Statement</a></h3>
        <p>
        The <b>foreach</b> statement is a generic loop.
        This statement works over functions, called <em>iterators</em>.
        On each iteration, the iterator function is called to produce a new
        value, stopping when this new value is <b>nil</b>.
        The generic <b>foreach</b> loop has the following syntax:

        <pre>
    stm ::= foreachstm
    foreachstm ::= <b>foreach</b> namelist <b>in</b> forexplist stm
    namelist ::= Name {&lsquo;<b>,</b>&rsquo; Name}
    forexplist ::= exp [&lsquo;<b>,</b>&rsquo; exp [&lsquo;<b>,</b>&rsquo; exp [&lsquo;<b>,</b>&rsquo; exp]]]</pre>

        A <b>foreach</b> statement like

        <pre>
    foreach <em>var_1</em>, &middot;&middot;&middot;, <em>var_n</em> in <em>forexplist</em> <em>stm</em></pre>

        works as follows.
        <br/><br/>
        The names <em>var_i</em> declare loop variables local to the loop body.
        The first of these variables is the <em>control variable</em>.
        <br/>
        The loop starts by evaluating <em>explist</em> to produce four values:
        an <em>iterator function</em>, a <em>state</em>, an initial value for
        the control variable, and a <em>closing value</em>.
        <br/>
        Then, at each iteration, Tokudae calls the iterator function with
        two arguments: the state and the control variable.
        The results from this call are then assigned to the loop variables,
        following the rules of multiple assignments
        (see <a href="#3.3.3">&sect;3.3.3</a>).
        If the control variable becomes <b>nil</b>, the loop terminates.
        Otherwise, the statement is executed and the loop goes to the next
        iteration.
        <br/><br/>
        The closing value behaves like a to-be-closed variable
        (see <a href="#3.3.8">&sect;3.3.8</a>), which can be used to release
        resources when the loop ends.
        Otherwise, it does not interfere with the loop.
        <br/><br/>
        You should not change the value of the control variable
        during the loop.
        </p>


        <h3>3.3.6 &ndash; <a name="3.3.6">Function Calls as Statements</a></h3>
        <p>
        To allow possible side-effects,
        function calls can be executed as statements:

        <pre>
    stm ::= call &lsquo;<b>;</b>&rsquo;</pre>

        In this case, all returned values are thrown away.
        Function calls are explained in <a href="#3.4.10">&sect;3.4.10</a>.
        </p>


        <h3>3.3.7 &ndash; <a name="3.3.7">Local Declarations</a></h3>
        <p>
        Local variables can be declared anywhere inside a block.
        The declaration can include an initialization:

        <pre>
    decl ::= localstm &lsquo;<b>;</b>&rsquo; | localfn | localclass | stm
    localstm ::= <b>local</b> attnamelist [&lsquo;<b>=</b>&rsquo; explist]
    attnamelist ::=  Name [attrib] {&lsquo;<b>,</b>&rsquo; Name [attrib]}</pre>

        If present, an initial assignment has the same semantics
        of a multiple assignment (see <a href="#3.3.3">&sect;3.3.3</a>).
        Otherwise, all variables are initialized with <b>nil</b>.
        <br/><br/>
        Each variable name may be postfixed by an attribute
        (a name between angle brackets):

        <pre>
    attrib ::= &lsquo;<b>&lt;</b>&rsquo; Name &lsquo;<b>&gt;</b>&rsquo;</pre>

        There are two possible attributes:
        <code>final</code>, which declares immutable variable, that is,
        a variable that cannot be assigned to after its initialization;
        and <code>close</code>, which declares a to-be-closed variable
        (see <a href="#3.3.8">&sect;3.3.8</a>).
        A list of variables can contain at most one to-be-closed variable.
        <br/><br/>
        A chunk is also a block (see <a href="#3.3.2">&sect;3.3.2</a>),
        and so local variables can be declared in a chunk outside any
        explicit block.
        <br/><br/>
        The visibility rules for local variables are explained in
        <a href="#3.5">&sect;3.5</a>.
        </pre>


        <h3>3.3.8 &ndash; <a name="3.3.8">To-be-closed Variables</a></h3>
        <p>
        A to-be-closed variable behaves like an immutable local variable,
        except that its value is <em>closed</em> whenever the variable
        goes out of scope, including normal block termination,
        exiting its block by <b>break</b>/<b>continue</b>/<b>return</b>,
        or exiting by an error.
        <br/><br/>
        Here, to <em>close</em> a value means to call its
        <code>__close</code> metamethod.
        When calling the metamethod, the value itself is passed as the
        first argument and the error object that caused the exit (if any)
        is passed as a second argument;
        if there was no error, the second argument is <b>nil</b>.
        <br/><br/>
        The value assigned to a to-be-closed variable must have a
        <code>__close</code> metamethod or be a false value.
        (<b>nil</b> and <b>false</b> are ignored as to-be-closed values.)
        <br/><br/>
        If several to-be-closed variables go out of scope at the same event,
        they are closed in the reverse order that they were declared.
        <br/><br/>
        If there is any error while running a closing method, that error is
        handled like an error in the regular code where the variable was
        defined.
        After an error, the other pending closing methods will still be called.
        </p>


        <h2>3.4 &ndash; <a name="3.4">Expressions</a></h2>
        <p>
        The basic expressions in Tokudae are the following:

        <pre>
    exp ::= <b>nil</b> | <b>false</b> | <b>true</b>
    exp ::= &lsquo;<b>...</b>&rsquo;
    exp ::= Number
    exp ::= LiteralString
    exp ::= listdef
    exp ::= tabledef
    exp ::= functiondef
    exp ::= classdef
    exp ::= prefixexp
    exp ::= exp binop exp
    exp ::= unop exp
    prefixexp ::= var | call [&lsquo;<b>?</b>&rsquo;] | &lsquo;<b>(</b>&rsquo; exp &lsquo;<b>)</b>&rsquo; | superexp</pre>

        Numbers and literal strings are explained in
        <a href="#3.1">&sect;3.1</a>;
        variables are explained in <a href="#3.2">&sect;3.2</a>;
        function definitions are explained in
        <a href="#3.4.10">&sect;3.4.10</a>;
        function calls are explained in <a href="#3.4.9">&sect;3.4.9</a>;
        table and list constructors are explained in
        <a href="#3.4.8">&sect;3.4.8</a>.
        Vararg expressions, denoted by three dots ('<code>...</code>'),
        can only be used when directly inside a variadic function;
        they are explained in <a href="#3.4.11">&sect;3.4.11</a>.
        Class definitions and expressions with <code>super</code> keyword
        are explained in <a href="#3.4.12">&sect;3.4.12</a>.
        <br/><br/>
        Binary operators comprise arithmetic operators
        (see <a href="#3.4.1">&sect;3.4.1</a>), bitwise operators
        (see <a href="#3.4.2">&sect;3.4.2</a>), relational operators
        (see <a href="#3.4.4">&sect;3.4.4</a>), logical operators
        (see <a href="#3.4.5">&sect;3.4.5</a>), and the concatenation operator
        (see <a href="#3.4.6">&sect;3.4.6</a>).
        Unary operators comprise the unary minus
        (see <a href="#3.4.1">&sect;3.4.1</a>), the unary bitwise NOT
        (see <a href="#3.4.2">&sect;3.4.2</a>) and the unary logical not
        (see <a href="#3.4.5">&sect;3.4.5</a>).
        </p>


        <h3>3.4.1 &ndash; <a name="3.4.1">Arithmetic Operators</a></h3>
        <p>
        Tokudae supports the following arithmetic operators:
        <ul>
            <li><b><code>+</code>: </b>addition</li>
            <li><b><code>-</code>: </b>subtraction</li>
            <li><b><code>*</code>: </b>multiplication</li>
            <li><b><code>/</code>: </b>float division</li>
            <li><b><code>//</code>: </b>integer division</li>
            <li><b><code>%</code>: </b>modulo</li>
            <li><b><code>**</code>: </b>exponentiation</li>
            <li><b><code>-</code>: </b>unary minus</li>
        </ul>
        With the exception of exponentiation and float division,
        the arithmetic operators work as follows:
        If both operands are integers, the operation is performed over
        integers and the result is an integer.
        Otherwise, if both operands are numbers, then they are converted to
        floats, the operation is performed following the machine's rules
        for floating-point arithmetic (usually the IEEE 754 standard),
        and the result is a float.
        <br/><br/>
        Exponentiation and float division (<code>/</code>) always convert
        their operands to floats and the result is always a float.
        Exponentiation uses the ISO&nbsp;C function <code>pow</code>,
        so that it works for non-integer exponents too.
        <br/><br/>
        Modulo is defined as the remainder of a division that rounds
        the quotient towards minus infinity (floor division).
        <br/><br/>
        In case of overflows in integer arithmetic, all operations
        <em>wrap around</em>.
        </p>


        <h3>3.4.2 &ndash; <a name="3.4.2">Bitwise Operators</a></h3>
        <p>
        Tokudae supports the following bitwise operators:
        <ul>
            <li><b><code>&amp;</code>: </b>bitwise AND</li>
            <li><b><code>|</code>: </b>bitwise OR</li>
            <li><b><code>^</code>: </b>bitwise exclusive OR (xor)</li>
            <li><b><code>&gt;&gt;</code>: </b>right shift</li>
            <li><b><code>&lt;&lt;</code>: </b>left shift</li>
            <li><b><code>~</code>: </b>unary bitwise NOT</li>
        </ul>
        All bitwise operations convert its operands to integers
        (see <a href="#3.4.3">&sect;3.4.3</a>), operate on all bits of
        those integers, and result in an integer.
        <br/><br/>
        Both right and left shifts fill the vacant bits with zeros.
        Negative displacements shift to the other direction;
        displacements with absolute values equal to or higher than
        the number of bits in an integer result in zero
        (as all bits are shifted out).
        </p>


        <h3>3.4.3 &ndash; <a name="3.4.3">Coercions and Conversions</a></h3>
        <p>
        Tokudae provides some automatic conversions between some
        types and representations at run time.
        Bitwise operators always convert float operands to integers.
        Exponentiation and float division always convert integer operands
        to floats.
        All other arithmetic operations applied to mixed numbers
        (integers and floats) convert the integer operand to a float.
        The C API also converts both integers to floats and
        floats to integers, as needed.
        <br/><br/>
        In a conversion from integer to float, if the integer value has an
        exact representation as a float, that is the result.
        Otherwise, the conversion gets the nearest higher or the nearest
        lower representable value.
        This kind of conversion never fails.
        <br/><br/>
        The conversion from float to integer checks whether the float has
        an exact representation as an integer
        (that is, the float has an integral value and it is in the range
        of integer representation).
        If it does, that representation is the result.
        Otherwise, the conversion fails.
        </p>


        <h3>3.4.4 &ndash; <a name="3.4.4">Relational Operators</a></h3>
        <p>
        Tokudae supports the following relational operators:
        <ul>
            <li><b><code>==</code>: </b>equality</li>
            <li><b><code>!=</code>: </b>inequality</li>
            <li><b><code>&lt;</code>: </b>less than</li>
            <li><b><code>&gt;</code>: </b>greater than</li>
            <li><b><code>&lt;=</code>: </b>less or equal</li>
            <li><b><code>&gt;=</code>: </b>greater or equal</li>
        </ul>
        These operators always result in <b>false</b> or <b>true</b>.
        <br/><br/>
        Equality (<code>==</code>) first compares the type of its operands.
        If the types are different, then the result is <b>false</b>.
        Otherwise, the values of the operands are compared.
        Strings are equal if they have the same byte content.
        Numbers are equal if they denote the same mathematical value.
        <br/><br/>
        Tables, lists, classes, instances, userdata, and threads are
        compared by reference:
        two objects are considered equal only if they are the same object.
        Every time you create a new object
        (a table, a list, a class, an instance, a userdata or a thread),
        this new object is different from any previously existing object.
        A function is always equal to itself.
        Functions with any detectable difference
        (different behavior, different definition) are always different.
        Functions created at different times but with no detectable
        differences may be classified as equal or not
        (depending on internal caching details).
        <br/><br/>
        You can change the way that Tokudae compares instances and
        full&nbsp;userdata by using the <code>__eq</code> metamethod
        (see <a href="#2.4">&sect;2.4</a>).
        <br/><br/>
        The operator <code>!=</code> is exactly the negation of equality
        (<code>==</code>).
        <br/><br/>
        The order operators work as follows.
        If both arguments are numbers,
        then they are compared according to their mathematical values,
        regardless of their subtypes.
        Otherwise, if both arguments are strings,
        then their values are compared according to the current locale.
        Otherwise, Tokudae tries to call the <code>__lt</code> or the
        <code>__le</code> metamethod (see <a href="#2.4">&sect;2.4</a>).
        A comparison <code>a &gt; b</code> is translated to
        <code>b &lt; a</code> and <code>a &gt;= b</code> is translated to
        <code>b &lt;= a</code>.
        <br/><br/>
        Following the IEEE 754 standard, the special value NaN is considered
        neither less than, nor equal to, nor greater than any value,
        including itself.
        </p>


        <h3>3.4.5 &ndash; <a name="3.4.5">Logical Operators</a></h3>
        <p>
        The logical operators in Tokudae are <b>and</b>, <b>or</b> and
        exclamation mark '<code>!</code>'.
        Like the control structures (see <a href="#3.3.4">&sect;3.3.4</a>),
        all logical operators consider both <b>false</b> and <b>nil</b> as
        false and anything else as true.
        <br/><br/>
        The negation operator <code>!</code> always returns <b>false</b> or
        <b>true</b>.
        The conjunction operator <b>and</b> returns its first argument
        if this value is <b>false</b> or <b>nil</b>;
        otherwise, <b>and</b> returns its second argument.
        The disjunction operator <b>or</b> returns its first argument
        if this value is different from <b>nil</b> and <b>false</b>;
        otherwise, <b>or</b> returns its second argument.
        Both <b>and</b> and <b>or</b> use short-circuit evaluation;
        that is, the second operand is evaluated only if necessary.
        Here are some examples:

        <pre>
    10 or 20            /// 10
    10 or error()       /// 10
    nil or "a"          /// "a"
    nil and 10          /// nil
    false and error()   /// false
    false and nil       /// false
    false or nil        /// nil
    10 and 20           /// 20</pre>
        </p>


        <h3>3.4.6 &ndash; <a name="3.4.6">Concatenation</a></h3>
        <p>
        The string concatenation operator in Tokudae is
        denoted by two dots ('<code>..</code>').
        If any of the operands are not strings then the <code>__concat</code>
        metamethod is called (see <a href="#2.4">&sect;2.4</a>).
        </p>


        <h3>3.4.7 &ndash; <a name="3.4.7">Precedence</a></h3>
        <p>
        Operator precedence in Tokudae follows the table below,
        from lower to higher priority (it mimics operator precedence in C):

        <pre>
    or
    and
    |
    ^
    &amp;
    ==   !=
    &lt;    &lt;=   &gt;    &gt;=
    &lt;&lt;   &gt;&gt;
    ..
    +    -
    *    /    //    %
    unary operators (-    ~    !)
    **</pre>

        As usual, you can use parentheses to change the precedences of an
        expression.
        The concatenation ('<code>..</code>') and exponentiation
        ('<code>**</code>') operators are right associative.
        All other binary operators are left associative.
        </p>


        <h3>3.4.8 &ndash; <a name="3.4.8">Table and List definition</a></h3>
        <p>
        Table and list definitions are expressions that create tables and
        lists.
        Every time a definition is evaluated, a new list or table is created.
        A definition can be used to create an empty table/list or to create
        a table/list and initialize some of its fields/elements.
        The general syntax for table definition is

        <pre>
    tabledef ::= &lsquo;<b>{</b>&rsquo; [fieldlist] &lsquo;<b>}</b>&rsquo;
    fieldlist ::= field {sep field} [sep]
    field ::= &lsquo;<b>[</b>&rsquo; exp &lsquo;<b>]</b>&rsquo; &lsquo;<b>=</b>&rsquo; exp | Name &lsquo;<b>=</b>&rsquo; exp
    sep ::= &lsquo;<b>,</b>&rsquo; | &lsquo;<b>;</b>&rsquo;</pre>

        Each field of the form <code>[exp1] = exp2</code> adds to the new
        table an entry with key <code>exp1</code> and value <code>exp2</code>.
        A field of the form <code>name = exp</code> is equivalent to
        <code>["name"] = exp</code>.
        <br/>
        For example,

        <pre>
    a = { [f(1)] = g; x = 5, ["y"] = 6; [30] = 23 };</pre>

        is equivalent to (<code>t</code> is temporary stack value)

        <pre>
    t = {};
    t[f(1)] = g;
    t.x = 5;        /// t["x"] = 5;
    t["y"] = 6;
    t[30] = 23;
    a = t;</pre>

        This example also shows the order of assignment in table definitions,
        the fields that are first defined are also first assigned.
        <br/>
        The general syntax for list definition is:

        <pre>
    listdef ::= &lsquo;<b>[</b>&rsquo; [elementlist] &lsquo;<b>]</b>&rsquo;
    elementlist ::= exp {sep exp} [sep]</pre>

        Each expression in the elements list is equivalent to
        <code>[i] = exp</code>, where <code>i</code> are consecutive integers
        starting with 0.
        For example,

        <pre>
    a = [ 15, "okay", 69, true ];</pre>

        is equivalent to (<code>l</code> is temporary stack value)

        <pre>
    l = [];
    l[0] = 15;
    l[1] = "okay";
    l[2] = 69;
    l[3] = true;
    a = l;</pre>

        The order of the assignment in the list definition is the same as
        shown in the example above, the first defined indices are also
        first assigned.
        <br/>
        There is special case in the list definition where some values
        might not get assigned.
        <br/>
        For example,

        <pre>
    a = [ 5.2, "?", nil, true, {}];</pre>

        is equivalent to (<code>l</code> is temporary stack value)

        <pre>
    l = [];
    l[0] = 5.2;
    l[1] = "?";</pre>

        because index <code>2</code> is <em>nil</em>, so the rest of the
        indices are not assigned as <em>nil</em> truncates the list.
        <br/><br/>
        As mentioned in <a href="#2.1">&sect;2.1</a>, list has special fields.
        These fields are: <code>x</code>, <code>y</code>, <code>z</code>,
        which represent indices <code>0</code>, <code>1</code> and
        <code>2</code> respectively. Field <code>len</code> accesses the
        length of the list, field <code>size</code> accesses the memory block
        size of the list and <code>last</code> accesses the last value
        in the list, or returns nil if list is empty.
        <br/><br/>
        <details class = "example">
            <summary>Example</summary>
            <pre>
local l = [2, 3, 4];
local size = l.size;
assert(l.x == 2 and l.y == 3 and l.z == 4);
assert(l.len == 3 and l.last == 4);
assert(l.len &lt;= size);
l[2] = nil;
assert(l.x == 2 and l.y == 3 and l.z == nil);
assert(l.len == 2 and l.last == 3);
assert(l.size == size);
l[0] = nil;
assert(l.x == nil);
assert(l.len == 0 and l.last == nil);
assert(l.size == size);
l.last = 5;
assert(l.len == 1 and l.x == 5 and l.last == 5);
assert(l.size == size);
l[1] = 1; l[2] = 1; l[3] = 1; l[4] = 1;
assert(l.len == 5);
assert(size &lt; l.size);</pre>
        </details>
        <br/>
        Additionally both the field list and element list can have an
        optional trailing separator, as a convenience for machine-generated
        code.
        </p>


        <h3>3.4.9 &ndash; <a name="3.4.9">Function Calls</a></h3>
        <p>
        A function call in Tokudae has the following syntax:

        <pre>
    call ::= prefixexp &lsquo;<b>(</b>&rsquo; [explist] &lsquo;<b>)</b>&rsquo;</pre>

        In a function call, first prefixexp and function arguments (explist)
        are evaluated.
        <br/><br/>
        If the value of prefixexp has type <em>function</em>, then this
        function is called with the given arguments.
        <br/><br/>
        If the value of prefixexp has type <em>class</em>, and
        if <code>__init</code> field is present in the metatable of that class,
        it is called: its first argument is the instance of the class then
        all the other arguments provided to the call follow next (if any).
        If <code>__init</code> is not present, then calling a class directly
        returns the instance of that class (see <a href="#2.4">&sect;2.4</a>).
        This always returns a single result.
        <br/><br/>
        Finally if prefixexp is neither a <em>class</em> nor <em>function</em>,
        and <code>__call</code> metamethod is present, it is called:
        its first argument is the value of prefixexp, followed by the original
        call arguments (see <a href="#2.4">&sect;2.4</a>).
        <br/><br/>
        All argument expressions are evaluated before the call.
        <br/><br/>
        If the call is not a statement (see <a href="#3.3.6">&sect;3.3.6</a>), 
        then the <code>?</code> can follow right after the call, this is a false
        test that checks the first call result, and if it is false
        (<em>nil</em> or <em>false</em>), it returns from the function/chunk
        with all the results from that call, otherwise the return is skipped,
        meaning <code>?</code> is ignored.
        For instance,

        <pre>
    local res = test()?;
    print(res);</pre>

        is equivalent (but does not translate) to,

        <pre>
    local res = [test()];
    if !res[0] return list.flatten(res);
    res = res[0];
    print(res);</pre>

        <details class = "example">
            <summary>Example 1</summary>
            <pre>
local fn sum(x) return x + x;
local fn mul(x) return x * x;
local fn none() return nil, "hi";

local fn inside1(x) {
    local fn inside2(x) {
        local res = sum(x)?;
        res = mul(x)?;
        res = none(x)?;
        return x;  /* unreached */
    }

    local st, res = inside2(x)?;
    assert(nil);  /* unreached */
    return x;
}

local st, res = inside1(5);
assert(!st and res == "hi");</pre>
        </details>
        <details class = "example">
            <summary>Example 2</summary>
            <pre>
local fn main() {
    local class Error {
        __init = |msg| {
            self.msg = msg;
            return self;
        };
        __tostring = || { return self.msg; };
        __name = "Error";
    }
    local class Point {
        __init = |x,y| {
            if typeof(x) != "number" or typeof(y) != "number"
                return nil, Error("invalid coordinates");
            self.x = x;
            self.y = y;
            return self;
        };
        __tostring = || {
            return string.fmt("Point X:%s Y:%s", tostr(self.x), tostr(self.y));
        };
        __name = "Point";
    }

    local p1 = Point(5, 2);
    print(p1);                   /* "Point X:5 Y:2\n" */
    local p2 = Point(5, true)?;  /* nil + Error is returned */
    print(p2);                   /* unreached */
}

local r1,r2,r3 = main();
assert(!r1 and typeof(r2) == "instance" and !r3);
error(tostr(r2));  /* convert to string for error to add extra information */</pre>
        </details>
        <br/>
        As mentioned earlier using false check '<code>?</code>' on statement
        calls is not allowed and it raises an error.
        </p>


        <h3>3.4.10 &ndash; <a name="3.4.10">Function Definitions</a></h3>
        <p>
        The syntax for function definition is

        <pre>
    functiondef ::= <b>fn</b> parenparams funcbody | pipeparams funcbody
    parenparams ::= &lsquo;<b>(</b>&rsquo; [parameters] &lsquo;<b>)</b>&rsquo;
    pipeparams ::= &lsquo;<b>|</b>&rsquo; [parameters] &lsquo;<b>|</b>&rsquo;
    funcbody ::= [&lsquo;<b>::</b>&rsquo;] funcblock
    funcblock ::= &lsquo;<b>{</b>&rsquo; block &lsquo;<b>}</b>&rsquo; | stm</pre>

        The following syntactic sugar simplifies function definitions:

        <pre>
    stm ::= fnstm
    fnstm ::= <b>fn</b> dottedname parenparams funcbody
    dottedname ::= Name {&lsquo;<b>.</b>&rsquo; Name}
    localfn ::= <b>local</b> <b>fn</b> Name parenparams funcbody</pre>

        The statement

        <pre>
    fn f() { <em>body</em> }</pre>

        translates to

        <pre>
    f = fn() { <em>body</em> };</pre>

        or

        <pre>
    f = || { <em>body</em> };</pre>

        The statement

        <pre>
    fn t.a.b.c.f() { <em>body</em> }</pre>

        translates to

        <pre>
    t.a.b.c.f = fn() { <em>body</em> };</pre>

        or
        <pre>
    t.a.b.c.f = || { <em>body</em> };</pre>

        The statement

        <pre>
    local fn f() { <em>body</em> }</pre>

        translates to

        <pre>
    local f; f = fn() { <em>body</em> };</pre>

        or

        <pre>
    local f; f = || { <em>body</em> };</pre>

        not to

        <pre>
    local f = fn() { <em>body</em> };</pre>

        or

        <pre>
    local f = || { <em>body</em> };</pre>

        (This only makes a difference when the body of the function
        contains references to <code>f</code>.)
        <br/><br/>
        A function definition is an executable expression, whose value has
        type <em>function</em>.
        When Tokudae precompiles a chunk, all its function bodies are
        precompiled too, but they are not created yet.
        Then, whenever Tokudae executes the function definition,
        the function is <em>instantiated</em> (or <em>closed</em>).
        This function instance, or <em>closure</em>, is the final value of
        the expression.
        <br/><br/>
        Parameters act as local variables that are initialized with the
        argument values:

        <pre>
    parameters ::= namelist [&lsquo;<b>,</b>&rsquo; &lsquo;<b>...</b>&rsquo;] | &lsquo;<b>...</b>&rsquo;</pre>

        When a Tokudae function is called, it adjusts its list of arguments to
        the length of its list of parameters
        (see <a href="#3.4.11">&sect;3.4.11</a>), unless the function is a
        <em>variadic function</em>, which is indicated by three dots
        ('<code>...</code>') at the end of its parameter list.
        A variadic function does not adjust its argument list;
        instead, it collects all extra arguments and supplies them
        to the function through a <em>vararg expression</em>,
        which is also written as three dots.
        The value of this expression is a list of all actual extra arguments,
        similar to a function with multiple results
        (see <a href="#3.4.11">&sect;3.4.11</a>).
        <br/><br/>
        As an example, consider the following definitions:

        <pre>
    fn f(a, b) {}
    fn g(a, b, ...) {}
    fn r() { return 1, 2, 3; }</pre>

        Then, we have the following mapping from arguments to parameters and
        to the vararg expression:

        <pre>
     CALL             PARAMETERS

     f(3)             a=3, b=nil
     f(3, 4)          a=3, b=4
     f(3, 4, 5)       a=3, b=4
     f(r(), 10)       a=1, b=10
     f(r())           a=1, b=2

     g(3)             a=3, b=nil, ... --&gt;  (nothing)
     g(3, 4)          a=3, b=4,   ... --&gt;  (nothing)
     g(3, 4, 5, 8)    a=3, b=4,   ... --&gt;  5  8
     g(5, r())        a=5, b=1,   ... --&gt;  2  3</pre>

        Results are returned using the <b>return</b> statement
        (see <a href="#3.3.4">&sect;3.3.4</a>).
        If control reaches the end of a function without encountering a
        <b>return</b> statement, then the function returns with no results.
        </p>


        <h3>3.4.11 &ndash; <a name="3.4.11">Lists of expressions, multiple results, and adjustment</a></h3>
        <p>
        Both function calls and vararg expressions can result in multiple
        values.
        These expressions are called <em>multires expressions</em>.
        <br/><br/>
        When a multires expression is used as the last element
        of a list of expressions, all results from the expression are
        added to the list of values produced by the list of expressions.
        Note that a single expression in a place that expects a list of
        expressions is the last expression in that (singleton) list.
        <br/><br/>
        These are the places where Tokudae expects a list of expressions:
        <ul>
            <li>
                A <b>return</b> statement,
                for instance <code>return e1, e2, e3;</code>
                (see <a href="#3.3.4">&sect;3.3.4</a>).
            </li>
            <li>
                A list constructor,
                for instance <code>[e1, e2, e3]</code>
                (see <a href="#3.4.8">&sect;3.4.8</a>).
            </li>
            <li>
                The arguments of a function call,
                for instance <code>foo(e1, e2, e3)</code>
                (see <a href="#3.4.9">&sect;3.4.9</a>).
            </li>
            <li>
                A multiple assignment,
                for instance <code>a, b, c = e1, e2, e3;</code>
                (see <a href="#3.3.3">&sect;3.3.3</a>).
            </li>
            <li>
                A local declaration,
                for instance <code>local a, b, c = e1, e2, e3;</code>
                (see <a href="#3.3.7">&sect;3.3.7</a>).
            </li>
            <li>
                The initial values in a generic <b>foreach</b> loop,
                for instance <code>foreach k in e1, e2, e3 { ... }</code>
                (see <a href="#3.3.5">&sect;3.3.5</a>).
            </li>
        </ul>
        In the last four cases, the list of values from the list of
        expressions must be <em>adjusted</em> to a specific length:
        the number of parameters in a call to a non-variadic function
        (see <a href="#3.4.10">&sect;3.4.10</a>), the number of variables
        in a multiple assignment or a local declaration, and exactly four
        values for a generic <b>foreach</b> loop.
        The <em>adjustment</em> follows these rules:
        If there are more values than needed,
        the extra values are thrown away;
        if there are fewer values than needed,
        the list is extended with <b>nil</b>'s.
        When the list of expressions ends with a multires expression,
        all results from that expression enter the list of values
        before the adjustment.
        <br/><br/>
        When a multires expression is used in a list of expressions without
        being the last element, or in a place where the syntax expects a
        single expression, Tokudae adjusts the result list of that expression
        to one element.
        As a particular case, the syntax expects a single expression inside
        a parenthesized expression; therefore, adding parentheses around a
        multires expression forces it to produce exactly one result.
        <br/><br/>
        We rarely need to use a vararg expression in a place where the
        syntax expects a single expression.
        (Usually it is simpler to add a regular parameter before the
        variadic part and use that parameter.)
        When there is such a need, it is recommended assigning the vararg
        expression to a single variable and using that variable in its place.
        <br/><br/>
        Here are some examples of uses of mutlres expressions.
        In all cases, when the construction needs
        "the n-th result" and there is no such result,
        it uses a <b>nil</b>.

        <pre>
    print(x, f());     /// prints x and all results from f().
    print(x, (f()));   /// prints x and the first result from f().
    print(f(), x);     /// prints the first result from f() and x.
    print(1 + f());    /// prints 1 added to the first result from f().
    local x = ...;     /// x gets the first vararg argument.
    x,y = ...;         /// x gets the first vararg argument,
                       /// y gets the second vararg argument.
    x,y,z = w, f();    /// x gets w, y gets the first result from f(),
                       /// z gets the second result from f().
    x,y,z = f();       /// x gets the first result from f(),
                       /// y gets the second result from f(),
                       /// z gets the third result from f().
    x,y,z = f(), g();  /// x gets the first result from f(),
                       /// y gets the first result from g(),
                       /// z gets the second result from g().
    x,y,z = (f());     /// x gets the first result from f(), y and z get nil.
    return f();        /// returns all results from f().
    return x, ...;     /// returns x and all received vararg arguments.
    return x,y,f();    /// returns x, y, and all results from f().
    [f()]              /// creates list with all results from f().
    [...]              /// creates list with all vararg arguments.
    [f(), 5]           /// creates list with the first result from f() and 5.</pre>
        </p>


        <h3>3.4.12 &ndash; <a name="3.4.12">Class Definitions and Instances</a></h3>
        <p>
        The syntax for class definition is

        <pre>
    classdef ::= <b>class</b> [inherit] [classbody]
    inherit ::= <b>inherits</b> exp
    classbody ::= &lsquo;<b>{</b>&rsquo; {classvalue} &lsquo;<b>}</b>&rsquo;
    classvalue ::= method | metafield
    method ::= <b>fn</b> Name parenparams funcbody
    metafield ::= Name &lsquo;<b>=</b>&rsquo; exp &lsquo;<b>;</b>&rsquo;</pre>

        The following syntax is used for class definition as a statement or
        a declaration, which also allows declaration of local variables in
        the class body.

        <pre>
    classvaluestm = classvalue | localstm &lsquo;<b>;</b>&rsquo;
    classbodystm ::= &lsquo;<b>{</b>&rsquo; {classvaluestm} &lsquo;<b>}</b>&rsquo;
    classstm ::= <b>class</b> dottedname [inherit] [classbodystm]
    localclass ::= <b>local</b> <b>class</b> Name [inherit] [classbodystm]</pre>

        The statements

        <pre>
    class x
    class x.y</pre>

        translate to

        <pre>
    x = class;
    x.y = class;</pre>

        The declarations

        <pre>
    local class x
    local class y inherits x</pre>

        translate to

        <pre>
    local x;
    x = class;
    local y;
    y = class inherits x;</pre>

        not to

        <pre>
    local x = class;
    local y = class inherits x;</pre>

        (This only makes a difference when the body of the class
        contains references to <code>x</code> or <code>y</code>.)
        <br/><br/>
        <details class = "example">
            <summary>
                This chunk of code illustrates how inheritance works.
            </summary>
            <pre>
class Vec2 {
    __init = |x, y| {
        self.x = (x or 0);
        self.y = (y or 0);
        return self;
    };
    __add = |other| {
        return getclass(self)(self.x + other.x, self.y + other.y);
    };
    __name = "Vec2";

    fn getx() return self.x;
    fn gety() return self.y;
};
local class Vec3 inherits Vec2 {
    local nvec3 = 0; /* number of 3D vector instances created */

    __init = |x, y, z| {
        getmetatable(super).__init(self, x, y).z = z;
        nvec3++;
        return self;
    };
    __gc = || {
        nvec3--;
    };
    __add = |other| {
        return getclass(self)(self.x + other.x, self.y + other.y, self.z + other.z);
    };
    __name = "Vec3";

    fn getz() return self.z;
    fn getcount() return nvec3;
}
local vec = Vec3(2, 3, 5) + Vec3(3, 3, 4);
assert(vec.x == 5 and vec.y == 6 and vec.z == 9);
assert(string.find(tostr(vec), "Vec3"));
assert(vec.getx() == 5 and vec.gety() == 6 and vec.getz() == 9);
assert(vec.getcount() &gt;= 1);
gc();
assert(vec.getcount() == 1);</pre>
        </details>
        <br/>
        Class methods always have the instance as the first argument.
        This argument is a local variable named <code>self</code> and it is
        hidden but accessible. Keep in mind if you are setting class methods
        via <a href="#setmethods"><code>setmethods</code></a>,
        then <code>self</code> in those functions is not accessible,
        instead you must name the first parameter in order to have access
        to the instance value.
        In addition to <code>self</code>, the <code>super</code> keyword
        becomes accessible in each method and metafield definition.
        This keyword can access the superclass (if any) and its methods.
        <br/><br/>
        <details class = "example">
            <summary>Example of super keyword.</summary>
            <pre>
/* the class has no superclass */
load([=[
local class Empty {
    fn level() {
        assert(super == nil);
        return 0.0;
    }
}
]=])();

/* assigning to 'super' or it's property is not allowed */
st, err = load([=[
    class Empty { fn level() return 0.0; }

    local class HalfFull inherits Empty {
        fn level() {
            assert(super == Empty);
            super.level = fn() { return 69; };
            return super.level() + 0.5;
        }
    }
]=]);
assert(!st and string.find(err, "assign to 'super'"));

/* accessing 'super' field in a class that does not have a superclass */
st, err = pcall(fn() {
    return (class { fn invalid() :: return super.invalid(); })().invalid();
});
assert(!st and string.find(err, "class instance has no superclass"));</pre>
        </details>
        <br/>
        As shown in the example above, assigning to <code>super</code> or
        it's field (property) is not allowed, additionally accessing
        <code>super</code> field when the class does not have a superclass
        raises an error.
        <br/>
        Each time we call a class, we create a new instance of that class,
        unless class has <code>__init</code> which might return something
        else other than the instance (see <a href="#2.4">&sect;2.4</a>).
        Instances can call the methods the class defines and can set/get
        <em>fields</em>. <em>fields</em> are identical to <em>fields</em> in a
        table. Instances are the combination of data and functionality.
        They derive the functionality from metafields and methods of their
        class and store data in their <em>fields</em>.
        <br/><br/>
        <details class = "example">
            <summary>A field can shadow a method.</summary>
            <pre>
local class Kek {
    fn lol() return "kek";
}
local player = Kek();
assert(typeof(player.lol) == "bound method");
player.lol = "lol";
assert(typeof(player.lol) == "string");
assert(player.lol == "lol");</pre>
        </details>
        <br/>
        In the example above, when we index <code>player</code> such as
        <code>player.lol</code>, we get back the method called
        <em>bound method</em> (more on that shortly).
        However after we assign <code>player.lol</code> field to a
        non-<b>nil</b> value we shadow the class <em>method</em> with the
        newly assigned field.
        To access the <em>method</em> again, assign the field to <b>nil</b>,
        or use <a href="#getclass"><code>getclass</code></a>.
        <br/><br/>
        Methods returned by indexing the instance are called
        <em>bound methods</em>, as they are bound to the instance they
        belong to.
        This is necessary in order for the bound method when called, to
        properly set the instance as the first method argument.
        Each time you index an instance with a key that corresponds to the
        class method of the instance and the instance field under that key
        is not present, you will create a <em>bound method</em>.
        The same goes for <em>full userdata</em>, these two types are
        the only types that can bound themselves to a method object and
        vice versa
        (see <a href="#toku_push_boundmethod"><code>toku_push_boundmethod</code></a>).
        </p>


        <h2>3.5 &ndash; <a name="3.5">Visibility Rules</a></h2>
        <p>
        Tokudae is a lexically scoped language.
        The scope of a local variable begins at the first statement after
        its declaration and lasts until the last non-empty statement
        of the innermost block that includes the declaration.
        Consider the following example:

        <pre>
    x = 10;                 // global variable
    {                       // new block
        local x = x;        // new 'x', with value 10
        print(x);           // 10
        x = x+1;
        {                   // another block
            local x = x+1;  // another 'x'
            print(x);       // 12
        }  
        print(x);           // 11
    }  
    print(x);               // 10  (the global one) </pre>

        Notice that, in a declaration like <code>local x = x;</code>,
        the new <code>x</code> being declared is not in scope yet,
        and so the second <code>x</code> refers to the outside variable.
        <br/><br/>
        Because of the lexical scoping rules, local variables can be freely
        accessed by functions defined inside their scope.
        A local variable used by an inner function is called an
        <em>upvalue</em> (or <em>external local variable</em>, or simply
        <em>external variable</em>) inside the inner function.
        <br/><br/>
        Notice that each execution of a <b>local</b> statement defines new
        local variables.
        <br/>
        Consider the following example:

        <pre>
    l = [];
    local x = 20;
    for (local i = 0; i &lt; 10; i++) {
        local y = 0;
        l[i] = || { y++; return x + y; };
    }
    for local i = 0; i &lt; l.len; i++;
        assert(l[i]() == 21);
    for local i = 0; i &lt; l.len; i++;
        assert(l[i]() == 22);</pre>

        The loop creates ten closures
        (that is, ten instances of the anonymous function).
        Each of these closures uses a different <code>y</code> variable,
        while all of them share the same <code>x</code>.
        <br/><br/>
        Redefinition of the local variable is defined as defining a local
        variable with the same name as already defined local variable in the
        same scope.
        Redefinition of the local variables is <b>not allowed</b>.
        Consider the following example on what not to do:

        <pre>
    local x = 5;
    local x = 6;    /// redefinition of local variable 'x'</pre>

        Exception to this rule is any local variable named <code>_</code>.
        <br/>
        For instance,

        <pre>
    local _, y1, z1 = ...;
    local _, y2, z2 = ...;</pre>

        Here the local variable <code>_</code> won't invoke local variable
        redefinition error, however the value of <code>_</code> will be the
        value of it's latest assignment.
        <br/>
        This doesn't work on declarations of local functions and/or classes.
        <br/>
        The following,

        <pre>
    local _, y1 = ...;
    local _, y2 = ...;
    local class _</pre>

        will raise local variable redefinition error at the local class
        declaration.
        </p>


        <h1>4 &ndash; <a name="4">The Application Programming Interface</a></h1>
        <p>
        This section describes the C&nbsp;API for Tokudae, that is,
        the set of C&nbsp;functions available to the host program to
        communicate with Tokudae.
        All API functions and related types and constants are declared in
        the header file <a name="tokudae.h"><code>tokudae.h</code></a>.
        </br></br>
        Even when we use the term "function", any facility in the API may be
        provided as a macro instead.
        Except where stated otherwise, all such macros use each of their
        arguments exactly once (except for the first argument, which is always
        a Tokudae state), and so do not generate any hidden side-effects.
        </br></br>
        As in most C&nbsp;libraries, the Tokudae API functions do not check
        their arguments for validity or consistency.
        However, you can change this behavior by compiling Tokudae with the
        macro <a name="TOKU_USE_APICHECK"><code>TOKU_USE_APICHECK</code></a>
        defined.
        </br></br>
        The Tokudae library is fully reentrant: it has no global variables.
        It keeps all information it needs in a dynamic structure, called
        the <em>Tokudae state</em>.
        </br></br>
        Each Tokudae state has one or more threads, which correspond to
        independent, cooperative lines of execution.
        The type <a href="#toku_State"><code>toku_State</code></a>
        (despite its name) refers to a thread.
        (Indirectly, through the thread, it also refers to the Tokudae state
        associated to the thread.)
        </br></br>
        A pointer to a thread must be passed as the first argument to every
        function in the library, except to
        <a href="#toku_newstate"><code>toku_newstate</code></a>, which creates
        a Tokudae state from scratch and returns a pointer to the
        <em>main thread</em> in the new state.
        </p>


        <h2>4.1 &ndash; <a name="4.1">The Stack</a></h2>
        <p>
        Tokudae uses a <em>virtual stack</em> to pass values to and from C.
        Each element in this stack represents a Tokudae value (<b>nil</b>,
        number, string, etc.).
        Functions in the API can access this stack through the Tokudae state
        parameter that they receive.
        <br/><br/>
        Whenever Tokudae calls C, the called function gets a new stack,
        which is independent of previous stacks and of stacks of
        C&nbsp;functions that are still active.
        This stack initially contains any arguments passed to the
        C&nbsp;function and it is where the C&nbsp;function can store
        temporary Tokudae values and must push its results to be returned
        to the caller
        (see <a href="#toku_CFunction"><code>toku_CFunction</code></a>).
        <br/><br/>
        For convenience, most query operations in the API do not follow a
        strict stack discipline.
        Instead, they can refer to any element in the stack by using an
        <em>index</em>:
        A positive index represents an absolute stack position, starting
        at&nbsp;0 as the bottom of the stack;
        a negative index represents an offset relative to the top of the stack.
        More specifically, if the stack has <em>n</em> elements, then
        index&nbsp;0 represents the first element
        (that is, the element that was pushed onto the stack first)
        and index&nbsp;<em>n-1</em> represents the last element;
        index&nbsp;-1 also represents the last element
        (that is, the element at the&nbsp;top)
        and index <em>-n</em> represents the first element.
        </p>


        <h3>4.1.1 &ndash; <a name="4.1.1">Stack Size</a></h3>
        <p>
        When you interact with the Tokudae API, you are responsible for
        ensuring consistency.
        In particular,
        <em>you are responsible for controlling stack overflow</em>.
        When you call any API function, you must ensure the stack has enough
        room to accommodate the results.
        <br/><br/>
        There is one exception to the above rule:
        When you call a Tokudae function without a fixed number of results
        (see <a href="#toku_call"><code>toku_call</code></a>),
        Tokudae ensures that the stack has enough space for all results.
        However, it does not ensure any extra space.
        So, before pushing anything on the stack after such a call
        you should use <a href="#toku_checkstack"><code>toku_checkstack</code></a>.
        <br/><br/>
        Whenever Tokudae calls C, it ensures that the stack has space for at
        least <a name="TOKU_MINSTACK"><code>TOKU_MINSTACK</code></a> extra
        elements; that is, you can safely push up to <code>TOKU_MINSTACK</code>
        values into it. <code>TOKU_MINSTACK</code> is defined as 20, so that
        usually you do not have to worry about stack space unless your code
        has loops pushing elements onto the stack.
        Whenever necessary, you can use the function
        <a href="#toku_checkstack"><code>toku_checkstack</code></a> to ensure
        that the stack has enough space for pushing new elements.
        </p>


        <h3>4.1.2 &ndash; <a name="4.1.2">Valid and Acceptable Indices</a></h3>
        <p>
        Any function in the API that receives stack indices works only with
        <em>valid indices</em> or <em>acceptable indices</em>.
        <br/><br/>
        A <em>valid index</em> is an index that refers to a position that
        stores a modifiable Tokudae value.
        It comprises stack indices between&nbsp;0 and the stack top
        (<code>0 &le; abs(index) &lt; top</code>) plus <em>pseudo-indices</em>,
        which represent some positions that are accessible to C&nbsp;code
        but that are not in the stack.
        Pseudo-indices are used to access the C&nbsp;table and C&nbsp;list
        (see <a href="#4.3">&sect;4.3</a>)
        and the upvalues of a C&nbsp;function
        (see <a href="#4.2">&sect;4.2</a>).
        <br/><br/>
        Functions that do not need a specific mutable position, but only a
        value (e.g., query functions), can be called with acceptable indices.
        An <em>acceptable index</em> can be any valid index, but it also can
        be any positive index after the stack top within the space allocated
        for the stack, that is, indices up to the stack size (not inclusive).
        Indices to upvalues (see <a href="#4.2">&sect;4.2</a>) greater than
        the real number of upvalues in the current C&nbsp;function are also
        acceptable (but invalid).
        Except when noted otherwise, functions in the API work with acceptable
        indices.
        <br/><br/>
        Acceptable indices serve to avoid extra tests against the stack top
        when querying the stack.
        For instance, a C&nbsp;function can query its third argument without
        the need to check whether there is a third argument, that is, without
        the need to check whether 2 is a valid index.
        <br/><br/>
        For functions that can be called with acceptable indices, any
        non-valid index is treated as if it contains a value of a virtual
        type <a name="TOKU_T_NONE"><code>TOKU_T_NONE</code></a>, which behaves
        like a nil value.
        </p>


        <h3>4.1.3 &ndash; <a name="4.1.3">Pointers to strings</a></h3>
        <p>
        Several functions in the API return pointers (<code>const char*</code>)
        to Tokudae strings in the stack.
        (See <a href="#toku_push_fstring"><code>toku_push_fstring</code></a>,
        <a href="#toku_push_lstring"><code>toku_push_lstring</code></a>,
        <a href="#toku_push_string"><code>toku_push_string</code></a>,
        and <a href="#toku_to_lstring"><code>toku_to_lstring</code></a>.
        See also <a href="#tokuL_check_lstring"><code>tokuL_check_lstring</code></a>,
        <a href="#tokuL_check_string"><code>tokuL_check_string</code></a>,
        and <a href="#tokuL_to_lstring"><code>tokuL_to_lstring</code></a> in the
        auxiliary library.)
        <br/><br/>
        In general, Tokudae's garbage collection can free or move internal
        memory and then invalidate pointers to internal strings.
        To allow a safe use of these pointers, the API guarantees that any
        pointer to a string in a stack index is valid while the string value
        at that index is not removed from the stack.
        (It can be moved to another index, though.)
        When the index is a pseudo-index (referring to an upvalue), the
        pointer is valid while the corresponding call is active and the
        corresponding upvalue is not modified.
        <br/><br/>
        Some functions in the debug interface also return pointers to strings,
        namely <a href="#toku_getlocal"><code>toku_getlocal</code></a>,
        <a href="#toku_getupvalue"><code>toku_getupvalue</code></a>,
        <a href="#toku_setlocal"><code>toku_setlocal</code></a>,
        and <a href="#toku_setupvalue"><code>toku_setupvalue</code></a>.
        For these functions, the pointer is guaranteed to be valid while the
        caller function is active and the given closure (if one was given)
        is in the stack.
        <br/><br/>
        Except for these guarantees, the garbage collector is free to
        invalidate any pointer to internal strings.
        </p>


        <h2>4.2 &ndash; <a name="4.2">C Closures</a></h2>
        <p>
        When a C&nbsp;function is created, it is possible to associate
        some values with it, thus creating a <em>C&nbsp;closure</em>
        (see <a href="#toku_push_cclosure"><code>toku_push_cclosure</code></a>);
        these values are called <em>upvalues</em> and are accessible to the
        function whenever it is called.
        <br/><br/>
        Whenever a C&nbsp;function is called, its upvalues are located at
        specific pseudo-indices.
        These pseudo-indices are produced by the macro
        <a href="#toku_upvalueindex"><code>toku_upvalueindex</code></a>.
        The first upvalue associated with a function is at index
        <code>toku_upvalueindex(0)</code>, and so on.
        Any access to <code>toku_upvalueindex(<em>n</em>)</code>,
        where <em>n</em> is greater or equal to the number of upvalues of the
        current function, produces an acceptable but invalid index.
        <br/><br/>
        A C&nbsp;closure can also change the values of its corresponding
        upvalues.
        </p>


        <h2>4.3 &ndash; <a name="4.3">C&nbsp;Table and C&nbsp;List</a></h2>
        <p>
        Tokudae provides a <em>C&nbsp;table</em> and a <em>C&nbsp;list</em>,
        a predefined table and a list value, respectively, used by any
        C&nbsp; code to store whatever Tokudae values it needs to store.
        The C&nbsp;list is always accessible at pseudo-index
        <a name="TOKU_CLIST_INDEX"><code>TOKU_CLIST_INDEX</code></a> and
        the C&nbsp;table is always accessible at pseudo-index
        <a name="TOKU_CTABLE_INDEX"><code>TOKU_CTABLE_INDEX</code></a>.
        <br/><br/>
        Any C&nbsp;library can store data into the C&nbsp;table, but it must
        take care to choose keys that are different from those used by other
        libraries, to avoid collisions.
        Typically, you should use as key a string containing your library name,
        or a light userdata with the address of a C&nbsp;object in your code,
        or any Tokudae object created by your code.
        As with variable names, string keys starting with two underscores
        followed by uppercase letters are reserved for Tokudae.
        <br/><br/>
        The indices in the <em>C&nbsp;list</em> are used by the reference
        mechanism (see <a href="#tokuL_ref"><code>tokuL_ref</code></a>) and
        by some predefined values.
        Therefore, indices in the C&nbsp;list must not be used for other
        purposes, meaning you should not manually set elements into the
        <em>C&nbsp;list</em>, instead you would use the reference mechanism.
        <br/><br/>
        When you create a new Tokudae state, its C&nbsp;list comes with some
        predefined values.
        These predefined values are indexed with indices defined as constants
        in <code>tokudae.h</code>.
        The following constants are defined:
        <ul>
            <li>
                <b><a name="TOKU_CLIST_MAINTHREAD"><code>TOKU_CLIST_MAINTHREAD</code></a>:</b>
                At this index the C&nbsp;list has the main thread of the state.
                (The main thread is the one created together with the state.)
            </li>
            <li>
                <b><a name="TOKU_CLIST_GLOBALS"><code>TOKU_CLIST_GLOBALS</code></a>:</b>
                At this index the C&nbsp;list has the global table.
            </li>
        </ul>
        </p>


        <h2>4.4 &ndash; <a name="4.4">Error Handling in C</a></h2>
        <p>
        Internally, Tokudae uses the C&nbsp;<code>longjmp</code> facility to
        handle errors.
        When Tokudae faces any error, such as a memory allocation error or a
        type error, it <em>raises</em> an error; that is, it does a long jump.
        A <em>protected environment</em> uses <code>setjmp</code>
        to set a recovery point; any error jumps to the most recent active
        recovery point.
        <br/><br/>
        Inside a C&nbsp;function you can raise an error explicitly
        by calling <a href="#toku_error"><code>toku_error</code></a>.
        <br/><br/>
        Most functions in the API can raise an error, for instance due to
        a memory allocation error.
        The documentation for each function indicates whether it can raise
        errors.
        <br/><br/>
        If an error happens outside any protected environment, Tokudae calls
        a <em>panic function</em>
        (see <a href="#toku_atpanic"><code>toku_atpanic</code></a>)
        and then calls <code>abort</code>, thus exiting the host application.
        Your panic function can avoid this exit by never returning
        (e.g., doing a long jump to your own recovery point outside Tokudae).
        <br/><br/>
        The panic function, as its name implies, is a mechanism of last resort.
        Programs should avoid it.
        As a general rule, when a C&nbsp;function is called by Tokudae with a
        Tokudae state, it can do whatever it wants on that Tokudae state,
        as it should be already protected.
        However, when C code operates on other Tokudae states
        (e.g., a Tokudae-state argument to the function, a Tokudae state
        stored in the C&nbsp;table/list, or the result of
        <a href="#toku_newthread"><code>toku_newthread</code></a>),
        it should use them only in API calls that cannot raise errors.
        <br/><br/>
        The panic function runs as if it were a message handler
        (see <a href="#2.3">&sect;2.3</a>); in particular, the error object
        is on the top of the stack.
        However, there is no guarantee about stack space.
        To push anything on the stack, the panic function must first check
        the available space (see <a href="#4.1.1">&sect;4.1.1</a>).
        </p>


        <h3>4.4.1 &ndash; <a name="4.4.1">Status Codes</a></h3>
        <p>
        Several functions that report errors in the API use the following
        status codes to indicate different kinds of errors or other conditions:
        <ul>
            <li>
                <b><a name="TOKU_STATUS_OK"><code>TOKU_STATUS_OK</code></a> (0):</b>
                no errors.
            </li>
            <li>
                <b><a name="TOKU_STATUS_ERUNTIME"><code>TOKU_STATUS_ERUNTIME</code></a>:</b>
                a runtime error.
            </li>
            <li>
                <b><a name="TOKU_STATUS_EMEM"><code>TOKU_STATUS_EMEM</code></a>: </b>
                memory allocation error.
                For such errors, Tokudae does not call the message handler.
            </li>
            <li>
                <b><a name="TOKU_STATUS_EERROR"><code>TOKU_STATUS_EERROR</code></a>: </b>
                error while running the message handler.
            </li>
            <li>
                <b><a name="TOKU_STATUS_ESYNTAX"><code>TOKU_STATUS_ESYNTAX</code></a>:</b>
                syntax error during precompilation.</li>
            <li>
                <b><a name="TOKU_STATUS_EFILE"><code>TOKU_STATUS_EFILE</code></a>:</b>
                a file-related error;
                e.g., it cannot open or read the file.
            </li>
        </ul>
        These constants are defined in the header file <code>tokudae.h</code>.
        <br/>
        (Except <a href="#TOKU_STATUS_EFILE"><code>TOKU_STATUS_EFILE</code></a>,
        which is defined in the auxiliary library header <code>tokudaeaux.h</code>.)
        </p>


        <h2>4.5 &ndash; <a name="4.5">Functions and Types</a></h2>
        <p>
        Here we list all functions and types from the C&nbsp;API.
        Each function has an indicator like this:
        <span class="apii">[-o, +p, <em>x</em>]</span>
        <br/><br/>
        The first field, <code>o</code>, is how many elements the function
        pops from the stack.
        The second field, <code>p</code>, is how many elements the function
        pushes onto the stack.
        (Any function always pushes its results after popping its arguments.)
        A field in the form <code>x|y</code> means the function can push
        (or pop) <code>x</code> or <code>y</code> elements, depending on
        the situation; an interrogation mark '<code>?</code>' means that
        we cannot know how many elements the function pops/pushes by looking
        only at its arguments.
        (For instance, they may depend on what is in the stack.)
        The third field, <code>x</code>, tells whether the function may raise errors:
        '<code>-</code>' means the function never raises any error;
        '<code>m</code>' means the function may raise only out-of-memory errors;
        '<code>v</code>' means the function may raise the errors explained in the text;
        '<code>e</code>' means the function can run arbitrary Tokudae code,
        either directly or through metamethods, and therefore may raise any
        errors.
        </p>

        <!-- toku_State -->
        <hr><h3><a name="toku_State"><code>toku_State</code></a></h3>
        <pre>typedef struct toku_State toku_State;</pre>
        <p>
        An opaque structure that points to a thread and indirectly
        (through the thread) to the whole state of a Tokudae interpreter.
        The Tokudae library is fully reentrant: it has no global variables.
        All information about a state is accessible through this structure.
        <br/><br/>
        A pointer to this structure must be passed as the first argument to
        every function in the library, except to
        <a href="#toku_newstate"><code>toku_newstate</code></a>, which creates a
        Tokudae state from scratch.
        </p>

        <!-- toku_Integer -->
        <hr><h3><a name="toku_Integer"><code>toku_Integer</code></a></h3>
        <pre>typedef ... toku_Integer;</pre>
        <p>
        The type of integers in Tokudae.
        <br/><br/>
        By default this type is <code>long long</code>,
        (usually a 64-bit two-complement integer),
        (See <code>TOKU_INT_TYPE</code> in <code>tokudaeconf.h</code>.)
        <br/><br/>
        Tokudae also defines the constants
        <a name="TOKU_INTEGER_MIN"><code>TOKU_INTEGER_MIN</code></a> and
        <a name="TOKU_INTEGER_MAX"><code>TOKU_INTEGER_MAX</code></a>,
        with the minimum and the maximum values that fit in this type.
        </p>

        <!-- toku_Unsigned -->
        <hr><h3><a name="toku_Unsigned"><code>toku_Unsigned</code></a></h3>
        <pre>typedef ... toku_Unsigned;</pre>
        <p>
        The unsigned version of <a href="#toku_Integer"><code>toku_Integer</code></a>.
        </p>

        <!-- toku_Number -->
        <hr><h3><a name="toku_Number"><code>toku_Number</code></a></h3>
        <pre>typedef ... toku_Number;</pre>
        <p>
        The type of floats in Tokudae.
        <br/><br/>
        By default this type is double.
        (See <code>TOKU_FLOAT_TYPE</code> in <code>tokudaeconf.h</code>.)
        </p>

        <!-- toku_CFunction -->
        <hr><h3><a name="toku_CFunction"><code>toku_CFunction</code></a></h3>
        <pre>typedef int (*toku_CFunction) (toku_State *T);</pre>
        <p>
        Type for C&nbsp;functions.
        <br/><br/>
        In order to communicate properly with Tokudae, a C&nbsp;function
        must use the following protocol, which defines the way parameters and
        results are passed: a C&nbsp;function receives its arguments from
        Tokudae in its stack in direct order (the first argument is pushed first).
        So, when the function starts,
        <a href="#toku_getntop"><code>toku_getntop(T)</code></a> returns the
        number of arguments received by the function.
        The first argument (if any) is at index 0 and its last argument is at
        index <a href="#toku_gettop"><code>toku_gettop(T)</code></a>.
        To return values to Tokudae, a C&nbsp;function just pushes them onto
        the stack, in direct order (the first result is pushed first), and
        returns in C the number of results.
        Any other value in the stack below the results will be properly
        discarded by Tokudae.
        Like a Tokudae function, a C&nbsp;function called by Tokudae can also
        return many results.
        <details class = "example">
            <summary>
        In this example, function receives a variable number of numeric
        arguments and returns their average and their sum.
            </summary>
            <pre>
static int foo (toku_State *T) {
    int n = toku_gettop(T);         /* index of last argument */
    toku_Number sum = 0.0;
    int i;
    for (i = 0; i &lt;= n; i++) {
        if (!toku_is_number(T, i)) {
            toku_push_literal(T, "incorrect argument");
            toku_error(T);
        }
        sum += toku_to_number(T, i);
    }
    toku_push_number(T, sum/n);     /* first result */
    toku_push_number(T, sum);       /* second result */
    return 2;                       /* number of results */
}</pre>
        </details>
        </p>

        <!-- toku_Alloc -->
        <hr><h3><a name="toku_Alloc"><code>toku_Alloc</code></a></h3>
        <pre>typedef void *(*toku_Alloc) (void *ptr, void *ud, size_t osz, size_t nsz);</pre>
        <p>
        The type of the memory-allocation function used by Tokudae states.
        The allocator function must provide a functionality similar to
        <code>realloc</code>, but not exactly the same.
        Its arguments are <code>ud</code>, second argument that is an opaque
        pointer passed to <a href="#toku_newstate"><code>toku_newstate</code></a>;
        <code>ptr</code>, a pointer to the block being allocated/reallocated/freed;
        <code>osz</code>, the original size of the block or some code about
        what is being allocated (such as a <a href="#toku_type">type</a> tag);
        and <code>nsz</code>, the new size of the block.
        <br/><br/>
        When <code>ptr</code> is not <code>NULL</code>, <code>osz</code> is
        the size of the block pointed by <code>ptr</code>, that is, the size
        given when it was allocated or reallocated.
        <br/><br/>
        When <code>ptr</code> is <code>NULL</code>, <code>osz</code> encodes
        the kind of object that Tokudae is allocating.
        <code>osz</code> is any of
        <a href="#TOKU_T_USERDATA"><code>TOKU_T_USERDATA</code></a>,
        <a href="#TOKU_T_STRING"><code>TOKU_T_STRING</code></a>,
        <a href="#TOKU_T_LIST"><code>TOKU_T_LIST</code></a>,
        <a href="#TOKU_T_TABLE"><code>TOKU_T_TABLE</code></a>,
        <a href="#TOKU_T_FUNCTION"><code>TOKU_T_FUNCTION</code></a>,
        <a href="#TOKU_T_BMETHOD"><code>TOKU_T_BMETHOD</code></a>,
        <a href="#TOKU_T_CLASS"><code>TOKU_T_CLASS</code></a>,
        <a href="#TOKU_T_INSTANCE"><code>TOKU_T_INSTANCE</code></a>, or
        <a href="#TOKU_T_THREAD"><code>TOKU_T_THREAD</code></a> when
        (and only when) Tokudae is creating a new object of that type.
        When <code>osz</code> is some other value, Tokudae is allocating
        memory for something else.
        <br/><br/>
        Tokudae assumes the following behavior from the allocator function:
        <br/><br/>
        When <code>nsz</code> is zero, the allocator must behave like
        <code>free</code> and then return <code>NULL</code>.
        <br/><br/>
        When <code>nsz</code> is not zero, the allocator must behave like
        <code>realloc</code>.
        In particular, the allocator returns <code>NULL</code> if and only if
        it cannot fulfill the request.
        <details class = "example">
            <summary>
            Here is a simple implementation for the allocator function.
            It is used in the auxiliary library by
            <a href="#tokuL_newstate"><code>tokuL_newstate</code></a>.
            </summary>
        <pre>
static void *allocator (void *ptr, void *ud, size_t osz, size_t nsz) {
    (void)ud; (void)osz;  /* not used */
    if (nsz == 0) {
        free(ptr);
        return NULL;
    } else
        return realloc(ptr, nsz);
}</pre>
        </details>
        <br/>
        Note that ISO&nbsp;C ensures that <code>free(NULL)</code> has no
        effect and that <code>realloc(NULL,size)</code> is equivalent to
        <code>malloc(size)</code>.
        </p>

        <!-- toku_Reader -->
        <hr><h3><a name="toku_Reader"><code>toku_Reader</code></a></h3>
        <pre>typedef const char *(*toku_Reader) (toku_State *T, void *data, size_t *szread);</pre>
        <p>
        The reader function used by <a href="#toku_load"><code>toku_load</code></a>.
        Every time <a href="#toku_load"><code>toku_load</code></a> needs another
        piece of the chunk, it calls the reader, passing along its
        <code>data</code> parameter.
        The reader must return a pointer to a block of memory with a new piece
        of the chunk and set <code>szread</code> to the block size.
        The block must exist until the reader function is called again.
        To signal the end of the chunk, the reader must return
        <code>NULL</code> or set <code>szread</code> to zero.
        The reader function may return pieces of any size greater than zero.
        </p>

        <!-- toku_Writer -->
        <hr><h3><a name="toku_Writer"><code>toku_Writer</code></a></h3>
        <pre>typedef int (*toku_Writer) (toku_State *T, const void *b, size_t sz, void *data);</pre>
        <p>
        The type of the writer function used by
        <a href="#toku_dump"><code>toku_dump</code></a>.
        Every time <a href="#toku_dump"><code>toku_dump</code></a>
        produces another piece of chunk, it calls the writer,
        passing along the buffer to be written (<code>p</code>),
        its size (<code>sz</code>), and the <code>ud</code> parameter
        supplied to <a href="#toku_dump"><code>toku_dump</code></a>.
        <br/><br/>
        After <a href="#toku_dump"><code>toku_dump</code></a> writes its
        last piece, it will signal that by calling the writer function one
        more time, with a <code>NULL</code> buffer (and size 0).
        <br/><br/>
        The writer returns an error code:
        0&nbsp;means no errors;
        any other value means an error and stops
        <a href="#toku_dump"><code>toku_dump</code></a>
        from calling the writer again.
        </p>

        <!-- toku_WarnFunction -->
        <hr><h3><a name="toku_WarnFunction"><code>toku_WarnFunction</code></a></h3>
        <pre>typedef void (*toku_WarnFunction) (void *ud, const char *msg, int tocont);</pre>
        <p>
        The type of warning functions, called by Tokudae to emit warnings.
        The first parameter is an opaque pointer set by
        <a href="#toku_setwarnf"><code>toku_setwarnf</code></a>.
        The second parameter is the warning message.
        The third parameter is a boolean that indicates whether the message is
        to be continued by the message in the next call.
        <br/><br/>
        See <a href="#warn"><code>warn</code></a> for more details about
        warnings.
        </p>

        <!-- toku_Debug -->
        <hr><h3><a name="toku_Debug"><code>toku_Debug</code></a></h3>
        <pre>
typedef struct toku_Debug {
    const char *name;               /* (n) */
    const char *namewhat;           /* (n) */
    const char *what;               /* (s) */
    const char *source;             /* (s) */
    size_t srclen;                  /* (s) */
    int currline;                   /* (l) */
    int defline;                    /* (s) */
    int lastdefline;                /* (s) */
    int nupvals;                    /* (u) number of upvalues */
    int nparams;                    /* (u) number of parameters */
    unsigned char isvararg;         /* (u) */
    int ftransfer;                  /* (r) */
    int ntransfer;                  /* (r) */
    char shortsrc[TOKU_IDSIZE];     /* (s) */
    /* private part */
    <em>other fields</em>
} toku_Debug;</pre>
        <p>
        A structure used to carry different pieces of information about a
        function or an activation record.
        <a href="#toku_getstack"><code>toku_getstack</code></a> fills only the
        private part of this structure, for later use.
        To fill the other fields of
        <a href="#toku_Debug"><code>toku_Debug</code></a> with useful information,
        you must call <a href="#toku_getinfo"><code>toku_getinfo</code></a> with
        an appropriate parameter. (Specifically, to get a field, you must add
        the letter between parentheses in the field's comment to the parameter
        <code>what</code> of <a href="#toku_getinfo"><code>toku_getinfo</code></a>.)
        <br/><br/>
        The fields of <a href="#toku_Debug"><code>toku_Debug</code></a> have the
        following meaning:
        <ul>
            <li>
                <b><code>source</code>: </b>
                the source of the chunk that created the function.
            </li>
            <li>
                <b><code>srclen</code>: </b>
                The length of the string <code>source</code>.
            </li>
            <li>
                <b><code>shortsrc</code>: </b>
                a "printable" version of <code>source</code> of maximum size
                <a name="TOKU_IDSIZE"><code>TOKU_IDSIZE</code></a>
                (see <code>tokudaeconf.h</code>), to be used in error messages.
            </li>
            <li>
                <b><code>defline</code>: </b>
                the line number where the definition of the function starts.
            </li>
            <li>
                <b><code>lastdefline</code>: </b>
                the line number where the definition of the function ends.
            </li>
            <li>
                <b><code>what</code>: </b>
                the string <code>"Tokudae"</code> if the function is a Tokudae
                function, <code>"C"</code> if it is a C&nbsp;function,
                <code>"main"</code> if it is the main part of a chunk.
            </li>
            <li>
                <b><code>currline</code>: </b>
                the current line where the given function is executing.
            </li>
            <li>
                <b><code>name</code>: </b>
                a reasonable name for the given function.
                Because functions in Tokudae are first-class values, they do
                not have a fixed name: some functions can be the value of
                multiple global variables, while others can be stored only
                in a table field.
                The <a href="#toku_getinfo"><code>toku_getinfo</code></a>
                function checks how the function was called to find a
                suitable name.
                If it cannot find a name, then <code>name</code> is set to
                <code>NULL</code>.
            </li>
            <li>
                <b><code>namewhat</code>: </b>
                explains the <code>name</code> field.
                The value of <code>namewhat</code> can be
                <code>"hook"</code>, <code>"metamethod"</code>,
                <code>"for iterator"</code>, <code>"superclass field"</code>,
                <code>"global"</code>, <code>"field"</code>,
                <code>"local"</code>, <code>"constant"</code>
                or <code>""</code> (the empty string),
                according to how the function was called.
                (Tokudae uses the empty string when no other option
                 seems to apply.)
            </li>
            <li>
                <b><code>nupvals</code>: </b>
                the number of upvalues of the function.
            </li>
            <li>
                <b><code>nparams</code>: </b>
                the number of parameters of the function
                (always 0&nbsp;for C&nbsp;functions).
            </li>
            <li>
                <b><code>isvararg</code>: </b>
                true if the function is a variadic function
                (always true for C&nbsp;functions).
            </li>
            <li>
                <b><code>ftransfer</code>: </b>
                the index in the stack of the first value being "transferred",
                that is, parameters in a call or return values in a return.
                (The other values are in consecutive indices.)
                Using this index, you can access and modify these values
                through <a href="#toku_getlocal"><code>toku_getlocal</code></a>
                and <a  hreef="#toku_setlocal"><code>toku_setlocal</code></a>.
                This field is only meaningful during a call hook, denoting
                the first parameter, or a return hook, denoting the first
                value being returned.
                (For call hooks, this value is always&nbsp;0.)
            </li>
            <li>
                <b><code>ntransfer</code>: </b>
                the number of values being transferred (see previous item).
                (For calls of Tokudae functions, this value is always equal
                to <code>nparams</code>.)
            </li>
        </ul>
        </p>

        <!-- toku_Hook -->
        <hr><h3><a name="toku_Hook"><code>toku_Hook</code></a></h3>
        <pre>typedef void (*toku_Hook) (toku_State *T, toku_Debug *ar);</pre>
        Type for debugging hook functions.
        <br/><br/>
        Whenever a hook is called, its <code>ar</code> argument has its field
        <code>event</code> set to the specific event that triggered the hook.
        Tokudae identifies these events with the following constants:
        <a name="TOKU_HOOK_CALL"><code>TOKU_HOOK_CALL</code></a>,
        <a name="TOKU_HOOK_RET"><code>TOKU_HOOK_RET</code></a>,
        <a name="TOKU_HOOK_LINE"><code>TOKU_HOOK_LINE</code></a>,
        and <a name="TOKU_HOOK_COUNT"><code>TOKU_HOOK_COUNT</code></a>.
        Moreover, for line events, the field <code>currline</code> is also set.
        To get the value of any other field in <code>ar</code>,
        the hook must call
        <a href="#toku_getinfo"><code>toku_getinfo</code></a>.
        <br/><br/>
        For call events, <code>event</code> is <code>TOKU_HOOK_CALL</code>;
        for return events, <code>event</code> is <code>TOKU_HOOK_RET</code>;
        for line change events, <code>event</code> is
        <code>TOKU_HOOK_LINE</code>; after <em>count</em> opcodes are
        executed, <code>event</code> is <code>TOKU_HOOK_COUNT</code>.
        <br/><br/>
        While Tokudae is running a hook, it disables other calls to hooks.
        Therefore, if a hook calls back Tokudae to execute a function or a
        chunk, this execution occurs without any calls to hooks.
        <p>

        <hr><h3><a name="toku_upvalueindex"><code>toku_upvalueindex</code></a></h3><p>
        <span class="apii">[-0, +0, &ndash;]</span>
        <pre>int toku_upvalueindex (unsigned short i);</pre>
        <p>
        Returns the pseudo-index that represents the upvalue at index
        <code>i</code> (starting from 0) of the running function
        (see <a href="#4.2">&sect;4.2</a>).
        </p>

        <!-- toku_newstate -->
        <hr><h3><a name="toku_newstate"><code>toku_newstate</code></a></h3>
        <span class="apii">[-0, +0, &ndash;]</span>
        <pre>void toku_newstate (toku_Alloc f, void *ud, unsigned int seed);</pre>
        <p>
        Creates a new independent state and returns its main thread.
        Returns <code>NULL</code> if it cannot create the state
        (due to lack of memory).
        The argument <code>f</code> is the allocator function;
        Tokudae will do all memory allocation for this state through this
        function (see <a href="#toku_Alloc"><code>toku_Alloc</code></a>).
        The second argument, <code>ud</code>, is an opaque pointer that
        Tokudae passes to the allocator in every call.
        The third argument <code>seed</code>, is a seed for the hashing
        of the strings.
        </p>

        <!-- toku_close -->
        <hr><h3><a name="toku_close"><code>toku_close</code></a></h3>
        <span class="apii">[-0, +0, &ndash;]</span>
        <pre>void toku_close (toku_State *T);</pre>
        <p>
        Close all active to-be-closed variables in the main thread,
        release all objects in the given Tokudae state
        (calling the corresponding garbage-collection metamethods, if any),
        and free all dynamic memory used by this state.
        <br/><br/>
        On several platforms, you may not need to call this function,
        because all resources are naturally released when the host program ends.
        On the other hand, long-running programs that create multiple states,
        such as daemons or web servers, will probably need to close states as
        soon as they are not needed.
        </p>

        <!-- toku_newthread -->
        <hr><h3><a name="toku_newthread"><code>toku_newthread</code></a></h3>
        <span class="apii">[-0, +1, <em>m</em>]</span>
        <pre>toku_State *toku_newthread (toku_State *T);</pre>
        <p>
        Creates a new thread, pushes it on the stack,
        and returns a pointer to a <a href="#toku_State"><code>toku_State</code></a>
        that represents this new thread.
        The new thread returned by this function shares with the original
        thread its global environment, but has an independent execution stack.
        <br/><br/>
        Threads are subject to garbage collection, like any Tokudae object.
        </p>

        <!-- toku_resetthread -->
        <hr><h3><a name="toku_resetthread"><code>toku_resetthread</code></a></h3>
        <span class="apii">[-0, +?, &ndash;]</span>
        <pre>int toku_resetthread (toku_State *T);</pre>
        <p>
        Resets a thread, cleaning its call stack and closing all pending
        to-be-closed variables.
        Returns a status code: <a href="#TOKU_STATUS_OK"><code>TOKU_STATUS_OK</code></a>
        for no errors in the thread (either the original error that stopped
        the thread or errors in closing methods), or an error status otherwise.
        In case of error, leaves the error object on the top of the stack.
        </p>

        <!-- toku_atpanic -->
        <hr><h3><a name="toku_atpanic"><code>toku_atpanic</code></a></h3>
        <span class="apii">[-0, +0, &ndash;]</span>
        <pre>toku_CFunction toku_atpanic (toku_State *T, toku_CFunction panicf);</pre>
        <p>
        Sets a new panic function and returns the old one
        (see <a href="#4.4">&sect;4.4</a>).
        </p>

        <!-- toku_setallocf -->
        <hr><h3><a name="toku_setallocf"><code>toku_setallocf</code></a></h3>
        <span class="apii">[-0, +0, &ndash;]</span>
        <pre>void toku_setallocf (toku_State *T, toku_Alloc f, void *ud);</pre>
        <p>
        Changes the allocator function of a given state to <code>f</code>
        with user data <code>ud</code>.
        </p>

        <!-- toku_getallocf -->
        <hr><h3><a name="toku_getallocf"><code>toku_getallocf</code></a></h3>
        <span class="apii">[-0, +0, &ndash;]</span>
        <pre>toku_Alloc toku_getallocf (toku_State *T, void **ud);</pre>
        <p>
        Returns the memory-allocation function of a given state.
        If <code>ud</code> is not <code>NULL</code>, Tokudae stores in
        <code>*ud</code> the opaque pointer given when the memory-allocator
        function was set.
        </p>

        <!-- toku_setntop -->
        <hr><h3><a name="toku_setntop"><code>toku_setntop</code></a></h3>
        <span class="apii">[-?, +?, <em>e</em>]</span>
        <pre>void toku_setntop (toku_State *T, int n);</pre>
        <p>
        Sets the stack top to hold <code>n</code> values on the stack.
        If the new top is greater than the old one, then the new elements are
        filled with <b>nil</b>.
        If <code>n</code> is&nbsp;0, then all stack elements are removed.
        <br/><br/>
        This function can run arbitrary code when removing an index
        marked as to-be-closed from the stack.
        </p>

        <!-- toku_gettop -->
        <hr><h3><a name="toku_gettop"><code>toku_gettop</code></a></h3>
        <span class="apii">[-0, +0, &ndash;]</span>
        <pre>int toku_gettop (toku_State *T);</pre>
        <p>
        Returns the index of the top element in the stack.
        This result is equal to the number of elements in the stack - 1;
        So return value of -1&nbsp;means an empty stack.
        </p>

        <!-- toku_absindex -->
        <hr><h3><a name="toku_absindex"><code>toku_absindex</code></a></h3>
        <span class="apii">[-0, +0, &ndash;]</span>
        <pre>int toku_absindex (toku_State *T, int idx);</pre>
        <p>
        Converts the acceptable index <code>idx</code> into an equivalent
        absolute index (that is, one that does not depend on the stack size).
        </p>

        <!-- toku_rotate -->
        <hr><h3><a name="toku_rotate"><code>toku_rotate</code></a></h3>
        <span class="apii">[-0, +0, &ndash;]</span>
        <pre>void toku_rotate (toku_State *T, int idx, int n);</pre>
        <p>
        Rotates the stack elements between the valid index <code>idx</code>
        and the top of the stack.
        The elements are rotated <code>n</code> positions in the direction of
        the top, for a positive <code>n</code>, or <code>-n</code> positions
        in the direction of the bottom, for a negative <code>n</code>.
        The absolute value of <code>n</code> must not be greater than the size
        of the slice being rotated.
        This function cannot be called with a pseudo-index, because a
        pseudo-index is not an actual stack position.
        </p>

        <!-- toku_copy -->
        <hr><h3><a name="toku_copy"><code>toku_copy</code></a></h3>
        <span class="apii">[-0, +0, &ndash;]</span>
        <pre>void toku_copy (toku_State *T, int src, int dest);</pre>
        <p>
        Copies the element at index <code>src</code> into the valid
        index <code>dest</code>, replacing the value at that position.
        Values at other positions are not affected.
        </p>

        <!-- toku_checkstack -->
        <hr><h3><a name="toku_checkstack"><code>toku_checkstack</code></a></h3>
        <span class="apii">[-0, +0, &ndash;]</span>
        <pre>int toku_checkstack (toku_State *T, int n);</pre>
        <p>
        Ensures that the stack has space for at least <code>n</code> extra
        elements, that is, that you can safely push up to <code>n</code>
        values into it.
        It returns false if it cannot fulfill the request, either because it
        would cause the stack to be greater than a fixed maximum size
        (typically at least several thousand elements) or because it cannot
        allocate memory for the extra space.
        This function never shrinks the stack; if the stack already has space
        for the extra elements, it is left unchanged.
        </p>

        <!-- toku_push -->
        <hr><h3><a name="toku_push"><code>toku_push</code></a></h3>
        <span class="apii">[-0, +1, &ndash;]</span>
        <pre>void toku_push (toku_State *T, int idx);</pre>
        <p>
        Pushes a copy of the element at the given index onto the stack.
        </p>

        <!-- toku_xmove -->
        <hr><h3><a name="toku_xmove"><code>toku_xmove</code></a></h3>
        <span class="apii">[-?, +?, &ndash;]</span>
        <pre>void toku_xmove (toku_State *src, toku_State *dest, int n);</pre>
        <p>
        Exchange values between different threads of the same state.
        <br/><br/>
        This function pops <code>n</code> values from the stack
        <code>src</code>, and pushes them onto the stack <code>dest</code>.
        </p>

        <!-- toku_is_number -->
        <hr><h3><a name="toku_is_number"><code>toku_is_number</code></a></h3>
        <span class="apii">[-0, +0, &ndash;]</span>
        <pre>int toku_is_number (toku_State *T, int idx);</pre>
        <p>
        Returns 1 if the value at the given index is a number, and
        0&nbsp;otherwise.
        </p>

        <!-- toku_is_integer -->
        <hr><h3><a name="toku_is_integer"><code>toku_is_integer</code></a></h3>
        <span class="apii">[-0, +0, &ndash;]</span>
        <pre>int toku_is_integer (toku_State *T, int idx);</pre>
        <p>
        Returns 1 if the value at the given index is an integer
        (that is, the value is a number and is represented as an integer),
        and 0&nbsp;otherwise.
        </p>

        <!-- toku_is_string -->
        <hr><h3><a name="toku_is_string"><code>toku_is_string</code></a></h3>
        <span class="apii">[-0, +0, &ndash;]</span>
        <pre>int toku_is_string (toku_State *T);</pre>
        <p>
        </p>

        <!-- toku_is_cfunction -->
        <hr><h3><a name="toku_is_cfunction"><code>toku_is_cfunction</code></a></h3>
        <span class="apii">[-0, +0, &ndash;]</span>
        <pre>void toku_is_cfunction (toku_State *T, int idx);</pre>
        <p>
        Returns 1 if the value at the given index is a C&nbsp;function,
        and 0&nbsp;otherwise.
        </p>

        <!-- toku_is_udatamethod -->
        <hr><h3><a name="toku_is_udatamethod"><code>toku_is_udatamethod</code></a></h3>
        <span class="apii">[-0, +0, &ndash;]</span>
        <pre>void toku_is_udatamethod (toku_State *T, int idx);</pre>
        <p>
        Returns 1 if the value at the given index is a userdata bound method,
        and 0&nbsp;otherwise.
        </p>

        <!-- toku_is_userdata -->
        <hr><h3><a name="toku_is_userdata"><code>toku_is_userdata</code></a></h3>
        <span class="apii">[-0, +0, &ndash;]</span>
        <pre>int toku_is_userdata (toku_State *T, int idx);</pre>
        <p>
        Returns 1 if the value at the given index is a userdata
        (either full or light), and 0&nbsp;otherwise.
        </p>

        <!-- toku_type -->
        <hr><h3><a name="toku_type"><code>toku_type</code></a></h3>
        <span class="apii">[-0, +0, &ndash;]</span>
        <pre>int toku_type (toku_State *T, int idx);</pre>
        <p>
        Returns the type of the value in the given valid index <code>idx</code>,
        or <a href="#TOKU_T_NONE"><code>TOKU_T_NONE</code></a> for a
        non-valid but acceptable index.
        The types returned by <a href="#toku_type"><code>toku_type</code></a>
        are coded by the following constants defined in <code>tokudae.h</code>:
        <a name="TOKU_T_NIL"><code>TOKU_T_NIL</code></a>,
        <a name="TOKU_T_BOOL"><code>TOKU_T_BOOL</code></a>,
        <a name="TOKU_T_NUMBER"><code>TOKU_T_NUMBER</code></a>,
        <a name="TOKU_T_USERDATA"><code>TOKU_T_USERDATA</code></a>,
        <a name="TOKU_T_LIGHTUSERDATA"><code>TOKU_T_LIGHTUSERDATA</code></a>,
        <a name="TOKU_T_STRING"><code>TOKU_T_STRING</code></a>,
        <a name="TOKU_T_LIST"><code>TOKU_T_LIST</code></a>,
        <a name="TOKU_T_TABLE"><code>TOKU_T_TABLE</code></a>,
        <a name="TOKU_T_FUNCTION"><code>TOKU_T_FUNCTION</code></a>,
        <a name="TOKU_T_BMETHOD"><code>TOKU_T_BMETHOD</code></a>,
        <a name="TOKU_T_CLASS"><code>TOKU_T_CLASS</code></a>,
        <a name="TOKU_T_INSTANCE"><code>TOKU_T_INSTANCE</code></a>
        and <a name="TOKU_T_THREAD"><code>TOKU_T_THREAD</code></a>.
        </p>

        <!-- toku_typename -->
        <hr><h3><a name="toku_typename"><code>toku_typename</code></a></h3>
        <span class="apii">[-0, +0, &ndash;]</span>
        <pre>const char *toku_typename (toku_State *T, int type);</pre>
        <p>
        Returns the name of the type encoded by the value <code>type</code>,
        which must be one the values returned by
        <a href="#toku_type"><code>toku_type</code></a>.
        </p>

        <!-- toku_to_numberx -->
        <hr><h3><a name="toku_to_numberx"><code>toku_to_numberx</code></a></h3>
        <span class="apii">[-0, +0, &ndash;]</span>
        <pre>toku_Number toku_to_numberx (toku_State *T, int idx, int *isnum);</pre>
        <p>
        Converts the Tokudae value at the given index to the C&nbsp;type
        <a href="#toku_Number"><code>toku_Number</code></a>
        (see <a href="#toku_Number"><code>toku_Number</code></a>).
        The Tokudae value must be a number or integer convertible to a number
        (see <a href="#3.4.3">&sect;3.4.3</a>); otherwise,
        <a href="#toku_to_numberx"><code>toku_to_numberx</code></a>
        returns&nbsp;0.
        <br/><br/>
        If <code>isnum</code> is not <code>NULL</code>, its referent is
        assigned a boolean value that indicates whether the operation
        succeeded.
        </p>

        <!-- toku_to_integerx -->
        <hr><h3><a name="toku_to_integerx"><code>toku_to_integerx</code></a></h3>
        <span class="apii">[-0, +0, &ndash;]</span>
        <pre>toku_Integer toku_to_integerx (toku_State *T, int idx, int *isnum);</pre>
        <p>
        Converts the Tokudae value at the given index to the signed
        integral type <a href="#toku_Integer"><code>toku_Integer</code></a>.
        The Tokudae value must be an integer or a number convertible to an
        integer (see <a href="#3.4.3">&sect;3.4.3</a>);
        otherwise,
        <a href="#toku_to_integerx"><code>toku_to_integerx</code></a>
        returns&nbsp;0.
        <br/><br/>
        If <code>isnum</code> is not <code>NULL</code>, its referent is
        assigned a boolean value that indicates whether the operation
        succeeded.
        </p>

        <!-- toku_to_bool -->
        <hr><h3><a name="toku_to_bool"><code>toku_to_bool</code></a></h3>
        <span class="apii">[-0, +0, &ndash;]</span>
        <pre>int toku_to_bool (toku_State *T, int idx);</pre>
        <p>
        Converts the Tokudae value at the given index to a C&nbsp;boolean
        value (0&nbsp;or&nbsp;1).
        Like all tests in Tokudae,
        <a href="#toku_to_bool"><code>toku_to_bool</code></a>
        returns true for any Tokudae value different from <b>false</b> and
        <b>nil</b>; otherwise it returns false.
        (If you want to accept only actual boolean values,
        use <a href="#toku_is_bool"><code>toku_is_bool</code></a> to test the
        value's type.)
        </p>

        <!-- toku_to_lstring -->
        <hr><h3><a name="toku_to_lstring"><code>toku_to_lstring</code></a></h3>
        <span class="apii">[-0, +0, &ndash;]</span>
        <pre>const char *toku_to_lstring (toku_State *T, int idx, size_t *len);</pre>
        <p>
        Converts the Tokudae value at the given index to a C&nbsp;string.
        If <code>len</code> is not <code>NULL</code>,
        it sets <code>*len</code> with the string length.
        The Tokudae value must be a string; otherwise, the function returns
        <code>NULL</code>.
        <br/><br/>
        <a href="#toku_to_lstring"><code>toku_to_lstring</code></a>
        returns a pointer to a string inside the Tokudae state
        (see <a href="#4.1.3">&sect;4.1.3</a>).
        This string always has a zero ('<code>\0</code>') after its last
        character (as in&nbsp;C), but can contain other zeros in its body.
        </p>

        <!-- toku_to_cfunction -->
        <hr><h3><a name="toku_to_cfunction"><code>toku_to_cfunction</code></a></h3>
        <span class="apii">[-0, +0, &ndash;]</span>
        <pre>toku_CFunction toku_to_cfunction (toku_State *T, int idx);</pre>
        <p>
        Converts a value at the given index to a C&nbsp;function.
        That value must be a C&nbsp;function; otherwise, returns <code>NULL</code>.
        </p>

        <!-- toku_to_userdata -->
        <hr><h3><a name="toku_to_userdata"><code>toku_to_userdata</code></a></h3>
        <span class="apii">[-0, +0, &ndash;]</span>
        <pre>void *toku_to_userdata (toku_State *T, int idx);</pre>
        <p>
        If the value at the given index is a full userdata, returns its
        memory-block address.
        If the value is a light userdata, returns its value (a pointer).
        Otherwise, returns <code>NULL</code>.
        </p>

        <!-- toku_to_pointer -->
        <hr><h3><a name="toku_to_pointer"><code>toku_to_pointer</code></a></h3>
        <span class="apii">[-0, +0, &ndash;]</span>
        <pre>const void *toku_to_pointer (toku_State *T, int idx);</pre>
        <p>
        Converts the value at the given index to a generic C&nbsp;pointer
        (<code>void*</code>).
        The value can be an userdata, a table, a thread, a string, an instance,
        a class, a list, a bound method or a function; otherwise,
        <code>toku_to_pointer</code> returns <code>NULL</code>.
        Different objects will give different pointers.
        There is no way to convert the pointer back to its original value.
        <br/><br/>
        Typically this function is used only for hashing and debug information.
        </p>

        <!-- toku_to_thread -->
        <hr><h3><a name="toku_to_thread"><code>toku_to_thread</code></a></h3>
        <span class="apii">[-0, +0, &ndash;]</span>
        <pre>toku_State *toku_to_thread (toku_State *T, int idx);</pre>
        <p>
        Converts the value at the given index to a Tokudae thread
        (represented as <code>toku_State*</code>).
        This value must be a thread; otherwise, the function returns
        <code>NULL</code>.
        </p>

        <!-- toku_arith -->
        <hr><h3><a name="toku_arith"><code>toku_arith</code></a></h3>
        <span class="apii">[-(2|1), +1, <em>e</em>]</span>
        <pre>void toku_arith (toku_State *T, int op);</pre>
        <p>
        Performs an arithmetic or bitwise operation over the two values
        (or one, in the case of negations or bitwise NOT) at the top of
        the stack, with the value on the top being the second operand,
        pops these values, and pushes the result of the operation.
        The function follows the semantics of the corresponding Tokudae
        operator (that is, it may call metamethods).
        <br/><br/>
        The value of <code>op</code> must be one of the following constants:
        <ul>
            <li>
                <b><a name="TOKU_OP_ADD"><code>TOKU_OP_ADD</code></a>: </b>
                performs addition (<code>+</code>)
            </li>
            <li>
                <b><a name="TOKU_OP_SUB"><code>TOKU_OP_SUB</code></a>: </b>
                performs subtraction (<code>-</code>)
            </li>
            <li>
                <b><a name="TOKU_OP_MUL"><code>TOKU_OP_MUL</code></a>: </b>
                performs multiplication (<code>*</code>)
            </li>
            <li>
                <b><a name="TOKU_OP_DIV"><code>TOKU_OP_DIV</code></a>: </b>
                performs float division (<code>/</code>)
            </li>
            <li>
                <b><a name="TOKU_OP_IDIV"><code>TOKU_OP_IDIV</code></a>: </b>
                performs integer division (<code>//</code>)
            </li>
            <li>
                <b><a name="TOKU_OP_MOD"><code>TOKU_OP_MOD</code></a>: </b>
                performs modulo (<code>%</code>)
            </li>
            <li>
                <b><a name="TOKU_OP_POW"><code>TOKU_OP_POW</code></a>: </b>
                performs exponentiation (<code>**</code>)
            </li>
            <li>
                <b><a name="TOKU_OP_BSHL"><code>TOKU_OP_BSHL</code></a>: </b>
                performs left shift (<code>&lt;&lt;</code>)
            </li>
            <li>
                <b><a name="TOKU_OP_BSHR"><code>TOKU_OP_BSHR</code></a>: </b>
                performs right shift (<code>&gt;&gt;</code>)
            </li>
            <li>
                <b><a name="TOKU_OP_BAND"><code>TOKU_OP_BAND</code></a>: </b>
                performs bitwise AND (<code>&amp;</code>)
            </li>
            <li>
                <b><a name="TOKU_OP_BOR"><code>TOKU_OP_BOR</code></a>: </b>
                performs bitwise OR (<code>|</code>)
            </li>
            <li>
                <b><a name="TOKU_OP_BXOR"><code>TOKU_OP_BXOR</code></a>: </b>
                performs bitwise exclusive OR (<code>^</code>)
            </li>
            <li>
                <b><a name="TOKU_OP_UNM"><code>TOKU_OP_UNM</code></a>: </b>
                performs mathematical negation (unary <code>-</code>)
            </li>
            <li>
                <b><a name="TOKU_OP_BNOT"><code>TOKU_OP_BNOT</code></a>: </b>
                performs bitwise NOT (<code>~</code>)
            </li>
        </ul>
        </p>

        <!-- toku_rawequal -->
        <hr><h3><a name="toku_rawequal"><code>toku_rawequal</code></a></h3>
        <span class="apii">[-0, +0, &ndash;]</span>
        <pre>int toku_rawequal (toku_State *T, int idx1, int idx2);</pre>
        <p>
        Checks whether <code>idx1</code> is equal to <code>idx2</code>,
        without invoking the <code>__eq</code> metamethod.
        Returns a boolean.
        </p>

        <!-- toku_compare -->
        <hr><h3><a name="toku_compare"><code>toku_compare</code></a></h3>
        <span class="apii">[-0, +0, <em>e</em>]</span>
        <pre>int toku_compare (toku_State *T, int idx1, int idx2, int op);</pre>
        <p>
        Compares two Tokudae values.
        Returns 1 if the value at index <code>idx1</code> satisfies
        <code>op</code> when compared with the value at index
        <code>idx2</code>, following the semantics of the corresponding
        Tokudae operator (that is, it may call metamethods).
        Otherwise returns&nbsp;0.
        Also returns&nbsp;0 if any of the indices is not valid.
        <br/><br/>
        The value of <code>op</code> must be one of the following constants:
        <ul>
            <li>
                <b><a name="TOKU_ORD_EQ"><code>TOKU_ORD_EQ</code></a>: </b>
                compares for equality (<code>==</code>)
            </li>
            <li>
                <b><a name="TOKU_ORD_LT"><code>TOKU_ORD_LT</code></a>: </b>
                compares for less than (<code>&lt;</code>)
            </li>
            <li>
                <b><a name="TOKU_ORD_LE"><code>TOKU_ORD_LE</code></a>: </b>
                compares for less or equal (<code>&lt;=</code>)
            </li>
        </ul>
        </p>

        <!-- toku_push_nil -->
        <hr><h3><a name="toku_push_nil"><code>toku_push_nil</code></a></h3>
        <span class="apii">[-0, +1, &ndash;]</span>
        <pre>void toku_push_nil (toku_State *T);</pre>
        <p>
        Pushes a nil value onto the stack.
        </p>

        <!-- toku_push_number -->
        <hr><h3><a name="toku_push_number"><code>toku_push_number</code></a></h3>
        <span class="apii">[-0, +1, &ndash;]</span>
        <pre>void toku_push_number (toku_State *T, toku_Number n);</pre>
        <p>
        Pushes a float with value <code>n</code> onto the stack.
        </p>

        <!-- toku_push_integer -->
        <hr><h3><a name="toku_push_integer"><code>toku_push_integer</code></a></h3>
        <span class="apii">[-0, +1, &ndash;]</span>
        <pre>void toku_push_integer (toku_State *T, toku_Integer n);</pre>
        <p>
        Pushes an integer with value <code>n</code> onto the stack.
        </p>

        <!-- toku_push_lstring -->
        <hr><h3><a name="toku_push_lstring"><code>toku_push_lstring</code></a></h3>
        <span class="apii">[-0, +1, <em>m</em>]</span>
        <pre>const char *toku_push_lstring (toku_State *T, const char *s, size_t len);</pre>
        <p>
        Pushes the string pointed to by <code>s</code> with size
        <code>len</code> onto the stack.
        Tokudae will make or reuse an internal copy of the given string,
        so the memory at <code>s</code> can be freed or reused immediately
        after the function returns.
        The string can contain any binary data, including embedded zeros.
        <br/><br/>
        Returns a pointer to the internal copy of the string
        (see <a href="#4.1.3">&sect;4.1.3</a>).
        </p>

        <!-- toku_push_string -->
        <hr><h3><a name="toku_push_string"><code>toku_push_string</code></a></h3>
        <span class="apii">[-0, +1, <em>m</em>]</span>
        <pre>const char *toku_push_string (toku_State *T, const char *s);</pre>
        <p>
        Pushes the zero-terminated string pointed to by <code>s</code>
        onto the stack.
        Tokudae will make or reuse an internal copy of the given string,
        so the memory at <code>s</code> can be freed or reused immediately
        after the function returns.
        <br/><br/>
        Returns a pointer to the internal copy of the string
        (see <a href="#4.1.3">&sect;4.1.3</a>).
        <br/><br/>
        If <code>s</code> is <code>NULL</code>, pushes <b>nil</b> and
        returns <code>NULL</code>.
        </p>

        <!-- toku_push_fstring -->
        <hr><h3><a name="toku_push_fstring"><code>toku_push_fstring</code></a></h3>
        <span class="apii">[-0, +1, <em>v</em>]</span>
        <pre>const char *toku_push_fstring (toku_State *T, const char *fmt, ...);</pre>
        <p>
        Pushes onto the stack a formatted string and returns a pointer to
        this string (see <a href="#4.1.3">&sect;4.1.3</a>).
        It is similar to the ISO&nbsp;C function <code>sprintf</code>,
        but has two important differences.
        First, you do not have to allocate space for the result; the result
        is a Tokudae string and Tokudae takes care of memory allocation
        (and deallocation, through garbage collection).
        Second, the conversion specifiers are quite restricted.
        There are no flags, widths, or precisions.
        <br/>
        The conversion specifiers can only be:
        <ul>
            <li>
                '<code>%%</code>' (inserts the character '<code>%</code>'),
            </li>
            <li>
                '<code>%s</code>' (inserts a zero-terminated string, with no size restrictions),
            </li>
            <li>
                '<code>%f</code>' (inserts a <a href="#toku_Number"><code>toku_Number</code></a>),
            </li>
            <li>
                '<code>%I</code>' (inserts a <a href="#toku_Integer"><code>toku_Integer</code></a>),
            </li>
            <li>
                '<code>%p</code>' (inserts a pointer),
            </li>
            <li>
                '<code>%d</code>' (inserts an <code>int</code>),
            </li>
            <li>
                '<code>%u</code>' (inserts an <code>unsigned int</code>),
            </li>
            <li>
                '<code>%c</code>' (inserts an <code>int</code> as a one-byte character), and
            </li>
            <li>
                '<code>%U</code>' (inserts a <code>long int</code> as a UTF-8 byte sequence).
            </li>
        </ul>
        This function may raise errors due to memory overflow
        or an invalid conversion specifier.
        </p>

        <!-- toku_push_vfstring -->
        <hr><h3><a name="toku_push_vfstring"><code>toku_push_vfstring</code></a></h3>
        <span class="apii">[-0, +1, <em>v</em>]</span>
        <pre>const char *toku_push_vfstring (toku_State *T, const char *fmt, va_list argp);</pre>
        <p>
        Equivalent to
        <a href="#toku_push_fstring"><code>toku_push_fstring</code></a>,
        except that it receives a <code>va_list</code> instead of a variable
        number of arguments.
        </p>

        <!-- toku_push_cclosure -->
        <hr><h3><a name="toku_push_cclosure"><code>toku_push_cclosure</code></a></h3>
        <span class="apii">[-n, +1, <em>m</em>]</span>
        <pre>void toku_push_cclosure (toku_State *T, toku_CFunction f, int n);</pre>
        <p>
        Pushes a new C&nbsp;closure onto the stack.
        This function receives a pointer to a C&nbsp;function and pushes onto
        the stack a Tokudae value of type <code>function</code> that, when
        called, invokes the corresponding C&nbsp;function.
        The parameter <code>n</code> tells how many upvalues this function
        will have (see <a href="#4.2">&sect;4.2</a>).
        <br/><br/>
        Any function to be callable by Tokudae must follow the correct protocol
        to receive its parameters and return its results
        (see <a href="#toku_CFunction"><code>toku_CFunction</code></a>).
        <br/><br/>
        When a C&nbsp;function is created, it is possible to associate some
        values with it, the so called upvalues; these upvalues are then
        accessible to the function whenever it is called.
        This association is called a C&nbsp;closure
        (see <a href="#4.2">&sect;4.2</a>).
        To create a C&nbsp;closure, first the initial values for its upvalues
        must be pushed onto the stack.
        (When there are multiple upvalues, the first value is pushed first.)
        Then <a href="#toku_push_cclosure"><code>toku_push_cclosure</code></a>
        is called to create and push the C&nbsp;function onto the stack,
        with the argument <code>n</code> telling how many values will be
        associated with the function.
        <a href="#toku_push_cclosure"><code>toku_push_cclosure</code></a> also
        pops these values from the stack.
        <br/><br/>
        When <code>n</code> is zero, this function creates a
        <em>light C&nbsp;function</em>, which is just a pointer to the
        C&nbsp;function.
        In that case, it never raises a memory error.
        </p>

        <!-- toku_push_bool -->
        <hr><h3><a name="toku_push_bool"><code>toku_push_bool</code></a></h3>
        <span class="apii">[-0, +1, &ndash;]</span>
        <pre>void toku_push_bool (toku_State *T, int b);</pre>
        <p>
        Pushes a boolean value with value <code>b</code> onto the stack.
        </p>

        <!-- toku_push_lightuserdata -->
        <hr><h3><a name="toku_push_lightuserdata"><code>toku_push_lightuserdata</code></a></h3>
        <span class="apii">[-0, +1, &ndash;]</span>
        <pre>void toku_push_lightuserdata (toku_State *T, void *p);</pre>
        <p>
        Pushes a light userdata onto the stack.
        <br/><br/>
        Userdata represent C&nbsp;values in Tokudae.
        A <em>light userdata</em> represents a pointer, a <code>void*</code>.
        It is a value (like a number): you do not create it and it is not
        collected (as it was never created).
        A light userdata is equal to "any" light userdata with the same
        C&nbsp;address.
        </p>

        <!-- toku_push_userdata -->
        <hr><h3><a name="toku_push_userdata"><code>toku_push_userdata</code></a></h3>
        <span class="apii">[-0, +1, <em>m</em>]</span>
        <pre>void *toku_push_userdata (toku_State *T, size_t size, unsigned short nuv);</pre>
        <p>
        This function creates and pushes on the stack a new full userdata,
        with <code>nuv</code> associated Tokudae values, called
        <code>user values</code>, plus an associated block of raw memory with
        <code>size</code> bytes.
        (The user values can be set and read with the functions
        <a href="#toku_set_uservalue"><code>toku_set_uservalue</code></a> and
        <a href="#toku_get_uservalue"><code>toku_get_uservalue</code></a>.)
        <br/><br/>
        The function returns the address of the block of memory.
        Tokudae ensures that this address is valid as long as the corresponding
        userdata is alive (see <a href="#2.5">&sect;2.5</a>).
        Moreover, if the userdata is marked for finalization
        (see <a href="#2.5.2">&sect;2.5.2</a>), its address is valid at least
        until the call to its finalizer.
        </p>

        <!-- toku_push_list -->
        <hr><h3><a name="toku_push_list"><code>toku_push_list</code></a></h3>
        <span class="apii">[-0, +1, <em>m</em>]</span>
        <pre>void toku_push_list (toku_State *T, int size);</pre>
        <p>
        Creates a new empty list and pushes it on the stack.
        Parameter <code>size</code> is a hint for how many elements the
        list will have.
        Tokudae may use these hints to preallocate memory for the new list.
        This preallocation may help performance when you know in advance how
        many elements the list will have.
        </p>

        <!-- toku_push_table -->
        <hr><h3><a name="toku_push_table"><code>toku_push_table</code></a></h3>
        <span class="apii">[-0, +1, <em>m</em>]</span>
        <pre>void toku_push_table (toku_State *T, int size);</pre>
        <p>
        Creates a new empty table and pushes it on the stack.
        Parameter <code>size</code> is a hint for how many fields the
        table will have, similar to
        <a href="#toku_push_list"><code>toku_push_list</code></a>.
        </p>

        <!-- toku_push_thread -->
        <hr><h3><a name="toku_push_thread"><code>toku_push_thread</code></a></h3>
        <span class="apii">[-0, +1, &ndash;]</span>
        <pre>int toku_push_thread (toku_State *T);</pre>
        <p>
        Pushes the thread represented by <code>T</code> onto the stack.
        Returns 1 if this thread is the main thread of its state.
        </p>

        <!-- toku_push_class -->
        <hr><h3><a name="toku_push_class"><code>toku_push_class</code></a></h3>
        <span class="apii">[-0, +1, <em>m</em>]</span>
        <pre>void toku_push_class (toku_State *T);</pre>
        <p>
        Creates a new class and pushes it on the stack.
        This class has neither methods table nor metatable.
        In order to set class methods see
        <a href="#toku_set_methodtable"><code>toku_set_methodtable</code></a>, and
        to set metatable see
        <a href="#toku_set_metatable"><code>toku_set_metatable</code></a>.
        </p>

        <!-- toku_push_instance -->
        <hr><h3><a name="toku_push_instance"><code>toku_push_instance</code></a></h3>
        <span class="apii">[-0, +1, <em>e</em>]</span>
        <pre>void toku_push_instance (toku_State *T, int idx);</pre>
        <p>
        Creates a new instance of the class at the given index and pushes
        it on the stack.
        <br/><br/>
        As in Tokudae, this function may trigger a metamethod for the
        <code>__init</code> event (see <a href="#2.4">&sect;2.4</a>).;
        <br/>
        (In which case the pushed value might not necessarily be the instance
        of the class.)
        </p>

        <!-- toku_push_boundmethod -->
        <hr><h3><a name="toku_push_boundmethod"><code>toku_push_boundmethod</code></a></h3>
        <span class="apii">[-1, +1, <em>m</em>]</span>
        <pre>void toku_push_boundmethod (toku_State *T, int idx);</pre>
        <p>
        Creates a new bound method object and pushes it on the stack.
        The receiver, <em>self</em> object, is at the given index, and the
        method object is on the stack top. This function pops the method
        object, pushing the bound method in its place.
        <br/><br/>
        In order to later &lsquo;<em>disassemble</em>&rsquo; the bound method,
        see <a href="#toku_get_self"><code>toku_get_self</code></a> and
        <a href="#toku_get_method"><code>toku_get_method</code></a>.
        </p>

        <!-- toku_get -->
        <hr><h3><a name="toku_get"><code>toku_get</code></a></h3>
        <span class="apii">[-1, +1, <em>e</em>]</span>
        <pre>int toku_get (toku_State *T, int idx);</pre>
        <p>
        Pushes on the stack the value <code>obj[k]</code>, where
        <code>obj</code> is the value at the given index and <code>k</code>
        is the value on top of the stack.
        <br/><br/>
        This function pops the key from the stack, pushing the resulting
        value in its place.
        As in Tokudae, this function may trigger a metamethod
        for the <code>__getidx</code> event (see <a href="#2.4">&sect;2.4</a>).
        <br/><br/>
        Returns the type of the pushed value.
        </p>

        <!-- toku_get_raw -->
        <hr><h3><a name="toku_get_raw"><code>toku_get_raw</code></a></h3>
        <span class="apii">[-1, +1, &ndash;]</span>
        <pre>int toku_get_raw (toku_State *T, int index);</pre>
        <p>
        Similar to <a href="#toku_get"><code>toku_get</code></a>, but does a
        raw access (i.e., without metamethods).
        The value at <code>index</code> must be a table, list or instance.
        </p>

        <!-- toku_get_global_str -->
        <hr><h3><a name="toku_get_global_str"><code>toku_get_global_str</code></a></h3>
        <span class="apii">[-0, +1, &ndash;]</span>
        <pre>int toku_get_global_str (toku_State *T, const char *name);</pre>
        <p>
        Pushes onto the stack the value of the global <code>name</code>.
        Returns the type of that value.
        </p>

        <!-- toku_get_index -->
        <hr><h3><a name="toku_get_index"><code>toku_get_index</code></a></h3>
        <span class="apii">[-0, +1, &ndash;]</span>
        <pre>int toku_get_index (toku_State *T, int idx, toku_Integer i);</pre>
        <p>
        Pushes onto the stack the value <code>l[i]</code>,
        where <code>l</code> is the list at the given index.
        <br/><br/>
        Returns the type of the pushed value.
        </p>

        <!-- toku_get_cindex -->
        <hr><h3><a name="toku_get_cindex"><code>toku_get_cindex</code></a></h3>
        <span class="apii">[-0, +1, &ndash;]</span>
        <pre>int toku_get_cindex (toku_State *T, toku_Integer i);</pre>
        <p>
        Similar to <a href="#toku_get_index"><code>toku_get_index</code></a>,
        except the list is at the pseudo-index
        <a href="#TOKU_CLIST_INDEX"><code>TOKU_CLIST_INDEX</code></a>.
        </p>

        <!-- toku_get_field -->
        <hr><h3><a name="toku_get_field"><code>toku_get_field</code></a></h3>
        <span class="apii">[-1, +1, &ndash;]</span>
        <pre>int toku_get_field (toku_State *T, int idx);</pre>
        <p>
        Similar to <a href="#toku_get_raw"><code>toku_get_raw</code></a>,
        except that the value at <code>idx</code> can only be a table or an
        instance. Additionally, this is convenient when we want to avoid
        creating an instance bound method in cases where the field is not
        present but method is, as is the case in
        <a href="#toku_get_raw"><code>toku_get_raw</code></a>.
        <br/><br/>
        Returns the type of the pushed value.
        </p>

        <!-- toku_get_field_str -->
        <hr><h3><a name="toku_get_field_str"><code>toku_get_field_str</code></a></h3>
        <span class="apii">[-0, +1, &ndash;]</span>
        <pre>int toku_get_field_str (toku_State *T, int index, const char *s);</pre>
        <p>
        Similar to <a href="#toku_get_field"><code>toku_get_field</code></a>
        but instead of using the value on top of the stack as key, it instead
        uses the argument <code>s</code> which is a null-terminated string
        (i.e.,&nbsp;<code>obj[s]</code>).
        <br/><br/>
        Returns the type of the pushed value.
        </p>

        <!-- toku_get_field_int -->
        <hr><h3><a name="toku_get_field_int"><code>toku_get_field_int</code></a></h3>
        <span class="apii">[-0, +1, &ndash;]</span>
        <pre>int toku_get_field_int (toku_State *T, int index, toku_Integer i);</pre>
        <p>
        Identical to <a href="#toku_get_field_str"><code>toku_get_field_str</code></a>
        except the key is argument <code>i</code> which is a
        <a href="#toku_Integer"><code>toku_Integer</code></a>.
        <br/><br/>
        Returns the type of the pushed value.
        </p>

        <!-- toku_get_cfield_str -->
        <hr><h3><a name="toku_get_cfield_str"><code>toku_get_cfield_str</code></a></h3><p>
        <span class="apii">[-0, +1, &ndash;]</span>
        <pre>int toku_get_cfield_str (toku_State *T, const char *s);</pre>
        <p>
        Equivalent to <code>t[s]</code> where <code>t</code> is the
        <em>C table</em> located at the pseudo-index
        <a href="#TOKU_CTABLE_INDEX"><code>TOKU_CTABLE_INDEX</code></a>
        (see <a href="#4.3">&sect;4.3</a>).
        <br/><br/>
        Returns the type of the pushed value.
        </p>

        <!-- toku_get_class -->
        <hr><h3><a name="toku_get_class"><code>toku_get_class</code></a></h3>
        <span class="apii">[-0, +0|1, &ndash;]</span>
        <pre>int toku_get_class (toku_State *T, int idx);</pre>
        <p>
        Pushes the class of the object at the given index on the stack.
        <br/><br/>
        Returns <code>TOKU_T_CLASS</code> if the object at <code>index</code>
        is instance, otherwise nothing is pushed and this returns 
        <a href="#TOKU_T_NONE"><code>TOKU_T_NONE</code></a>.
        </p>

        <!-- toku_get_superclass -->
        <hr><h3><a name="toku_get_superclass"><code>toku_get_superclass</code></a></h3>
        <span class="apii">[-0, +(0|1), &ndash;]</span>
        <pre>int toku_get_superclass (toku_State *T, int idx);</pre>
        <p>
        Pushes the superclass of the value at the given index on the stack.
        The value at the given index must be either a class or an instance.
        <br/><br/>
        Returns 1 if the value has a superclass, otherwise nothing is pushed
        and 0 is returned.
        </p>

        <!-- toku_get_method -->
        <hr><h3><a name="toku_get_method"><code>toku_get_method</code></a></h3>
        <span class="apii">[-0, +1, &ndash;]</span>
        <pre>int toku_get_method (toku_State *T, int index);</pre>
        <p>
        Pushes a method object of the bound method at the given index onto
        the stack.
        <br/><br/>
        Returns the type of the method object.
        </p>

        <!-- toku_get_self -->
        <hr><h3><a name="toku_get_self"><code>toku_get_self</code></a></h3>
        <span class="apii">[-0, +1, &ndash;]</span>
        <pre>int toku_get_self (toku_State *T, int idx);</pre>
        <p>
        Pushes a <em>self</em> object of the bound method at the given index
        onto the stack.
        <br/><br/>
        Returns the type of the <em>self</em> object.
        </p>

        <!-- toku_get_uservalue -->
        <hr><h3><a name="toku_get_uservalue"><code>toku_get_uservalue</code></a></h3>
        <span class="apii">[-0, +1, &ndash;]</span>
        <pre>int toku_get_uservalue (toku_State *T, int idx, unsigned short n);</pre>
        <p>
        Pushes onto the stack the user value at index <code>n</code>
        associated with the full userdata at the given index and returns
        the type of the pushed value.
        <br/><br/>
        If the userdata does not have that value, pushes <b>nil</b> and
        returns <a href="#TOKU_T_NONE"><code>TOKU_T_NONE</code></a>.
        </p>

        <!-- toku_get_methodtable -->
        <hr><h3><a name="toku_get_methodtable"><code>toku_get_methodtable</code></a></h3>
        <span class="apii">[-0, +(0|1), &ndash;]</span>
        <pre>int toku_get_methodtable (toku_State *T, int idx);</pre>
        <p>
        Checks if the class at the given index has a method table and pushes
        it onto the stack.
        <br/><br/>
        Returns 1 if the class has a method table, meaning the table was
        pushed, otherwise nothing is pushed and 0 is returned.
        </p>

        <!-- toku_get_metatable -->
        <hr><h3><a name="toku_get_metatable"><code>toku_get_metatable</code></a></h3>
        <span class="apii">[-0, +(0|1), &ndash;]</span>
        <pre>int toku_get_metatable (toku_State *T, int idx);</pre>
        <p>
        Pushes the metatable of the value at the given index onto the stack.
        Only <em>full userdata</em>, <em>class</em> and transitively
        <em>instance</em> values have a metatable.
        <br/><br/>
        This returns 1 if the value at given index has a metatable, meaning
        the table is pushed, otherwise nothing is pushed onto the stack and
        0 is returned.
        </p>

        <!-- toku_get_fieldtable -->
        <hr><h3><a name="toku_get_fieldtable"><code>toku_get_fieldtable</code></a></h3>
        <span class="apii">[-0, +1, &ndash;]</span>
        <pre>void toku_get_fieldtable (toku_State *T, int idx);</pre>
        <p>
        Pushes the fields table of the instance at the given index onto the
        stack. Instances always have a table to store fields (state) so
        this always pushes the table.
        </p>

        <!-- toku_set -->
        <hr><h3><a name="toku_set"><code>toku_set</code></a></h3>
        <span class="apii">[-2, +0, <em>e</em>]</span>
        <pre>void toku_set (toku_State *T, int idx);</pre>
        <p>
        Does the equivalent to <code>obj[k]&nbsp;=&nbsp;v;</code>, where <code>obj</code>
        is the value at the given index, <code>v</code> is the value on top of
        the stack and <code>k</code> is the key value on stack below
        the&nbsp;<code>v</code>.
        <br/><br/>
        This function pops both the key and value off the stack.
        As in Tokudae, this function may trigger a metamethod
        for the <code>__setidx</code> event (see <a href="#2.4">&sect;2.4</a>).
        </p>

        <!-- toku_set_raw -->
        <hr><h3><a name="toku_set_raw"><code>toku_set_raw</code></a></h3>
        <span class="apii">[-2, +0, <em>v</em>]</span>
        <pre>void toku_set_raw (toku_State *T, int index);</pre>
        <p>
        Similar to <a href="#toku_set"><code>toku_set</code></a> except that
        it performs a raw set, meaning it wont invoke a metamethod.
        <br/>
        Value at the given index must be a table, a list or an instance,
        otherwise this function errors as the value can't be indexed.
        <br/><br/>
        This function pops both the key and value off the stack.
        </p>

        <!-- toku_set_global_str -->
        <hr><h3><a name="toku_set_global_str"><code>toku_set_global_str</code></a></h3>
        <span class="apii">[-1, +0, <em>m</em>]</span>
        <pre>void toku_set_global_str (toku_State *T, const char *name);</pre>
        <p>
        Pops a value from the stack and sets it as the new value of global
        <code>name</code>.
        </p>

        <!-- toku_set_index -->
        <hr><h3><a name="toku_set_index"><code>toku_set_index</code></a></h3>
        <span class="apii">[-1, +0, <em>v</em>]</span>
        <pre>void toku_set_index (toku_State *T, int idx, toku_Integer i);</pre>
        <p>
        Does the equivalent of <code>l[i]&nbsp;=&nbsp;v</code>, where <code>l</code>
        is the list at the given index, <code>i</code> is index into the
        list and <code>v</code> is element value on top of the stack.
        <br/>
        As in Tokudae, the list index <code>i</code> in unsigned
        representation must be in valid range of <code>[0,len]</code>,
        where <code>len</code> is the length of the list.
        If <code>i</code> is equal to the length of the list, the value is
        appended and list length incremented by 1.
        <br/><br/>
        Tokudae can raise memory error, or list size error if the value is
        being appended and the list length would be too large or index
        bounds error if <code>i</code> is out of the valid range.
        <br/><br/>
        This function pops the element value off the stack.
        </p>

        <!-- toku_set_cindex -->
        <hr><h3><a name="toku_set_cindex"><code>toku_set_cindex</code></a></h3>
        <span class="apii">[-1, +0, <em>v</em>]</span>
        <pre>void toku_set_cindex (toku_State *T, toku_Integer i);</pre>
        <p>
        Similar to <a href="#toku_set_index"><code>toku_set_index</code></a>
        but instead, the list is a <em>C list</em> located at the pseudo-index
        <a href="#TOKU_CLIST_INDEX"><code>TOKU_CLIST_INDEX</code></a>
        (see <a href="#4.3">&sect;4.3</a>).
        </p>

        <!-- toku_set_field -->
        <hr><h3><a name="toku_set_field"><code>toku_set_field</code></a></h3>
        <span class="apii">[-2, +0, <em>m</em>]</span>
        <pre>void toku_set_field (toku_State *T, int index);</pre>
        <p>
        Similar to <a href="#toku_set_raw"><code>toku_set_raw</code></a> but
        the value at <code>index</code> must be a table or an instance
        (list is not allowed as lists do not have fields).
        <br/>
        Optimized API call you should use if you are setting table or
        instance field.
        <br/><br/>
        This function pops both the key and value off the stack.
        </p>

        <!-- toku_set_field_str -->
        <hr><h3><a name="toku_set_field_str"><code>toku_set_field_str</code></a></h3>
        <span class="apii">[-1, +0, <em>m</em>]</span>
        <pre>void toku_set_field_str (toku_State *T, int index, const char *s);</pre>
        <p>
        Similar to <a href="#toku_set_field"><code>toku_set_field</code></a>
        but instead of using the value on stack as the key, it instead uses
        the argument <code>s</code> which is null-terminated string
        (i.e.,&nbsp;<code>obj[s]&nbsp;=&nbsp;v</code>).
        <br/>
        Optimized API call you should use if you are setting <em>string</em>
        table or instance field.
        <br/><br/>
        This function pops the value off the stack.
        </p>

        <!-- toku_set_field_int -->
        <hr><h3><a name="toku_set_field_int"><code>toku_set_field_int</code></a></h3>
        <span class="apii">[-0, +0, <em>m</em>]</span>
        <pre>void toku_set_field_int (toku_State *T, int index, toku_Integer i);</pre>
        <p>
        Similar to
        <a href="#toku_set_field_str"><code>toku_set_field_str</code></a>
        except the key argument <code>i</code> is a
        <a href="#toku_Integer">toku_Integer</a>.
        <br/>
        Optimized API call you should use if you are setting <em>integer</em>
        table or instance field.
        </p>

        <!-- toku_set_cfield_str -->
        <hr><h3><a name="toku_set_cfield_str"><code>toku_set_cfield_str</code></a></h3>
        <span class="apii">[-1, +0, <em>m</em>]</span>
        <pre>void toku_set_cfield_str (toku_State *T, const char *s);</pre>
        <p>
        Similar to
        <a href="#toku_set_field_str"><code>toku_set_field_str</code></a>,
        except the object we are setting is a <em>C table</em> located at the
        pseudo-index
        <a href="#TOKU_CTABLE_INDEX"><code>TOKU_CTABLE_INDEX</code></a>
        (see <a href="#4.3">&sect;4.3</a>).
        </p>

        <!-- toku_set_superclass -->
        <hr><h3><a name="toku_set_superclass"><code>toku_set_superclass</code></a></h3>
        <span class="apii">[-1, +0, &ndash;]</span>
        <pre>void toku_set_superclass (toku_State *T, int idx);</pre>
        <p>
        The value on top of the stack is set as the superclass of the value
        at the given index. Both of the values need to be classes.
        <br/><br/>
        This function pops the value on top of the stack.
        </p>

        <!-- toku_set_metatable -->
        <hr><h3><a name="toku_set_metatable"><code>toku_set_metatable</code></a></h3>
        <span class="apii">[-1, +0, &ndash;]</span>
        <pre>int toku_set_metatable (toku_State *T, int idx);</pre>
        <p>
        Sets the value on top of the stack as the new <em>metatable</em> of the
        value at the given index. If the value on top of the stack is
        a <b>nil</b> value, then the metatable is removed.
        The value at the given index must be a class or full userdata object.
        <br/><br/>
        In case the value at the given index is a full userdata, the
        metatable is not <b>nil</b>, and the metatable contains the
        <code>__gc</code> entry, the usual rules apply
        (see <a href="#2.5.2">&sect;2.5.2</a>).
        However if the value is a class, and the previous metatable
        didn't have a <code>__gc</code> entry, each already existing instance
        of that class won't trigger <code>__gc</code> event before it gets
        collected.
        <br/><br/>
        This pops off the value on top of the stack.
        </p>

        <!-- toku_set_uservalue -->
        <hr><h3><a name="toku_set_uservalue"><code>toku_set_uservalue</code></a></h3>
        <span class="apii">[-1, +0, &ndash;]</span>
        <pre>int toku_set_uservalue (toku_State *T, int idx, unsigned short n);</pre>
        <p>
        Pops a value from the stack and sets it as the new user value at index
        <code>n</code> associated to the full userdata at the given index.
        <br/><br/>
        Returns 0 if the userdata does not have that value.
        </p>

        <!-- toku_set_methodtable -->
        <hr><h3><a name="toku_set_methodtable"><code>toku_set_methodtable</code></a></h3>
        <span class="apii">[-1, +0, &ndash;]</span>
        <pre>int toku_set_methodtable (toku_State *T, int idx);</pre>
        <p>
        Pops a value on top of the stack, which must be a table,
        and sets it as the method table of the value at the given index,
        which must be a class.
        </p>

        <!-- toku_set_fieldtable -->
        <hr><h3><a name="toku_set_fieldtable"><code>toku_set_fieldtable</code></a></h3>
        <span class="apii">[-1, +0, &ndash;]</span>
        <pre>void toku_set_fieldtable (toku_State *T, int idx);</pre>
        <p>
        Pops a value on top of the stack, which must be a table,
        and sets it as the fields table of the value at the given index,
        which must be an instance.
        </p>

        <!-- toku_status -->
        <hr><h3><a name="toku_status"><code>toku_status</code></a></h3>
        <span class="apii">[-0, +0, &ndash;]</span>
        <pre>int toku_status (toku_State *T);</pre>
        <p>
        Returns the status of the thread <code>C</code>.
        <br/><br/>
        The status can be
        <a href="#TOKU_STATUS_OK"><code>TOKU_STATUS_OK</code></a>
        for a normal thread.
        <br/><br/>
        You can call functions only in threads with status
        <a href="#TOKU_STATUS_OK"><code>TOKU_STATUS_OK</code></a>.
        </p>

        <!-- toku_error -->
        <hr><h3><a name="toku_error"><code>toku_error</code></a></h3>
        <span class="apii">[-0, +0, &ndash;]</span>
        <pre>int toku_error (toku_State *T);</pre>
        <p>
        Raises a Tokudae error, using the value on the top of the stack as
        the error object.
        This function does a long jump, and therefore never returns
        (see <a href="#tokuL_error"><code>tokuL_error</code></a>).
        </p>

        <!-- toku_call -->
        <hr><h3><a name="toku_call"><code>toku_call</code></a></h3>
        <span class="apii">[-(nargs+1), +nresults, <em>e</em>]</span>
        <pre>void toku_call (toku_State *T, int nargs, int nresults);</pre>
        <p>
        Calls a function.
        Like regular Tokudae calls, <code>toku_call</code> respects the
        <code>__call</code> metamethod.
        So, here the word "function" means any callable value.
        <br/><br/>
        To do a call you must use the following protocol:
        first, the function to be called is pushed onto the stack;
        then, the arguments to the call are pushed in direct order;
        that is, the first argument is pushed first.
        Finally you call <a href="#toku_call"><code>toku_call</code></a>;
        <code>nargs</code> is the number of arguments that you pushed onto
        the stack.
        When the function returns, all arguments and the function value are
        popped and the call results are pushed onto the stack.
        The number of results is adjusted to <code>nresults</code>,
        unless <code>nresults</code> is
        <a name="TOKU_MULTRET"><code>TOKU_MULTRET</code></a>.
        In this case, all results from the function are pushed;
        Tokudae takes care that the returned values fit into the stack space,
        but it does not ensure any extra space in the stack.
        The function results are pushed onto the stack in direct order
        (the first result is pushed first), so that after the call the last
        result is on the top of the stack.
        <br/><br/>
        Any error while calling and running the function is propagated upwards
        (with a <code>longjmp</code>).
        <br/><br/>
        The following example shows how the host program can do the
        equivalent to this Tokudae code:

        <pre>
    a = f("how", t.x, 14);</pre>

        Here it is in&nbsp;C:

        <pre>
    toku_get_global_str(T, "f");              /* function to be called */
    toku_push_literal(T, "how");                       /* 1st argument */
    toku_get_global_str(T, "t");    /* table or instance to be indexed */
    toku_get_field_str(T, -1, "x");    /* push result of t.x (2nd arg) */
    toku_remove(T, -2);                   /* remove 't' from the stack */
    toku_push_integer(T, 14);                          /* 3rd argument */
    toku_call(T, 3, 1);      /* call 'f' with 3 arguments and 1 result */
    toku_set_global_str(T, "a");                     /* set global 'a' */</pre>

        Note that the code above is <em>balanced</em>:
        at its end, the stack is back to its original configuration.
        This is considered good programming practice.
        </p>

        <!-- toku_pcall -->
        <hr><h3><a name="toku_pcall"><code>toku_pcall</code></a></h3>
        <span class="apii">[-(nargs + 1), +(nresults|1), &ndash;]</span>
        <pre>int toku_pcall (toku_State *T, int nargs, int nresults, int absmsgh);</pre>
        <p>
        Calls a function (or a callable object) in protected mode.
        <br/><br/>
        Both <code>nargs</code> and <code>nresults</code> have the same
        meaning as in <a href="#toku_call"><code>toku_call</code></a>.
        If there are no errors during the call,
        <a href="#toku_pcall"><code>toku_pcall</code></a> behaves exactly like
        <a href="#toku_call"><code>toku_call</code></a>.
        However, if there is any error,
        <a href="#toku_pcall"><code>toku_pcall</code></a> catches it, pushes a
        single value on the stack (the error object), and returns an error code.
        Like <a href="#toku_call"><code>toku_call</code></a>,
        <a href="#toku_pcall"><code>toku_pcall</code></a> always removes the
        function and its arguments from the stack.
        <br/><br/>
        If <code>absmsgh</code> is less than 0, then the error object returned
        on the stack is exactly the original error object.
        Otherwise, <code>absmsgh</code> is the absolute stack index of a
        <em>message handler</em>.
        (Meaning this index cannot be a pseudo-index or negative.)
        In case of runtime errors, this handler will be called with the error
        object and its return value will be the object returned on the stack
        by <a href="#toku_pcall"><code>toku_pcall</code></a>.
        <br/><br/>
        Typically, the message handler is used to add more debug information
        to the error object, such as a stack traceback.
        Such information cannot be gathered after the return of
        <a href="#toku_pcall"><code>toku_pcall</code></a>, since by then the stack
        has unwound.
        <br/><br/>
        The <a href="#toku_pcall"><code>toku_pcall</code></a> function returns one
        of the following status codes:
        <a href="#TOKU_STATUS_OK"><code>TOKU_STATUS_OK</code></a>,
        <a href="#TOKU_STATUS_ERUNTIME"><code>TOKU_STATUS_ERUNTIME</code></a>,
        <a href="#TOKU_STATUS_EMEM"><code>TOKU_STATUS_EMEM</code></a> or
        <a href="#TOKU_STATUS_EERROR"><code>TOKU_STATUS_EERROR</code></a>.
        </p>

        <!-- toku_load -->
        <hr><h3><a name="toku_load"><code>toku_load</code></a></h3>
        <span class="apii">[-0, +1, &ndash;]</span>
        <pre>int toku_load (toku_State *T,
               toku_Reader reader,
               void *userdata,
               const char *chunkname,
               const char *mode);</pre>
        <p>
        Loads a Tokudae chunk without running it.
        If there are no errors, <code>toku_load</code> pushes the compiled chunk
        as a Tokudae function on top of the stack.
        Otherwise, it pushes an error message.
        <br/><br/>
        The <code>toku_load</code> function uses a user-supplied
        <code>reader</code> function to read the chunk
        (see <a href="#toku_Reader"><code>toku_Reader</code></a>).
        The <code>userdata</code> argument is an opaque value passed to the
        reader function.
        <br/><br/>
        The <code>chunkname</code> argument gives a name to the chunk, which
        is used for error messages and in debug information
        (see <a href="#toku_Debug"><code>toku_Debug</code></a>).
        <br/><br/>
        <code>toku_load</code> automatically detects whether the chunk
        is text or binary and loads it accordingly
        (see program <code>tokudaec</code>).
        The string <code>mode</code> works as in function
        <a href="#load"><code>load</code></a>, with the addition that a
        <code>NULL</code> value is equivalent to the string "<code>bt</code>".
        <br/><br/>
        <code>toku_load</code> uses the stack internally, so the reader function
        must always leave the stack unmodified when returning.
        <br/><br/>
        <code>toku_load</code> can return
        <a href="#TOKU_STATUS_OK"><code>TOKU_STATUS_OK</code></a>,
        <a href="#TOKU_STATUS_ESYNTAX"><code>TOKU_STATUS_ESYNTAX</code></a>, or
        <a href="#TOKU_STATUS_EMEM"><code>TOKU_STATUS_EMEM</code></a>.
        The function may also return other values corresponding to errors
        raised by the read function (see <a href="#4.4.1">&sect;4.4.1</a>).
        <br/><br/>
        If the resulting function has upvalues,
        its first upvalue is set to the value of the global environment
        stored at index <code>TOKU_CLIST_GLOBALS</code> in the C list
        (see <a href="#4.3">&sect;4.3</a>).
        When loading main chunks,
        this upvalue will be the <code>__ENV</code> variable
        (see <a href="#2.2">&sect;2.2</a>).
        Other upvalues are initialized with <b>nil</b>.
        </p>

        <!-- toku_dump -->
        <hr><h3><a name="toku_dump"><code>toku_dump</code></a></h3>
        <span class="apii">[-0, +0, &ndash;]</span>
        <pre>int toku_load (toku_State *T,
               toku_Writer writer,
               void *data,
               int strip);</pre>
        <p>
        Dumps a function as a binary chunk.
        Receives a Tokudae function on the top of the stack and produces
        a binary chunk that, if loaded again, results in a function
        equivalent to the one dumped.
        As it produces parts of the chunk,
        <a href="#toku_dump"><code>toku_dump</code></a> calls function
        <code>writer</code>
        (see <a href="#toku_Writer"><code>toku_Writer</code></a>)
        with the given <code>data</code> to write them.
        <br/><br/>
        The function <a href="#toku_dump"><code>toku_dump</code></a> fully
        preserves the Tokudae stack through the calls to the writer function,
        except that it may push some values for internal use
        before the first call, and it restores the stack size to its
        original size after the last call.
        <br/><br/>
        If <code>strip</code> is true, the binary representation may not
        include all debug information about the function, to save space.
        <br/><br/>
        The value returned is the error code returned by the last
        call to the writer; 0&nbsp;means no errors.
        </p>

        <!-- toku_gc -->
        <hr><h3><a name="toku_gc"><code>toku_gc</code></a></h3>
        <span class="apii">[-0, +0, &ndash;]</span>
        <pre>int toku_gc (toku_State *T, int what, ...);</pre>
        <p>
        Controls the garbage collector.
        <br/><br/>
        This function performs several tasks, according to the value of the
        parameter <code>what</code>.
        For options that need extra arguments, they are listed after the
        option.
        <ul>
            <li>
                <b><a name="TOKU_GC_STOP"><code>TOKU_GC_STOP</code></a>: </b>
                Stops the garbage collector.
            </li>
            <li>
                <b><a name="TOKU_GC_RESTART"><code>TOKU_GC_RESTART</code></a>: </b>
                Restarts the garbage collector.
            </li>
            <li>
                <b><a name="TOKU_GC_CHECK"><code>TOKU_GC_CHECK</code></a>: </b>
                Resets the check flag, setting it to 0 and returns the
                previous value of the check flag. Check flag is set to 1 if
                the collector has swept any object (unmarked reachable one or
                collected it) since the last time check was made.
            </li>
            <li>
                <b><a name="TOKU_GC_COLLECT"><code>TOKU_GC_COLLECT</code></a>: </b>
                Performs a full garbage-collection cycle.
            </li>
            <li>
                <b><a name="TOKU_GC_COUNT"><code>TOKU_GC_COUNT</code></a>: </b>
                Returns the current amount of memory (in Kbytes) in use by
                Tokudae.
            </li>
            <li>
                <b><a name="TOKU_GC_COUNTBYTES"><code>TOKU_GC_COUNTBYTES</code></a>: </b>
                Returns the remainder of dividing the current amount of bytes
                of memory in use by Tokudae by 1024.
            </li>
            <li>
                <b><a name="TOKU_GC_STEP"><code>TOKU_GC_STEP</code></a> (int stepsize): </b>
                Performs a step of garbage collection, corresponding to the
                allocation of <code>stepsize</code> Kbytes.
            </li>
            <li>
                <b><a name="TOKU_GC_PARAM"><code>TOKU_GC_PARAM</code></a> (int param, int value): </b>
                Changes and/or returns the value of a parameter of the
                collector. If <code>value</code> is -1, the call only returns
                the current value. The argument <code>param</code> must be
                on of the following values:
                <ul>
                    <li>
                        <b><a name="TOKU_GCP_PAUSE"><code>TOKU_GCP_PAUSE</code>: </a></b>
                        The garbage-collector pause.
                    </li>
                    <li>
                        <b><a name="TOKU_GCP_STEPMUL"><code>TOKU_GCP_STEPMUL</code>: </a></b>
                        The step multiplier.
                    </li>
                    <li>
                        <b><a name="TOKU_GCP_STEPSIZE"><code>TOKU_GCP_STEPSIZE</code>: </a></b>
                        The step size.
                    </li>
                </ul>
            </li>
            <li>
                <b><a name="TOKU_GC_ISRUNNING"><code>TOKU_GC_ISRUNNING</code></a>: </b>
                Returns a boolean that tells whether the collector is running
                (i.e., not stopped).
            </li>
        </ul>
        For more details about these options,
        see <a href="#gc"><code>gc</code></a>.
        <br/><br/>
        This function should not be called by a finalizer.
        </p>

        <!-- toku_setwarnf -->
        <hr><h3><a name="toku_setwarnf"><code>toku_setwarnf</code></a></h3>
        <span class="apii">[-0, +0, &ndash;]</span>
        <pre>void toku_setwarnf (toku_State *T, toku_WarnFunction fwarn, void *ud);</pre>
        <p>
        Sets the warning function to be used by Tokudae to emit warnings
        (see <a href="#toku_WarnFunction"><code>toku_WarnFunction</code></a>).
        The <code>ud</code> parameter sets the value <code>ud</code> passed to
        the warning function.
        </p>

        <!-- toku_warning -->
        <hr><h3><a name="toku_warning"><code>toku_warning</code></a></h3>
        <span class="apii">[-0, +0, &ndash;]</span>
        <pre>void toku_warning (toku_State *T, const char *msg, int cont);</pre>
        <p>
        Emits a warning with the given message.
        A message in a call with <code>tocont</code> true should be continued
        in another call to this function.
        <br/><br/>
        See <a href="#warn"><code>warn</code></a> for more details about warnings.
        </p>

        <!-- toku_numbertocstring -->
        <hr><h3><a name="toku_numbertocstring"><code>toku_numbertocstring</code></a></h3>
        <span class="apii">[-0, +0, &ndash;]</span>
        <pre>unsigned toku_numbertocstring (toku_State *T, int idx, char *buff);</pre>
        <p>
        Converts the number at acceptable index <code>idx</code> to a string
        and puts the result in <code>buff</code>.
        The buffer must have a size of at least
        <a name="TOKU_N2SBUFFSZ"><code>TOKU_N2SBUFFSZ</code></a> bytes.
        The conversion follows a non-specified format
        (see <a href="#3.4.3">&sect;3.4.3</a>).
        The function returns the number of bytes written to the buffer
        (including the final zero), or zero if the value at <code>idx</code>
        is not a number.
        </p>

        <!-- toku_stringtonumber -->
        <hr><h3><a name="toku_stringtonumber"><code>toku_stringtonumber</code></a></h3>
        <span class="apii">[-0, +1, &ndash;]</span>
        <pre>size_t toku_stringtonumber (toku_State *T, const char *s, int *f);</pre>
        <p>
        Converts the zero-terminated string <code>s</code> to a number,
        pushes that number into the stack,
        and returns the total size of the string,
        that is, its length plus one.
        The conversion can result in an integer or a float,
        according to the lexical conventions of Tokudae
        (see <a href="#3.1">&sect;3.1</a>), with the exception that
        separator '<code>_</code>' is not allowed.
        The string may have leading and trailing whitespaces and a sign.
        If the string is not a valid numeral,
        returns 0 and pushes nothing.
        (Note that the result can be used as a boolean,
        true if the conversion succeeds.)
        <br/><br/>
        Additionally the <code>f</code> parameter, if provided (not NULL),
        is set to a value less than 0 in case of underflow and a value
        greater than 0 in case of overflow (otherwise the value is set
        to 0).
        </p>

        <!-- toku_version -->
        <hr><h3><a name="toku_version"><code>toku_version</code></a></h3>
        <span class="apii">[-0, +0, &ndash;]</span>
        <pre>toku_Number toku_version (toku_State *T);</pre>
        <p>
        Returns the version number of this core.
        </p>

        <!-- toku_len -->
        <hr><h3><a name="toku_len"><code>toku_len</code></a></h3>
        <span class="apii">[-0, +0, &ndash;]</span>
        <pre>toku_Unsigned toku_len (toku_State *T, int idx);</pre>
        <p>
        Returns the "length" of the value at the given index.
        For strings, this is the string length;
        for lists, this is the list length;
        for tables and instances, this is the number of non <b>nil</b> fields;
        for classes, this is the number of methods;
        For other values, this call returns&nbsp;0.
        </p>

        <!-- toku_lenudata -->
        <hr><h3><a name="toku_lenudata"><code>toku_lenudata</code></a></h3>
        <span class="apii">[-0, +0, &ndash;]</span>
        <pre>size_t toku_len (toku_State *T, int idx);</pre>
        <p>
        Returns the size of the block of memory allocated for the userdata
        at the given index.
        </p>

        <!-- toku_nextfield -->
        <hr><h3><a name="toku_nextfield"><code>toku_nextfield</code></a></h3>
        <span class="apii">[-1, +(2|0), <em>v</em>]</span>
        <pre>int toku_nextfield (toku_State *T, int idx);</pre>
        <p>
        Pops a key from the stack,
        and pushes a key&ndash;value pair (a field) from the table or instance
        at the given index, the "next" pair after the given key.
        If there are no more elements in the table or instance,
        then <a href="#toku_nextfield"><code>toku_nextfield</code></a>
        returns&nbsp;0 and pushes nothing.
        <details class = "example">
            <summary>A typical table (or instance) traversal.</summary>
        <pre>
/* table is in the stack at index 't' */
toku_push_nil(T);  /* first key */
while (toku_nextfield(T, t) != 0) {
    /* uses 'key' (at index -2) and 'value' (at index -1) */
    printf("%s - %s\n",
           toku_typename(T, toku_type(T, -2)),
           toku_typename(T, toku_type(T, -1)));
    /* removes 'value'; keeps 'key' for next iteration */
    toku_pop(T, 1);
}</pre>
        </details>
        <br/>
        This function may raise an error if the given key is neither
        <b>nil</b> nor present in the table or instance.
        See function <a href="#nextfield"><code>nextfield</code></a> for the caveats of
        modifying the table or instance fields during its traversal.
        </p>

        <!-- toku_concat -->
        <hr><h3><a name="toku_concat"><code>toku_concat</code></a></h3>
        <span class="apii">[-n, +1, <em>e</em>]</span>
        <pre>void toku_concat (toku_State *T,  int n);</pre>
        <p>
        Concatenates the <code>n</code> values at the top of the stack,
        pops them, and leaves the result on the top.
        If <code>n</code>&nbsp;is&nbsp;1, the result is the single value on
        the stack (that is, the function does nothing);
        if <code>n</code> is 0, the result is the empty string.
        Concatenation is performed following the usual semantics of Tokudae
        (see <a href="#3.4.6">&sect;3.4.6</a>).
        </p>

        <!-- toku_toclose -->
        <hr><h3><a name="toku_toclose"><code>toku_toclose</code></a></h3>
        <span class="apii">[-0, +0, <em>v</em>]</span>
        <pre>void toku_toclose (toku_State *T, int idx);</pre>
        <p>
        Marks the given index in the stack as a to-be-closed slot
        (see <a href="#3.3.8">&sect;3.3.8</a>).
        Like a to-be-closed variable in Tokudae, the value at that slot in
        the stack will be closed when it goes out of scope.
        Here, in the context of a C function, to go out of scope means that
        the running function returns to Tokudae, or there is an error,
        or the slot is removed from the stack through
        <a href="#toku_setntop"><code>toku_setntop</code></a> or
        <a href="#toku_pop"><code>toku_pop</code></a>,
        or there is a call to
        <a href="#toku_closeslot"><code>toku_closeslot</code></a>.
        A slot marked as to-be-closed should not be removed from the stack
        by any other function in the API except
        <a href="#toku_setntop"><code>toku_setntop</code></a> or
        <a href="#toku_pop"><code>toku_pop</code></a>,
        unless previously deactivated by
        <a href="#toku_closeslot"><code>toku_closeslot</code></a>.
        <br/><br/>
        This function raises an error if the value at the given slot
        neither has a <code>__close</code> metamethod nor is a false value.
        <br/><br/>
        This function should not be called for an index that is equal to
        or below an active to-be-closed slot.
        <br/><br/>
        Note that, both in case of errors and of a regular return,
        by the time the <code>__close</code> metamethod runs,
        the C&nbsp;stack was already unwound, so that any automatic
        C&nbsp;variable declared in the calling function
        (e.g., a buffer) will be out of scope.
        </p>

        <!-- toku_closeslot -->
        <hr><h3><a name="toku_closeslot"><code>toku_closeslot</code></a></h3>
        <span class="apii">[-0, +0, <em>e</em>]</span>
        <pre>void toku_closeslot (toku_State *T, int idx);</pre>
        <p>
        Close the to-be-closed slot at the given index and set its value to
        <b>nil</b>.
        The index must be the last index previously marked to be closed
        (see <a href="#toku_toclose"><code>toku_toclose</code></a>) that is still
        active (that is, not closed yet).
        </p>

        <!-- toku_shrinklist -->
        <hr><h3><a name="toku_shrinklist"><code>toku_shrinklist</code></a></h3>
        <span class="apii">[-0, +0, &ndash;]</span>
        <pre>int toku_shrinklist (toku_State *T, int idx);</pre>
        <p>
        Shrinks the size of the list at the given index to the list length
        if the length is a power of two, or to the nearest power of two
        greater than the current length. This is a no-op if the list size is
        equal to the current length.
        <br/><br/>
        This returns 1 if list was shrunk, otherwise 0.
        </p>

        <!-- toku_numuservalues -->
        <hr><h3><a name="toku_numuservalues"><code>toku_numuservalues</code></a></h3>
        <span class="apii">[-0, +0, &ndash;]</span>
        <pre>unsigned short toku_numuservalues (toku_State *T, int idx);</pre>
        <p>
        Returns the total number of user values of the full userdata at the
        given index.
        </p>

        <!-- toku_push_cfunction -->
        <hr><h3><a name="toku_push_cfunction"><code>toku_push_cfunction</code></a></h3>
        <span class="apii">[-0, +1, &ndash;]</span>
        <pre>void toku_push_cfunction (toku_State *T, toku_CFunction f);</pre>
        <p>
        Pushes a C&nbsp;function onto the stack.
        This function is equivalent to
        <a href="#toku_push_cclosure"><code>toku_push_cclosure</code></a> with
        no upvalues.
        </p>

        <!-- toku_is_function -->
        <hr><h3><a name="toku_is_function"><code>toku_is_function</code></a></h3>
        <span class="apii">[-0, +0, &ndash;]</span>
        <pre>int toku_is_function (toku_State *T, int idx);</pre>
        <p>
        Returns 1 if the value at the given index is a function,
        and 0&nbsp;otherwise.
        </p>

        <!-- toku_is_boundmethod -->
        <hr><h3><a name="toku_is_boundmethod"><code>toku_is_boundmethod</code></a></h3>
        <span class="apii">[-0, +0, &ndash;]</span>
        <pre>int toku_is_boundmethod (toku_State *T, int idx);</pre>
        <p>
        Returns 1 if the value at the given index is a bound method,
        and 0&nbsp;otherwise.
        </p>

        <!-- toku_is_list -->
        <hr><h3><a name="toku_is_list"><code>toku_is_list</code></a></h3>
        <span class="apii">[-0, +0, &ndash;]</span>
        <pre>int toku_is_list (toku_State *T, int idx);</pre>
        <p>
        Returns 1 if the value at the given index is the list,
        and 0&nbsp;otherwise.
        </p>

        <!-- toku_is_table -->
        <hr><h3><a name="toku_is_table"><code>toku_is_table</code></a></h3>
        <span class="apii">[-0, +0, &ndash;]</span>
        <pre>int toku_is_table (toku_State *T, int idx);</pre>
        <p>
        Returns 1 if the value at the given index is a table,
        and 0&nbsp;otherwise.
        </p>

        <!-- toku_is_class -->
        <hr><h3><a name="toku_is_class"><code>toku_is_class</code></a></h3>
        <span class="apii">[-0, +0, &ndash;]</span>
        <pre>int toku_is_class (toku_State *T, int idx);</pre>
        <p>
        Returns 1 if the value at the given index is a class,
        and 0&nbsp;otherwise.
        </p>

        <!-- toku_is_instance -->
        <hr><h3><a name="toku_is_instance"><code>toku_is_instance</code></a></h3>
        <span class="apii">[-0, +0, &ndash;]</span>
        <pre>int toku_is_instance (toku_State *T, int idx);</pre>
        <p>
        Returns 1 if the value at the given index is an instance,
        and 0&nbsp;otherwise.
        </p>

        <!-- toku_is_lightuserdata -->
        <hr><h3><a name="toku_is_lightuserdata"><code>toku_is_lightuserdata</code></a></h3>
        <span class="apii">[-0, +0, &ndash;]</span>
        <pre>int toku_is_lightuserdata (toku_State *T, int idx);</pre>
        <p>
        Returns 1 if the value at the given index is a light userdata,
        and 0&nbsp;otherwise.
        </p>

        <!-- toku_is_fulluserdata -->
        <hr><h3><a name="toku_is_fulluserdata"><code>toku_is_fulluserdata</code></a></h3>
        <span class="apii">[-0, +0, &ndash;]</span>
        <pre>int toku_is_fulluserdata (toku_State *T, int idx);</pre>
        <p>
        Returns 1 if the value at the given index is a full userdata,
        and 0&nbsp;otherwise.
        </p>

        <!-- toku_is_nil -->
        <hr><h3><a name="toku_is_nil"><code>toku_is_nil</code></a></h3>
        <span class="apii">[-0, +0, &ndash;]</span>
        <pre>int toku_is_nil (toku_State *T, int idx);</pre>
        <p>
        Returns 1 if the value at the given index is <b>nil</b>,
        and 0&nbsp;otherwise.
        </p>

        <!-- toku_is_boolean -->
        <hr><h3><a name="toku_is_bool"><code>toku_is_bool</code></a></h3>
        <span class="apii">[-0, +0, &ndash;]</span>
        <pre>int toku_is_bool (toku_State *T, int idx);</pre>
        <p>
        Returns 1 if the value at the given index is a boolean,
        and 0&nbsp;otherwise.
        </p>

        <!-- toku_is_thread -->
        <hr><h3><a name="toku_is_thread"><code>toku_is_thread</code></a></h3>
        <span class="apii">[-0, +0, &ndash;]</span>
        <pre>int toku_is_thread (toku_State *T, int idx);</pre>
        <p>
        Returns 1 if the value at the given index is a thread,
        and 0&nbsp;otherwise.
        </p>

        <!-- toku_is_none -->
        <hr><h3><a name="toku_is_none"><code>toku_is_none</code></a></h3>
        <span class="apii">[-0, +0, &ndash;]</span>
        <pre>int toku_is_none (toku_State *T, int idx);</pre>
        <p>
        Returns 1 if the given index is not valid, and 0&nbsp;otherwise.
        </p>

        <!-- toku_is_noneornil -->
        <hr><h3><a name="toku_is_noneornil"><code>toku_is_noneornil</code></a></h3>
        <span class="apii">[-0, +0, &ndash;]</span>
        <pre>int toku_is_noneornil (toku_State *T, int idx);</pre>
        <p>
        Returns 1 if the given index is not valid or if the value at this
        index is <b>nil</b>, and 0&nbsp;otherwise.
        </p>

        <!-- toku_to_string -->
        <hr><h3><a name="toku_to_string"><code>toku_to_string</code></a></h3>
        <span class="apii">[-0, +0, &ndash;]</span>
        <pre>const char *toku_to_string (toku_State *T, int idx);</pre>
        <p>
        Equivalent to <a href="#toku_to_lstring"><code>toku_to_lstring</code></a>
        with <code>len</code> equal to <code>NULL</code>.
        </p>

        <!-- toku_to_number -->
        <hr><h3><a name="toku_to_number"><code>toku_to_number</code></a></h3>
        <span class="apii">[-0, +0, &ndash;]</span>
        <pre>toku_Number toku_to_number (toku_State *T, int idx);</pre>
        <p>
        Equivalent to <a href="#toku_to_numberx"><code>toku_to_numberx</code></a>
        with <code>isnum</code> equal to <code>NULL</code>.
        </p>

        <!-- toku_to_integer -->
        <hr><h3><a name="toku_to_integer"><code>toku_to_integer</code></a></h3>
        <span class="apii">[-0, +0, &ndash;]</span>
        <pre>toku_Integer toku_to_integer (toku_State *T, int index);</pre>
        <p>
        Equivalent to <a href="#toku_to_integerx"><code>toku_to_integerx</code></a>
        with <code>isnum</code> equal to <code>NULL</code>.
        </p>

        <!-- toku_push_mainthread -->
        <hr><h3><a name="toku_push_mainthread"><code>toku_push_mainthread</code></a></h3>
        <span class="apii">[-0, +1, &ndash;]</span>
        <pre>void toku_push_mainthread (toku_State *T);</pre>
        <p>
        Pushes the main thread of the state onto the stack.
        </p>

        <!-- toku_push_globaltable -->
        <hr><h3><a name="toku_push_globaltable"><code>toku_push_globaltable</code></a></h3>
        <span class="apii">[-0, +1, &ndash;]</span>
        <pre>void toku_push_globaltable (toku_State *T);</pre>
        <p>
        Pushes the global table onto the stack.

        <!-- toku_push_clist -->
        <hr><h3><a name="toku_push_clist"><code>toku_push_clist</code></a></h3>
        <span class="apii">[-0, +1, &ndash;]</span>
        <pre>void toku_push_clist (toku_State *T);</pre>
        <p>
        Pushes the C list onto the stack.
        </p>

        <!-- toku_push_ctable -->
        <hr><h3><a name="toku_push_ctable"><code>toku_push_ctable</code></a></h3>
        <span class="apii">[-0, +1, &ndash;]</span>
        <pre>void toku_push_ctable (toku_State *T);</pre>
        <p>
        Pushes the C table onto the stack.
        </p>

        <!-- toku_push_literal -->
        <hr><h3><a name="toku_push_literal"><code>toku_push_literal</code></a></h3>
        <span class="apii">[-0, +1, <em>m</em>]</span>
        <pre>const char *toku_push_literal (toku_State *T, const char *s);</pre>
        <p>
        This macro is equivalent to
        <a href="#toku_push_string"><code>toku_push_string</code></a>,
        but should be used only when <code>s</code> is a literal string.
        (Tokudae may optimize this case.)
        </p>

        <!-- toku_register -->
        <hr><h3><a name="toku_register"><code>toku_register</code></a></h3>
        <span class="apii">[-0, +0, <em>m</em>]</span>
        <pre>void toku_register (toku_State *T, const char *name, toku_CFunction f);</pre>
        <p>
        Sets the C&nbsp;function <code>f</code> as the new value of global
        <code>name</code>.
        <br/><br/>
        It is defined as a macro:

        <pre>
    (toku_push_cfunction(C, f), toku_set_global_str(C, name))</pre>
        </p>

        <!-- toku_insert -->
        <hr><h3><a name="toku_insert"><code>toku_insert</code></a></h3>
        <span class="apii">[-1, +1, &ndash;]</span>
        <pre>void toku_insert (toku_State *T, int index);</pre>
        <p>
        Moves the top element into the given valid index, shifting up the
        elements above this index to open space.
        This function cannot be called with a pseudo-index, because a
        pseudo-index is not an actual stack position.
        </p>

        <!-- toku_pop -->
        <hr><h3><a name="toku_pop"><code>toku_pop</code></a></h3>
        <span class="apii">[-n, +0, &ndash;]</span>
        <pre>void toku_pop (toku_State *T, int n);</pre>
        <p>
        Pops <code>n</code> elements from the stack.
        It is implemented as a macro over
        <a href="#toku_setntop"><code>toku_setntop</code></a>.
        </p>

        <!-- toku_remove -->
        <hr><h3><a name="toku_remove"><code>toku_remove</code></a></h3>
        <span class="apii">[-1, +0, &ndash;]</span>
        <pre>void toku_remove (toku_State *T, int index);</pre>
        <p>
        Removes the element at the given valid index, shifting down the
        elements above this index to fill the gap.
        This function cannot be called with a pseudo-index, because a
        pseudo-index is not an actual stack position.
        </p>

        <!-- toku_replace -->
        <hr><h3><a name="toku_replace"><code>toku_replace</code></a></h3>
        <span class="apii">[-1, +0, &ndash;]</span>
        <pre>void toku_replace (toku_State *T, int index);</pre>
        <p>
        Moves the top element into the given valid index without shifting any
        element (therefore replacing the value at that given index), and then
        pops the top element.
        </p>

        <!-- toku_getextraspace -->
        <hr><h3><a name="toku_getextraspace"><code>toku_getextraspace</code></a></h3>
        <span class="apii">[-0, +0, &ndash;]</span>
        <pre>void *toku_getextraspace (toku_State *T);</pre>
        <p>
        Returns a pointer to a raw memory area associated with the
        given Tokudae state.
        The application can use this area for any purpose;
        Tokudae does not use it for anything.
        <br/><br/>
        Each new thread has this area initialized with a copy of the area
        of the main thread.
        <br/><br/>
        By default, this area has the size of a pointer to void, but you can
        recompile Tokudae with a different size for this area.
        (See <a name="TOKU_EXTRASPACE"><code>TOKU_EXTRASPACE</code></a> in
        <code>tokudaeconf.h</code>.)
        </p>

        <!-- toku_getntop -->
        <hr><h3><a name="toku_getntop"><code>toku_getntop</code></a></h3>
        <span class="apii">[-0, +0, &ndash;]</span>
        <pre>int toku_getntop (toku_State *T);</pre>
        <p>
        Similar to <a href="#toku_gettop"><code>toku_gettop</code></a> except
        this returns the actual number of the values on the stack.
        So the return value of 0 means an empty stack.
        (This is equivalent to
        <a href="#toku_gettop"><code>toku_gettop</code></a><code>&nbsp;+&nbsp;1</code>.)
        </p>

        <!-- toku_getstack -->
        <hr><h3><a name="toku_getstack"><code>toku_getstack</code></a></h3>
        <span class="apii">[-0, +0, &ndash;]</span>
        <pre>int toku_getstack (toku_State *T, int level, toku_Debug *ar);</pre>
        <p>
        Gets information about the interpreter runtime stack.
        <br/><br/>
        This function fills parts of a
        <a href="#toku_Debug"><code>toku_Debug</code></a> structure with an
        identification of the <em>activation record</em> of the function
        executing at a given level.
        Level&nbsp;0 is the current running function, whereas level
        <em>n+1</em> is the function that has called level <em>n</em>.
        When called with a level greater than the stack depth,
        <a href="#toku_getstack"><code>toku_getstack</code></a> returns 0;
        otherwise it returns 1.
        </p>

        <!-- toku_getinfo -->
        <hr><h3><a name="toku_getinfo"><code>toku_getinfo</code></a></h3>
        <span class="apii">[-(0|1), +(0|1|2), <em>m</em>]</span>
        <pre>int toku_getinfo (toku_State *T, const char *what, toku_Debug *ar);</pre>
        <p>
        Gets information about a specific function or function invocation.
        <br/><br/>
        To get information about a function invocation, the parameter
        <code>ar</code> must be a valid activation record that was filled by
        a previous call to
        <a href="#toku_getstack"><code>toku_getstack</code></a> or
        given as argument to a hook
        (see <a href="#toku_Hook"><code>toku_Hook</code></a>).
        <br/><br/>
        To get information about a function, you push it onto the stack and
        start the <code>what</code> string with the character
        '<code>&gt;</code>'.
        (In that case, <code>toku_getinfo</code> pops the function from the top
        of the stack.)
        <br/>
        <details class = "example">
            <summary>
                Example code that figures out the line where the function
                <code>f</code> was defined.
            </summary>
        <pre>
toku_Debug ar;
toku_get_global_str(T, "f");  /* get global 'f' */
toku_getinfo(T, "&gt;s", &amp;ar);
printf("%d\n", ar.defline);</pre>
        </details>
        <br/>
        Each character in the string <code>what</code> selects some fields of
        the structure <code>ar</code> to be filled or a value to be pushed on
        the stack.
        (These characters are also documented in the declaration of the
        structure <a href="#toku_Debug"><code>toku_Debug</code></a>, between
        parentheses in the comments following each field.)
        <ul>
            <li>
                <b>'<code>f</code>': </b>
                pushes onto the stack the function that is running at the
                given level;
            </li>
            <li>
                <b>'<code>l</code>': </b>
                fills in the field <code>currline</code>;
            </li>
            <li>
                <b>'<code>n</code>': </b>
                fills in the fields <code>name</code> and
                <code>namewhat</code>;
            </li>
            <li>
                <b>'<code>r</code>': </b>
                fills in the fields <code>ftransfer</code> and
                <code>ntransfer</code>;
            </li>
            <li>
                <b>'<code>s</code>': </b>
                fills in the fields <code>source</code>,
                <code>shortsrc</code>, <code>defline</code>,
                <code>lastdefline</code> and <code>what</code>;
            </li>
            <li>
                <b>'<code>u</code>': </b>
                fills in the fields <code>nupvals</code>, <code>nparams</code>
                and <code>isvararg</code>;
            </li>
            <li>
                <b>'<code>L</code>': </b>
                pushes onto the stack a table whose indices are the lines of
                the function with some associated code, that is, the lines
                where you can put a break point.
                (Lines with no code include empty lines and comments.)
                If this option is given together with option '<code>f</code>',
                its table is pushed after the function.
                This is the only option that can raise a memory error.
            </li>
        </ul>
        This function returns 0 to signal an invalid option in
        <code>what</code>; even then the valid options are handled correctly.
        </p>

        <!-- toku_stackinuse -->
        <hr><h3><a name="toku_stackinuse"><code>toku_stackinuse</code></a></h3>
        <span class="apii">[-0, +0, &ndash;]</span>
        <pre>int toku_stackinuse (toku_State *T);</pre>
        <p>
        Returns the total number of stack slots that are in use by the entire
        call stack (all of the currently active functions).
        </p>

        <!-- toku_getlocal -->
        <hr><h3><a name="toku_getlocal"><code>toku_getlocal</code></a></h3>
        <span class="apii">[-0, +(0|1), &ndash;]</span>
        <pre>const char *toku_getlocal (toku_State *T, const toku_Debug *ar, int n);</pre>
        <p>
        Gets information about a local variable or a temporary value of a
        given activation record or a given function.
        <br/><br/>
        In the first case, the parameter <code>ar</code> must be a valid
        activation record that was filled by a previous call to
        <a href="#toku_getstack"><code>toku_getstack</code></a> or
        given as argument to a hook
        (see <a href="#toku_Hook"><code>toku_Hook</code></a>).
        The index <code>n</code> selects which local variable to inspect;
        see <a href="#debug.getlocal"><code>debug.getlocal</code></a> for
        details about variable indices and names.
        <br/><br/>
        <a href="#toku_getlocal"><code>toku_getlocal</code></a> pushes the
        variable's value onto the stack and returns its name.
        <br/><br/>
        In the second case, <code>ar</code> must be <code>NULL</code> and the
        function to be inspected must be on the top of the stack.
        In this case, only parameters of Tokudae functions are visible
        (as there is no information about what variables are active)
        and no values are pushed onto the stack.
        <br/><br/>
        Returns <code>NULL</code> (and pushes nothing) when the index is
        greater than the number of active local variables.
        </p>

        <!-- toku_setlocal -->
        <hr><h3><a name="toku_setlocal"><code>toku_setlocal</code></a></h3>
        <span class="apii">[-(0|1), +0, &ndash;]</span>
        <pre>const char *toku_setlocal (toku_State *T, const toku_Debug *ar, int n);</pre>
        <p>
        Sets the value of a local variable of a given activation record.
        It assigns the value on the top of the stack to the variable and
        returns its name.
        It also pops the value from the stack.
        <br/><br/>
        Returns <code>NULL</code> (and pops nothing) when the index is
        greater than the number of active local variables.
        <br/><br/>
        Parameters <code>ar</code> and <code>n</code> are as in the function
        <a href="#toku_getlocal"><code>toku_getlocal</code></a>.
        </p>

        <!-- toku_getupvalue -->
        <hr><h3><a name="toku_getupvalue"><code>toku_getupvalue</code></a></h3>
        <span class="apii">[-0, +(0|1), &ndash;]</span>
        <pre>const char *toku_getupvalue (toku_State *T, int idx, int n);</pre>
        <p>
        Gets information about the <code>n</code>-th upvalue
        (first upvalue located at <code>n</code>&nbsp;==&nbsp;0) of the
        closure at the given index.
        It pushes the upvalue's value onto the stack and returns its name.
        Returns <code>NULL</code> (and pushes nothing) when the index
        <code>n</code> is greater or equal to the number of upvalues.
        </p>

        <!-- toku_setupvalue -->
        <hr><h3><a name="toku_setupvalue"><code>toku_setupvalue</code></a></h3>
        <span class="apii">[-(0|1), +0, &ndash;]</span>
        <pre>const char *toku_setupvalue (toku_State *T, int idx, int n);</pre>
        <p>
        Sets the value of a closure's upvalue.
        It assigns the value on the top of the stack to the upvalue and
        returns its name.
        It also pops the value from the stack.
        <br/><br/>
        Returns <code>NULL</code> (and pops nothing) when the index
        <code>n</code> is greater or equal to the number of upvalues.
        <br/><br/>
        Parameters <code>idx</code> and <code>n</code> are as in
        the function <a href="#toku_getupvalue"><code>toku_getupvalue</code></a>.
        </p>

        <!-- toku_upvalueid -->
        <hr><h3><a name="toku_upvalueid"><code>toku_upvalueid</code></a></h3>
        <span class="apii">[-0, +0, &ndash;]</span>
        <pre>void *toku_upvalueid (toku_State *T, int idx, int n);</pre>
        <p>
        Returns a unique identifier for the upvalue numbered <code>n</code>
        from the closure at the given index.
        <br/><br/>
        These unique identifiers allow a program to check whether different
        closures share upvalues.
        Tokudae closures that share an upvalue
        (that is, that access a same external local variable)
        will return identical ids for those upvalue indices.
        <br/><br/>
        Parameters <code>idx</code> and <code>n</code> are as in
        the function <a href="#toku_getupvalue"><code>toku_getupvalue</code></a>,
        but <code>n</code> cannot be greater or equal to the number of upvalues.
        </p>

        <!-- toku_upvaluejoin -->
        <hr><h3><a name="toku_upvaluejoin"><code>toku_upvaluejoin</code></a></h3>
        <span class="apii">[-0, +0, &ndash;]</span>
        <pre>void toku_upvaluejoin (toku_State *T, int idx1, int n1,
                                      int idx2, int n2);</pre>
        <p>
        Make the <code>n1</code>-th upvalue of the Tokudae closure at index
        <code>idx1</code> refer to the <code>n2</code>-th upvalue of the
        Tokudae closure at index <code>idx2</code>.
        </p>

        <!-- toku_sethook -->
        <hr><h3><a name="toku_sethook"><code>toku_sethook</code></a></h3>
        <span class="apii">[-0, +0, &ndash;]</span>
        <pre>void toku_sethook (toku_State *T, toku_Hook f, int mask, int count);</pre>
        <p>
        Sets the debugging hook function.
        <br/><br/>
        Argument <code>f</code> is the hook function.
        <code>mask</code> specifies on which events the hook will be called:
        it is formed by a bitwise OR of the constants
        <a name="TOKU_MASK_CALL"><code>TOKU_MASK_CALL</code></a>,
        <a name="TOKU_MASK_RET"><code>TOKU_MASK_RET</code></a>,
        <a name="TOKU_MASK_LINE"><code>TOKU_MASK_LINE</code></a>,
        and <a name="TOKU_MASK_COUNT"><code>TOKU_MASK_COUNT</code></a>.
        The <code>count</code> argument is only meaningful when the mask
        includes <code>TOKU_MASK_COUNT</code>.
        For each event, the hook is called as explained below:
        <ul>
            <li><b>The call hook</b>:
                is called when the interpreter calls a function.
                The hook is called just after Tokudae enters the new function.
            </li>
            <li><b>The return hook</b>:
                is called when the interpreter returns from a function.
                The hook is called just before Tokudae leaves the function.
            </li>
            <li><b>The line hook</b>:
                is called when the interpreter is about to start the execution
                of a new line of code, or when it jumps back in the code
                (even to the same line).
                This event only happens while Tokudae is executing a Tokudae
                function.
            </li>
            <li><b>The count hook</b>:
                is called after the interpreter executes every
                <code>count</code> instructions.
                This event only happens while Tokudae is executing a Tokudae
                function.
            </li>
        </ul>
        Hooks are disabled by setting <code>mask</code> to zero.
        </p>

        <!-- toku_gethook -->
        <hr><h3><a name="toku_gethook"><code>toku_gethook</code></a></h3>
        <span class="apii">[-0, +0, &ndash;]</span>
        <pre>toku_Hook toku_gethook (toku_State *T, toku_Hook f, int mask, int count);</pre>
        <p>
        Returns the current hook function.
        </p>

        <!-- toku_gethookmask -->
        <hr><h3><a name="toku_gethookmask"><code>toku_gethookmask</code></a></h3>
        <span class="apii">[-0, +0, &ndash;]</span>
        <pre>int toku_gethookmask (toku_State *T, toku_Hook f, int mask, int count);</pre>
        <p>
        Returns the current hook mask.
        </p>

        <!-- toku_gethookcount -->
        <hr><h3><a name="toku_gethookcount"><code>toku_gethookcount</code></a></h3>
        <span class="apii">[-0, +0, &ndash;]</span>
        <pre>int toku_gethookcount (toku_State *T, toku_Hook f, int mask, int count);</pre>
        <p>
        Returns the current hook count.
        </p>




        <h1>5 &ndash; <a name="5">The Auxiliary Library</a></h1>
        <p>
        The <em>auxiliary library</em> provides several convenient functions
        to interface C with Tokudae.
        While the basic API provides the primitive functions for all
        interactions between C and Tokudae, the auxiliary library provides
        higher-level functions for some common tasks.
        <br/><br/>
        All functions and types from the auxiliary library are defined in
        header file <code>tokudaeaux.h</code> and have a prefix
        <code>tokuL_</code>.
        <br/><br/>
        All functions in the auxiliary library are built on top of the basic
        API, and so they provide nothing that cannot be done with that API.
        Nevertheless, the use of the auxiliary library ensures more
        consistency to your code.
        <br/><br/>
        Several functions in the auxiliary library use internally some
        extra stack slots.
        When a function in the auxiliary library uses less than five slots,
        it does not check the stack size; it simply assumes that there are
        enough slots.
        <br/><br/>
        Several functions in the auxiliary library are used to check
        C&nbsp;function arguments.
        Because the error message is formatted for arguments
        (e.g., "<code>bad argument #1</code>"), you should not use these
        functions for other stack values.
        <br/><br/>
        Functions called <code>tokuL_check_*</code> always raise an error if
        the check is not satisfied.
        </p>


        <h2>5.1 &ndash; <a name="5.1">Functions and Types</a></h2>
        <p>
        Here we list all functions and types from the auxiliary library:
        </p>

        <hr><h3><a name="tokuL_Entry"><code>tokuL_Entry</code></a></h3><p>
        <pre>
typedef struct tokuL_Entry {
    const char *name;
    toku_CFunction func;
} tokuL_Entry;</pre>
        <p>
        Type for arrays of functions to be registered by
        <a href="#tokuL_set_funcs"><code>tokuL_set_funcs</code></a>.
        <code>name</code> is the function name and <code>func</code> is a
        pointer to the function.
        Any array of <a href="#tokuL_Entry"><code>tokuL_Entry</code></a> must
        end with a sentinel entry in which both <code>name</code> and
        <code>func</code> are <code>NULL</code>.
        </p>

        <hr><h3><a name="tokuL_Buffer"><code>tokuL_Buffer</code></a></h3><p>
        <pre>typedef struct tokuL_Buffer tokuL_Buffer;</pre>
        <p>
        Type for a <em>string buffer</em>.
        <br/><br/>
        A string buffer allows C&nbsp;code to build Tokudae strings piecemeal.
        Its pattern of use is as follows:
        <ul>
            <li>
                First declare a variable <code>b</code> of type
                <a href="#tokuL_Buffer"><code>tokuL_Buffer</code></a>.
            </li>
            <li>
                Then initialize it with a call
                <code>tokuL_buff_init(C, &amp;b)</code>.
            </li>
            <li>
                Then add string pieces to the buffer calling any of
                the <code>tokuL_buff_push*</code> functions.
            </li>
            <li>
                Finish by calling <code>tokuL_buff_end(&amp;b)</code>.
                This call leaves the final string on the top of the stack.
            </li>
        </ul>
        If you know beforehand the maximum size of the resulting string,
        you can use the buffer like this:
        <ul>
            <li>
                First declare a variable <code>b</code> of type
                <a href="#tokuL_Buffer"><code>tokuL_Buffer</code></a>.
            </li>
            <li>
                Then initialize it and preallocate a space of size
                <code>sz</code> with a call
                <code>tokuL_buff_initsz(T, &amp;b, sz)</code>.
            </li>
            <li>
                Then produce the string into that space.
            </li>
            <li>
                Finish by calling <code>tokuL_buff_endsz(&amp;b, sz)</code>,
                where <code>sz</code> is the total size of the resulting
                string copied into that space (which may be less than or equal
                to the preallocated size).
            </li>
        </ul>
        During its normal operation, a string buffer uses a variable number
        of stack slots.
        So, while using a buffer, you cannot assume that you know where
        the top of the stack is.
        You can use the stack between successive calls to buffer operations
        as long as that use is balanced;
        that is, when you call a buffer operation, the stack is at the same
        level it was immediately after the previous buffer operation.
        (The only exception to this rule is
        <a href="#tokuL_buff_push_stack"><code>tokuL_buff_push_stack</code></a>.)
        After calling <a href="#tokuL_buff_end"><code>tokuL_buff_end</code></a>,
        the stack is back to its level when the buffer was initialized,
        plus the final string on its top.
        </p>

        <hr><h3><a name="tokuL_error"><code>tokuL_error</code></a></h3><p>
        <span class="apii">[-0, +0, <em>v</em>]</span>
        <pre>int tokuL_error (toku_State *T, const char *fmt, ...);</pre>
        <p>
        Raises an error.
        The error message format is given by <code>fmt</code> plus any extra
        arguments, following the same rules of
        <a href="#toku_push_fstring"><code>toku_push_fstring</code></a>.
        It also adds at the beginning of the message the file name and
        the line number where the error occurred, if this information is
        available.
        <br/><br/>
        This function never returns, but it is an idiom to use it in
        C&nbsp;functions as <code>return tokuL_error(<em>args</em>)</code>.
        </p>

        <hr><h3><a name="tokuL_error_arg"><code>tokuL_error_arg</code></a></h3><p>
        <span class="apii">[-0, +0, <em>v</em>]</span>
        <pre>int tokuL_error_arg (toku_State *T, int idx, const char *extra);</pre>
        <p>
        Raises an error reporting a problem with argument at given index,
        of the C&nbsp;function that called it, using a standard message
        that includes <code>extra</code> as a comment
        (<code>argnum == idx + 1</code>):

        <pre>
    bad argument #<em>argnum</em> to '<em>funcname</em>' (<em>extra</em>)</pre>

        This function never returns.
        </p>

        <hr><h3><a name="tokuL_error_type"><code>tokuL_error_type</code></a></h3><p>
        <span class="apii">[-0, +0, <em>v</em>]</span>
        <pre>int tokuL_error_type (toku_State *T, int idx, const char *tname);</pre>
        <p>
        Raises a type error for the argument at the given index of the
        C&nbsp;function that called it, using a standard message;
        <code>tname</code> is a "name" for the expected type.
        This function never returns.
        </p>

        <hr><h3><a name="tokuL_check_number"><code>tokuL_check_number</code></a></h3><p>
        <span class="apii">[-0, +0, <em>v</em>]</span>
        <pre>toku_Number tokuL_check_number (toku_State *T, int idx);</pre>
        <p>
        Checks whether the function argument at the given index is a number
        and returns this number converted to a <code>toku_Number</code>.
        </p>

        <hr><h3><a name="tokuL_check_integer"><code>tokuL_check_integer</code></a></h3><p>
        <span class="apii">[-0, +0, <em>v</em>]</span>
        <pre>toku_Integer tokuL_check_integer (toku_State *T, int idx);</pre>
        <p>
        Checks whether the function argument at the given index is an integer
        and returns this integer.
        </p>

        <hr><h3><a name="tokuL_check_lstring"><code>tokuL_check_lstring</code></a></h3><p>
        <span class="apii">[-0, +0, <em>v</em>]</span>
        <pre>const char *tokuL_check_lstring (toku_State *T, int idx, size_t *l);</pre>
        <p>
        Checks whether the function argument at the given index is a string
        and returns this string;
        if <code>l</code> is not <code>NULL</code> fills its referent
        with the string's length.
        <br/><br/>
        This function uses
        <a href="#toku_to_lstring"><code>toku_to_lstring</code></a> to get its
        result, so all conversions and caveats of that function apply here.
        </p>

        <hr><h3><a name="tokuL_check_type"><code>tokuL_check_type</code></a></h3><p>
        <span class="apii">[-0, +0, <em>v</em>]</span>
        <pre>void tokuL_check_type (toku_State *T, int idx, int t);</pre>
        <p>
        Checks whether the function argument at the given index has type
        <code>t</code>.
        See <a href="#toku_type"><code>toku_type</code></a> for the encoding of
        types for <code>t</code>.
        </p>

        <hr><h3><a name="tokuL_check_any"><code>tokuL_check_any</code></a></h3><p>
        <span class="apii">[-0, +0, <em>v</em>]</span>
        <pre>void tokuL_check_any (toku_State *T, int idx);</pre>
        <p>
        Checks whether the function has an argument of any type
        (including <b>nil</b>) at the given index.
        </p>

        <hr><h3><a name="tokuL_check_stack"><code>tokuL_check_stack</code></a></h3><p>
        <span class="apii">[-0, +0, <em>v</em>]</span>
        <pre>void tokuL_check_stack (toku_State *T, int sz, const char *msg);</pre>
        <p>
        Grows the stack size to <code>top + sz</code> elements,
        raising an error if the stack cannot grow to that size.
        <code>msg</code> is an additional text to go into the error message
        (or <code>NULL</code> for no additional text).
        </p>

        <hr><h3><a name="tokuL_check_version"><code>tokuL_check_version</code></a></h3><p>
        <span class="apii">[-0, +0, <em>v</em>]</span>
        <pre>void tokuL_check_version (toku_State *T);</pre>
        <p>
        Checks whether the code making the call and the Tokudae library being
        called are using the same version of Tokudae.
        </p>

        <hr><h3><a name="tokuL_check_userdata"><code>tokuL_check_userdata</code></a></h3><p>
        <span class="apii">[-0, +0, <em>v</em>]</span>
        <pre>void *tokuL_check_userdata (toku_State *T, int idx, const char *tname);</pre>
        <p>
        Checks whether the function argument at the given index is a userdata
        of the type <code>tname</code>
        (see <a href="#tokuL_new_metatable"><code>tokuL_new_metatable</code></a>)
        and returns the userdata's memory-block address
        (see <a href="#toku_to_userdata"><code>toku_to_userdata</code></a>).
        </p>

        <hr><h3><a name="tokuL_check_option"><code>tokuL_check_option</code></a></h3><p>
        <span class="apii">[-0, +0, <em>v</em>]</span>
        <pre>int tokuL_check_option (toku_State *T
                        int idx,
                        const char *dfl,
                        const char *const opts[]);</pre>
        <p>
        Checks whether the function argument at the given index is a string and
        searches for this string in the array <code>opts</code>
        (which must be NULL-terminated).
        Returns the index in the array where the string was found.
        Raises an error if the argument is not a string or if the string
        cannot be found.
        <br/><br/>
        If <code>dfl</code> is not <code>NULL</code>, the function uses
        <code>dfl</code> as a default value when there is no argument
        at the given index or when this argument is <b>nil</b>.
        <br/><br/>
        This is a useful function for mapping strings to C&nbsp;enums.
        (The usual convention in Tokudae libraries is to use strings instead
        of numbers to select options.)
        </p>

        <hr><h3><a name="tokuL_opt_number"><code>tokuL_opt_number</code></a></h3><p>
        <span class="apii">[-0, +0, <em>v</em>]</span>
        <pre>toku_Number tokuL_opt_number (toku_State *T, int idx, toku_Number dfl);</pre>
        <p>
        If the function argument at the given index is a number, returns this
        number as a <a href="#toku_Number"><code>toku_Number</code></a>.
        If this argument is absent or is <b>nil</b>, returns <code>dfl</code>.
        Otherwise, raises an error.
        </p>

        <hr><h3><a name="tokuL_opt_integer"><code>tokuL_opt_integer</code></a></h3><p>
        <span class="apii">[-0, +0, <em>v</em>]</span>
        <pre>toku_Integer tokuL_opt_integer (toku_State *T, int idx, toku_Integer dfl);</pre>
        <p>
        If the function argument at the given index is an integer, returns this
        integer.
        If this argument is absent or is <b>nil</b>, returns <code>dfl</code>.
        Otherwise, raises an error.
        </p>

        <hr><h3><a name="tokuL_opt_lstring"><code>tokuL_opt_lstring</code></a></h3><p>
        <span class="apii">[-0, +0, <em>v</em>]</span>
        <pre>const char *tokuL_opt_lstring (toku_State *T,
                               int idx,
                               const char *dfl,
                               size_t *l);</pre>
        <p>
        If the function argument at the given index is a string, returns this
        string.
        If this argument is absent or is <b>nil</b>, returns <code>dfl</code>.
        Otherwise, raises an error.
        <br/><br/>
        If <code>l</code> is not <code>NULL</code>, fills its referent with
        the result's length.
        If the result is <code>NULL</code> (only possible when returning
        <code>dfl</code> and <code>dfl == NULL</code>), its length is
        considered zero.
        <br/><br/>
        This function uses
        <a href="#toku_to_lstring"><code>toku_to_lstring</code></a> to get its
        result, so all conversions and caveats of that function apply here.
        </p>

        <hr><h3><a name="tokuL_loadfilex"><code>tokuL_loadfilex</code></a></h3><p>
        <span class="apii">[-0, +1, <em>m</em>]</span>
        <pre>int tokuL_loadfilex (toku_State *T, const char *filename,
                                    const char *mode);</pre>
        <p>
        Loads a file as a Tokudae chunk.
        This function uses <a href="#toku_load"><code>toku_load</code></a> to
        load the chunk in the file named <code>filename</code>.
        If <code>filename</code> is <code>NULL</code>, then it loads from
        the standard input.
        <br/><br/>
        The string <code>mode</code> works as in the function
        <a href="#toku_load"><code>toku_load</code></a>.
        <br/><br/>
        This function returns the same results as
        <a href="#toku_load"><code>toku_load</code></a> or
        <a href="#TOKU_STATUS_EFILE"><code>TOKU_STATUS_EFILE</code></a>
        for file-related errors.
        <br/><br/>
        As <a href="#toku_load"><code>toku_load</code></a>, this function only
        loads the chunk; it does not run it.
        </p>

        <hr><h3><a name="tokuL_loadstring"><code>tokuL_loadstring</code></a></h3><p>
        <span class="apii">[-0, +1, &ndash;]</span>
        <pre>int tokuL_loadstring (toku_State *T, const char *s);</pre>
        <p>
        Loads a string as a Tokudae chunk.
        This function uses <a href="#toku_load"><code>toku_load</code></a> to
        load the chunk in the zero-terminated string <code>s</code>.
        <br/><br/>
        This function returns the same results as
        <a href="#toku_load"><code>toku_load</code></a>.
        <br/><br/>
        Also as <a href="#toku_load"><code>toku_load</code></a>,
        this function only loads the chunk; it does not run it.
        </p>

        <hr><h3><a name="tokuL_loadbufferx"><code>tokuL_loadbufferx</code></a></h3><p>
        <span class="apii">[-0, +1, &ndash;]</span>
        <pre>int tokuL_loadbufferx (toku_State *T,
                       const char *buff,
                       size_t sz,
                       const char *name,
                       const char *mode);</pre>
        <p>
        Loads a buffer as a Tokudae chunk.
        This function uses <a href="#toku_load"><code>toku_load</code></a> to
        load the chunk in the buffer pointed to by <code>buff</code> with size
        <code>sz</code>.
        <br/><br/>
        This function returns the same results as
        <a href="#toku_load"><code>toku_load</code></a>.
        <code>name</code> is the chunk name, used for debug information and
        error messages.
        The string <code>mode</code> works as in the function
        <a href="#toku_load"><code>toku_load</code></a>.
        </p>

        <hr><h3><a name="tokuL_new_metatable"><code>tokuL_new_metatable</code></a></h3><p>
        <span class="apii">[-0, +1, <em>m</em>]</span>
        <pre>int tokuL_new_metatable (toku_State *T, const char *tname);</pre>
        <p>
        If the C table already has the key <code>tname</code>, returns 0.
        Otherwise, creates a new table to be used as a metatable for userdata,
        adds to this new table the pair <code>__name&nbsp;=&nbsp;tname</code>,
        adds to the C table the pair <code>[tname]&nbsp;=&nbsp;new&nbsp;table</code>,
        and returns 1.
        <br/><br/>
        In both cases, the function pushes onto the stack the final value
        associated with <code>tname</code> in the C table.
        </p>

        <hr><h3><a name="tokuL_set_metatable"><code>tokuL_set_metatable</code></a></h3><p>
        <span class="apii">[-0, +0, &ndash;]</span>
        <pre>void tokuL_set_metatable (toku_State *T, const char *tname);</pre>
        <p>
        Sets the metatable of the object on top of the stack as the metatable
        associated with name <code>tname</code> in the C table
        (see <a href="#tokuL_new_metatable"><code>tokuL_new_metatable</code></a>).
        </p>

        <hr><h3><a name="tokuL_get_metafield"><code>tokuL_get_metafield</code></a></h3><p>
        <span class="apii">[-0, +(0|1), <em>m</em>]</span>
        <pre>int tokuL_get_metafield (toku_State *T, int idx, const char *event);</pre>
        <p>
        Pushes onto the stack the field <code>event</code> from the metatable
        of the object at the given index and returns the type of the puhsed
        value, or if the metatable does not have this field, pushes nothing
        and returns <code>TOKU_T_NIL</code>.
        </p>

        <hr><h3><a name="tokuL_callmeta"><code>tokuL_callmeta</code></a></h3><p>
        <span class="apii">[-0, +(0|1), <em>e</em>]</span>
        <pre>int tokuL_callmeta (toku_State *T, int idx, const char *event);</pre>
        <p>
        Calls a metamethod.
        <br/><br/>
        If the object at the given index has a metatable and this metatable
        has a field <code>event</code>, this function calls this field passing
        the object as its only argument.
        In this case this function returns true and pushes onto the stack the
        value returned by the call.
        If there is no metatable or no metamethod, this function returns
        false without pushing any value on the stack.
        </p>

        <hr><h3><a name="tokuL_test_userdata"><code>tokuL_test_userdata</code></a></h3><p>
        <span class="apii">[-0, +0, <em>m</em>]</span>
        <pre>void *tokuL_test_userdata (toku_State *T, int idx, const char *tname);</pre>
        <p>
        This function works like
        <a href="#tokuL_check_userdata"><code>tokuL_check_userdata</code></a>,
        except that, when the test fails, it returns <code>NULL</code>
        instead of raising an error.
        </p>

        <hr><h3><a name="tokuL_fileresult"><code>tokuL_fileresult</code></a></h3><p>
        <span class="apii">[-0, +(1|3), <em>m</em>]</span>
        <pre>int tokuL_fileresult (toku_State *T, int stat, const char *fname);</pre>
        <p>
        This function produces the return values for file-related functions
        in the standard library
        (<a href="#io.open"><code>io.open</code></a>,
        <a href="#os.rename"><code>os.rename</code></a>,
        <a href="#file.seek"><code>file.seek</code></a>, etc.).
        <br/><br/>
        If <code>stat</code> is 0, then, <b>fail</b>, error message and error
        code are pushed on top of the stack (in that order).
        Otherwise <em>true</em> is pushed on top of the stack.
        <br/><br/>
        In both cases, this returns the number of values pushed.
        </p>

        <hr><h3><a name="tokuL_execresult"><code>tokuL_execresult</code></a></h3><p>
        <span class="apii">[-0, +3, <em>m</em>]</span>
        <pre>int tokuL_execresult (toku_State *T, int stat);</pre>
        <p>
        This function produces the return values for process-related
        function in the standard library
        (<a href="#os.execute"><code>os.execute</code></a> and
        <a href="#io.close"><code>io.close</code></a>).
        </p>

        <hr><h3><a name="tokuL_to_lstring"><code>tokuL_to_lstring</code></a></h3><p>
        <span class="apii">[-0, +1, <em>e</em>]</span>
        <pre>const char *tokuL_to_lstring (toku_State *T, int idx, size_t *len);</pre>
        <p>
        Converts any Tokudae value at the given index to a C&nbsp;string
        in a reasonable format.
        The resulting string is pushed onto the stack and also
        returned by the function (see <a href="#4.1.3">&sect;4.1.3</a>).
        If <code>len</code> is not <code>NULL</code>, the function also sets
        <code>*len</code> with the string length.
        <br/><br/>
        If the value has a metatable with a <code>__tostring</code> field,
        then <code>tokuL_to_lstring</code> calls the corresponding metamethod
        with the value as argument, and uses the result of the call as its
        result.
        </p>

        <hr><h3><a name="tokuL_to_fulluserdata"><code>tokuL_to_fulluserdata</code></a></h3><p>
        <span class="apii">[-0, +0, &ndash;]</span>
        <pre>void *tokuL_to_fulluserdata (toku_State *T, int index);</pre>
        <p>
        Returns pointer to the memory block of the full userdata value at the
        given index. If the value is not a full userdata this returns NULL.
        </p>

        <hr><h3><a name="tokuL_where"><code>tokuL_where</code></a></h3><p>
        <span class="apii">[-0, +1, <em>m</em>]</span>
        <pre>void tokuL_where (toku_State *T, int lvl);</pre>
        <p>
        Pushes onto the stack a string identifying the current position
        of the control at level <code>lvl</code> in the call stack.
        Typically this string has the following format:

        <pre>
    <em>chunkname</em>:<em>currentline</em>:</pre>

        Level&nbsp;0 is the running function, level&nbsp;1 is the function
        that called the running function, etc.
        <br/><br/>
        This function is used to build a prefix for error messages.
        </p>

        <hr><h3><a name="tokuL_newstate"><code>tokuL_newstate</code></a></h3><p>
        <span class="apii">[-0, +0, &ndash;]</span>
        <pre>toku_State *tokuL_newstate (void);</pre>
        <p>
        Creates a new Tokudae state.
        It calls <a href="#toku_newstate"><code>toku_newstate</code></a>
        with an allocator based on the ISO&nbsp;C allocation functions and
        then sets a warning function and a panic function
        (see <a href="#4.4">&sect;4.4</a>) that print messages to the
        standard error output.
        <br/><br/>
        Returns the new state, or <code>NULL</code> if there is a memory
        allocation error.
        </p>

        <hr><h3><a name="tokuL_get_subtable"><code>tokuL_get_subtable</code></a></h3><p>
        <span class="apii">[-0, +1, <em>m</em>]</span>
        <pre>int tokuL_get_subtable (toku_State *T, int idx, const char *field);</pre>
        <p>
        Ensures that the value <code>obj[field]</code>, where <code>obj</code>
        is the value at the given index, is a table, and pushes that table
        onto the stack. This function performs raw access/store using the
        functions
        <a href="#toku_get_field_str"><code>toku_get_field_str</code></a> and
        <a href="#toku_set_field_str"><code>toku_set_field_str</code></a>.
        Despite the function name, the value being indexed can also be an
        instance.
        Returns true if it finds a previous table there and false if it
        creates a new table.
        </p>

        <hr><h3><a name="tokuL_importf"><code>tokuL_importf</code></a></h3><p>
        <span class="apii">[-0, +1, <em>e</em>]</span>
        <pre>void tokuL_importf (toku_State *T, const char *modname,
                    toku_CFunction openf, int global);</pre>
        <p>
        If <code>package.loaded[modname]</code> is not true,
        calls the function <code>openf</code> with the string
        <code>modname</code> as an argument and sets the call result to
        <code>package.loaded[modname]</code>, as if that function has been
        called through <a href="#import"><code>import</code></a>.
        <br/><br/>
        If <code>global</code> is true, also stores the module into the
        global <code>modname</code>.
        <br/><br/>
        Leaves a copy of the module on the stack.
        </p>

        <hr><h3><a name="tokuL_traceback"><code>tokuL_traceback</code></a></h3><p>
        <span class="apii">[-0, +1, <em>m</em>]</span>
        <pre>void tokuL_traceback (toku_State *T, toku_State *T1,
                      int lvl, const char *msg);</pre>
        <p>
        Creates and pushes a traceback of the stack <code>T1</code>.
        If <code>msg</code> is not <code>NULL</code>, it is appended
        at the beginning of the traceback.
        The <code>lvl</code> parameter tells at which level to start the
        traceback.
        </p>

        <hr><h3><a name="tokuL_gsub"><code>tokuL_gsub</code></a></h3><p>
        <span class="apii">[-0, +1, <em>m</em>]</span>
        <pre>void tokuL_gsub (toku_State *T,
                 const char *s,
                 const char *p,
                 const char *r);</pre>
        <p>
        Creates a copy of string <code>s</code>, replacing any occurrence of
        the string <code>p</code> with the string <code>r</code>.
        Pushes the resulting string on the stack and returns it.
        </p>

        <hr><h3><a name="tokuL_makeseed"><code>tokuL_makeseed</code></a></h3><p>
        <span class="apii">[-0, +0, &ndash;]</span>
        <pre>unsigned tokuL_makeseed (toku_State *T);</pre>
        <p>
        Returns a value with a weak attempt for randomness.
        (It produces that value based on the current date and time and the
        address of an internal variable, in case the machine has Address
        Space Layout Randomization.)
        </p>

        <hr><h3><a name="tokuL_set_funcs"><code>tokuL_set_funcs</code></a></h3><p>
        <span class="apii">[-nup, +0, <em>m</em>]</span>
        <pre>void tokuL_set_funcs (toku_State *T, const tokuL_Entry *l, int nup);</pre>
        <p>
        Registers all functions in the array <code>l</code>
        (see <a href="#tokuL_Entry"><code>tokuL_Entry</code></a>) into the
        table or instance on the top of the stack
        (below optional upvalues, see next).
        <br/><br/>
        When <code>nup</code> is not zero, all functions are created with
        <code>nup</code> upvalues, initialized with copies of the
        <code>nup</code> values previously pushed on the stack on top of
        the table or instance.
        These values are popped from the stack after the registration.
        <br/><br/>
        A function with a <code>NULL</code> value represents a placeholder,
        which is filled with <b>false</b>.
        </p>

        <hr><h3><a name="tokuL_ref"><code>tokuL_ref</code></a></h3><p>
        <span class="apii">[-1, +0, <em>m</em>]</span>
        <pre>void tokuL_ref (toku_State *T, int l);</pre>
        <p>
        Creates and returns a <em>reference</em>, in the list at index
        <code>l</code>, for the object on the top of the stack
        (and pops the object).
        <br/><br/>
        A reference is a unique integer index into that list.
        As long as you do not manually add entries into the list
        <code>l</code>,
        <a href="#tokuL_ref"><code>tokuL_ref</code></a> ensures
        the uniqueness of the index it returns.
        You can retrieve an object referred by the reference <code>r</code>
        by calling <code>toku_get_index(T, l, r)</code>.
        The function <a href="#tokuL_unref"><code>tokuL_unref</code></a> frees
        a reference.
        <br/><br/>
        If the object on the top of the stack is <b>nil</b>,
        <a href="#tokuL_ref"><code>tokuL_ref</code></a> returns the constant
        <a name="TOKU_REFNIL"><code>TOKU_REFNIL</code></a>.
        The constant <a name="TOKU_NOREF"><code>TOKU_NOREF</code></a> is
        guaranteed to be different from any reference returned by
        <a href="#tokuL_ref"><code>tokuL_ref</code></a>.
        </p>

        <hr><h3><a name="tokuL_unref"><code>tokuL_unref</code></a></h3><p>
        <span class="apii">[-0, +0, &ndash;]</span>
        <pre>void tokuL_unref (toku_State *T, int l, int ref);</pre>
        <p>
        Releases the reference <code>ref</code> from the list at index
        <code>l</code> (see <a href="#tokuL_ref"><code>tokuL_ref</code></a>).
        The entry is removed from the list, so that the referred object
        can be collected.
        The reference <code>ref</code> is also freed to be used again.
        <br/><br/>
        If <code>ref</code> is <a href="#TOKU_NOREF"><code>TOKU_NOREF</code></a>
        or <a href="#TOKU_REFNIL"><code>TOKU_REFNIL</code></a>,
        <a href="#tokuL_unref"><code>tokuL_unref</code></a> does nothing.
        </p>

        <hr><h3><a name="tokuL_check_string"><code>tokuL_check_string</code></a></h3><p>
        <span class="apii">[-0, +0, <em>v</em>]</span>
        <pre>const char *tokuL_check_string (toku_State *T, int idx);</pre>
        <p>
        Checks whether the function argument at the given index is a string
        and returns this string.
        <br/><br/>
        This function uses
        <a href="#toku_to_lstring"><code>toku_to_lstring</code></a>
        to get its result, so all conversions and caveats of that function
        apply here.
        </p>

        <hr><h3><a name="tokuL_check_arg"><code>tokuL_check_arg</code></a></h3><p>
        <span class="apii">[-0, +0, <em>v</em>]</span>
        <pre>void tokuL_check_arg (toku_State *T,
                      int cond,
                      int idx,
                      const char *extramsg);</pre>
        <p>
        Checks whether <code>cond</code> is true.
        If it is not, raises an error with a standard message
        (see <a href="#tokuL_error_arg"><code>tokuL_error_arg</code></a>).
        </p>

        <hr><h3><a name="tokuL_opt_string"><code>tokuL_opt_string</code></a></h3><p>
        <span class="apii">[-0, +0, <em>v</em>]</span>
        <pre>void tokuL_opt_string (toku_State *T, int idx, const char *dflt);</pre>
        <p>
        If the function argument <code>idx</code> is a string, returns
        this string.
        If this argument is absent or is <b>nil</b>, returns <code>dflt</code>.
        Otherwise, raises an error.
        </p>

        <hr><h3><a name="tokuL_opt"><code>tokuL_opt</code></a></h3><p>
        <span class="apii">[-0, +0, &ndash;]</span>
        <pre>T tokuL_opt (T, func, idx, dflt);</pre>
        <p>
        <details class = "example">
            <summary>This is defined as macro.</summary>
                <pre>
(toku_is_noneornil(T, index) ? (dfl) : fn(T, idx))</pre>
        </details>
        <br/>
        In words, if the argument <code>idx</code> is <b>nil</b> or absent,
        the macro results in the default <code>dflt</code>.
        Otherwise, it results in the result of calling <code>func</code>
        with the state <code>T</code> and the argument index <code>idx</code>
        as arguments.
        Note that it evaluates the expression <code>dflt</code> only if needed.
        </p>

        <hr><h3><a name="tokuL_expect_arg"><code>tokuL_expect_arg</code></a></h3><p>
        <span class="apii">[-0, +0, <em>v</em>]</span>
        <pre>void tokuL_expect_arg (toku_State *T
                       int cond,
                       int idx,
                       const char *tname);</pre>
        <p>
        Checks whether <code>cond</code> is true.
        If it is not, raises an error about the type of the argument
        at <code>idx</code> with a standard message
        (see <a href="#tokuL_error_type"><code>tokuL_error_type</code></a>).
        </p>

        <hr><h3><a name="tokuL_typename"><code>tokuL_typename</code></a></h3><p>
        <span class="apii">[-0, +0, &ndash;]</span>
        <pre>const char *tokuL_typename (toku_State *T, int idx);</pre>
        <p>
        Returns the name of the type of the value at the given index.
        </p>

        <hr><h3><a name="tokuL_push_fail"><code>tokuL_push_fail</code></a></h3><p>
        <span class="apii">[-0, +1, &ndash;]</span>
        <pre>void tokuL_push_fail (toku_State *T);</pre>
        <p>
        Pushes the <b>fail</b> value onto the stack
        (see <a href="#6">&sect;6</a>).
        </p>

        <hr><h3><a name="tokuL_push_libtable"><code>tokuL_push_libtable</code></a></h3><p>
        <span class="apii">[-0, +1, <em>m</em>]</span>
        <pre>void tokuL_push_libtable (toku_State *T, const tokuL_Entry l[]);</pre>
        <p>
        Creates a new table with a size optimized to store all entries in
        the array <code>l</code> (but does not actually store them).
        It is intended to be used in conjunction with
        <a href="#tokuL_set_funcs"><code>tokuL_set_funcs</code></a>
        (see <a href="#tokuL_push_lib"><code>tokuL_push_lib</code></a>).
        <br/><br/>
        It is implemented as a macro.
        The array <code>l</code> must be the actual array, not a pointer to it.
        </p>

        <hr><h3><a name="tokuL_push_lib"><code>tokuL_push_lib</code></a></h3><p>
        <span class="apii">[-0, +1, <em>m</em>]</span>
        <pre>void tokuL_push_lib (toku_State *T, const tokuL_Entry l[]);</pre>
        <p>
        Creates a new table and registers there the functions in the
        list <code>l</code>.
        <details class = "example">
            <summary>This is implemented as a macro.</summary>
            <pre>
(tokuL_check_version(T), tokuL_push_libtable(T,l), tokuL_set_funcs(T,l,0))</pre>
        </details>
        <br/>
        The array <code>l</code> must be the actual array, not a pointer to it.
        </p>

        <hr><h3><a name="tokuL_get_metatable"><code>tokuL_get_metatable</code></a></h3><p>
        <span class="apii">[-0, +1, <em>m</em>]</span>
        <pre>int tokuL_get_metatable (toku_State *T, const char *tname);</pre>
        <p>
        Pushes onto the stack the metatable aassociated with the name
        <code>tname</code> in the C table
        (see <a href="#tokuL_new_metatable"><code>tokuL_new_metatable</code></a>),
        or <b>nil</b> if there is no metatable associated with that name.
        Returns the type of the pushed value.
        </p>

        <hr><h3><a name="tokuL_loadfile"><code>tokuL_loadfile</code></a></h3><p>
        <span class="apii">[-0, +1, <em>m</em>]</span>
        <pre>int tokuL_loadfile (toku_State *T, const char *filename);</pre>
        <p>
        Equivalent to
        <a href="#tokuL_loadfilex"><code>tokuL_loadfilex</code></a>
        with <code>mode</code> equal to <code>NULL</code>.
        </p>

        <hr><h3><a name="tokuL_loadbuffer"><code>tokuL_loadbuffer</code></a></h3><p>
        <span class="apii">[-0, +1, <em>m</em>]</span>
        <pre>int tokuL_loadbuffer (toku_State *T,
                      const char *buff,
                      size_t sz,
                      const char *name);</pre>
        <p>
        Equivalent to
        <a href="#tokuL_loadbufferx"><code>tokuL_loadbufferx</code></a>
        with <code>mode</code> equal to <code>NULL</code>.
        </p>

        <hr><h3><a name="tokuL_intop"><code>tokuL_intop</code></a></h3><p>
        <span class="apii">[-0, +0, &ndash;]</span>
        <pre>toku_Integer tokuL_intop (op, x, y);</pre>
        <p>
        Perform arithmetic operation <code>op</code> on
        <a href="#toku_Integer"><code>toku_Integer</code></a> values
        <code>x</code> and <code>y</code> with wrap-around semantics,
        as the Tokudae core does.
        <details class = "example">
            <summary>This is implemented as a macro.</summary>
            <pre>
((toku_Integer)((toku_Unsigned)(x) op (toku_Unsigned)(y)))</pre>
        </details>
        </p>

        <hr><h3><a name="tokuL_buffptr"><code>tokuL_buffptr</code></a></h3><p>
        <span class="apii">[-0, +0, &ndash;]</span>
        <pre>char *tokuL_buffptr (tokuL_Buffer *B);</pre>
        <p>
        Returns the address of the current content of buffer <code>B</code>
        (see <a href="#tokuL_Buffer"><code>tokuL_Buffer</code></a>).
        Note that any addition to the buffer may invalidate this address.
        </p>

        <hr><h3><a name="tokuL_bufflen"><code>tokuL_bufflen</code></a></h3><p>
        <span class="apii">[-0, +0, &ndash;]</span>
        <pre>size_t tokuL_bufflen (tokuL_Buffer *B);</pre>
        <p>
        Returns the length of the current content of buffer <code>B</code>
        (see <a href="#tokuL_Buffer"><code>tokuL_Buffer</code></a>).
        </p>

        <hr><h3><a name="tokuL_buffadd"><code>tokuL_buffadd</code></a></h3><p>
        <span class="apii">[-?, +?, &ndash;]</span>
        <pre>void tokuL_buffadd (tokuL_Buffer *B, size_t n);</pre>
        <p>
        Adds to the buffer <code>B</code> a string of length <code>n</code>
        previously copied to the buffer area
        (see <a href="#tokuL_buff_initsz"><code>tokuL_buff_initsz</code></a>).
        </p>

        <hr><h3><a name="tokuL_buffsub"><code>tokuL_buffsub</code></a></h3><p>
        <span class="apii">[-?, +?, &ndash;]</span>
        <pre>void tokuL_buffsub (tokuL_Buffer *B, int n);</pre>
        <p>
        Removes <code>n</code> bytes from the buffer <code>B</code>
        (see <a href="#tokuL_Buffer"><code>tokuL_Buffer</code></a>).
        The buffer must have at least that many bytes.
        </p>

        <hr><h3><a name="tokuL_buff_push"><code>tokuL_buff_push</code></a></h3><p>
        <span class="apii">[-?, +?, <em>m</em>]</span>
        <pre>void tokuL_buff_push (tokuL_Buffer *B, char c);</pre>
        <p>
        Adds the byte <code>c</code> to the buffer <code>B</code>
        (see <a href="#tokuL_Buffer"><code>tokuL_Buffer</code></a>).
        </p>

        <hr><h3><a name="tokuL_buff_init"><code>tokuL_buff_init</code></a></h3><p>
        <span class="apii">[-0, +?, &ndash;]</span>
        <pre>void tokuL_buff_init (toku_State *T, tokuL_Buffer *B);</pre>
        <p>
        Initializes a buffer <code>B</code>
        (see <a href="#tokuL_Buffer"><code>tokuL_Buffer</code></a>).
        This function does not allocate any space;
        the buffer must be declared as a variable.
        </p>

        <hr><h3><a name="tokuL_buff_initsz"><code>tokuL_buff_initsz</code></a></h3><p>
        <span class="apii">[-?, +?, <em>m</em>]</span>
        <pre>char *tokuL_buff_initsz (toku_State *T, tokuL_Buffer *B, size_t sz);</pre>
        <p>
        Equivalent to the sequence
        <a href="#tokuL_buff_init"><code>tokuL_buff_init</code></a>,
        <a href="#tokuL_buff_ensure"><code>tokuL_buff_ensure</code></a>.
        </p>

        <hr><h3><a name="tokuL_buff_ensure"><code>tokuL_buff_ensure</code></a></h3><p>
        <span class="apii">[-?, +?, <em>m</em>]</span>
        <pre>char *tokuL_buff_ensure (tokuL_Buffer *B, size_t sz);</pre>
        <p>
        Returns an address to a space of size <code>sz</code>
        where you can copy a string to be added to buffer <code>B</code>
        (see <a href="#tokuL_Buffer"><code>tokuL_Buffer</code></a>).
        After copying the string into this space you must call
        <a href="#tokuL_buffadd"><code>tokuL_buffadd</code></a> with the size
        of the string to actually add it to the buffer.
        </p>

        <hr><h3><a name="tokuL_buff_push_lstring"><code>tokuL_buff_push_lstring</code></a></h3><p>
        <span class="apii">[-?, +?, <em>m</em>]</span>
        <pre>void tokuL_buff_push_lstring (tokuL_Buffer *B, const char *s, size_t l);</pre>
        <p>
        Adds the string pointed to by <code>s</code> with length
        <code>l</code> to the buffer <code>B</code>
        (see <a href="#tokuL_Buffer"><code>tokuL_Buffer</code></a>).
        The string can contain embedded zeros.
        </p>

        <hr><h3><a name="tokuL_buff_push_string"><code>tokuL_buff_push_string</code></a></h3><p>
        <span class="apii">[-?, +?, <em>m</em>]</span>
        <pre>void tokuL_buff_push_string (tokuL_Buffer *B, const char *s);</pre>
        <p>
        Adds the zero-terminated string pointed to by <code>s</code>
        to the buffer <code>B</code>
        (see <a href="#tokuL_Buffer"><code>tokuL_Buffer</code></a>).
        </p>

        <hr><h3><a name="tokuL_buff_push_stack"><code>tokuL_buff_push_stack</code></a></h3><p>
        <span class="apii">[-?, +?, <em>m</em>]</span>
        <pre>void tokuL_buff_push_stack (tokuL_Buffer *B);</pre>
        <p>
        Adds the value on the top of the stack to the buffer <code>B</code>
        (see <a href="#tokuL_Buffer"><code>tokuL_Buffer</code></a>).
        Pops the value.
        <br/><br/>
        This is the only function on string buffers that can (and must)
        be called with an extra element on the stack, which is the value
        to be added to the buffer.
        </p>

        <hr><h3><a name="tokuL_buff_push_gsub"><code>tokuL_buff_push_gsub</code></a></h3><p>
        <span class="apii">[-?, +?, <em>m</em>]</span>
        <pre>void tokuL_buff_push_gsub (tokuL_Buffer *B, const char *s,
                           const char *p, const char *r);</pre>
        <p>
        Adds a copy of the string <code>s</code> to the buffer <code>B</code>
        (see <a href="#tokuL_Buffer"><code>tokuL_Buffer</code></a>),
        replacing any occurrence of the string <code>p</code> with the
        string <code>r</code>.
        </p>

        <hr><h3><a name="tokuL_buff_end"><code>tokuL_buff_end</code></a></h3><p>
        <span class="apii">[-?, +1, <em>m</em>]</span>
        <pre>void tokuL_buff_end (tokuL_Buffer *B);</pre>
        <p>
        Finishes the use of buffer <code>B</code> leaving the final string
        on the top of the stack.
        </p>

        <hr><h3><a name="tokuL_buff_endsz"><code>tokuL_buff_endsz</code></a></h3><p>
        <span class="apii">[-?, +1, <em>m</em>]</span>
        <pre>void tokuL_buff_endsz (tokuL_Buffer *B, size_t sz);</pre>
        <p>
        Equivalent to the sequence
        <a href="#tokuL_buffadd"><code>tokuL_buffadd</code></a>,
        <a href="#tokuL_buff_end"><code>tokuL_buff_end</code></a>.
        </p>

        <hr><h3><a name="tokuL_buff_prep"><code>tokuL_buff_prep</code></a></h3><p>
        <span class="apii">[-?, +?, <em>m</em>]</span>
        <pre>void tokuL_buff_prep (tokuL_Buffer *B);</pre>
        <p>
        Equivalent to
        <a href="#tokuL_buff_ensure"><code>tokuL_buff_ensure</code></a>
        with the predefined size
        <a name="TOKUL_BUFFERSIZE"><code>TOKUL_BUFFERSIZE</code></a>.
        </p>

        <hr><h3><a name="tokuL_Stream"><code>tokuL_Stream</code></a></h3><p>
        <pre>
typedef struct tokuL_Stream {
    FILE *f;
    toku_CFunction closef;
} tokuL_Stream;</pre>
        <p>
        The standard representation for file handles used by the standard
        I/O library.
        <br/><br/>
        A file handle is implemented as a full userdata,
        with a metatable called
        <a name="TOKU_FILEHANDLE"><code>TOKU_FILEHANDLE</code></a>
        (where <code>TOKU_FILEHANDLE</code> is a macro with the actual
        metatable's name, see <code>tokudaeaux.h</code>).
        The metatable is created by the I/O library
        (see <a href="#tokuL_new_metatable"><code>tokuL_new_metatable</code></a>).
        <br/><br/>
        This userdata must start with the structure <code>tokuL_Stream</code>;
        it can contain other data after this initial structure.
        The field <code>f</code> points to the corresponding C stream,
        or it can be <code>NULL</code> to indicate an incompletely created handle.
        The field <code>closef</code> points to a Tokudae function that will
        be called to close the stream when the handle is closed or collected;
        this function receives the file handle as its sole argument and
        must return either a true value, in case of success,
        or a false value plus an error message, in case of error.
        Once Tokudae calls this field, it changes the field value to
        <code>NULL</code> to signal that the handle is closed.
        </p>




        <hr><h1>6 &ndash; <a name="6">The Standard Libraries</a></h1>
        <p>
        The standard Tokudae libraries provide useful functions that are
        implemented in&nbsp;C through the C&nbsp;API.
        Some of these functions provide essential services to the language
        (e.g, <a href="#typeof"><code>typeof</code></a> and
        <a href="#getmetatable"><code>getmetatable</code></a>);
        others provide access to outside services (e.g., I/O);
        and some could be implemented in Tokudae itself,
        but that for different reasons deserve an implementation in C
        (e.g., <a href="#list.sort"><code>list.sort</code></a>).
        <br/><br/>
        All libraries are implemented through the official C&nbsp;API and are
        provided as separate C&nbsp;modules.
        Unless otherwise noted, these library functions do not adjust its
        number of arguments to its expected parameters.
        For instance, a function documented as <code>foo(arg)</code>
        should not be called without an argument.
        <br/><br/>
        The notation <b>fail</b> means a false value representing some kind of
        failure (the recommendation is to always test the success of these
        functions with
        <code>(!status)</code>, instead of <code>(status == nil)</code>).
        <br/><br/>
        Currently, Tokudae has the following standard libraries:
        <ul>
            <li>basic library (<a href="#6.2">&sect;6.2</a>);</li>
            <li>package library(<a href="#6.3">&sect;6.3</a>);</li>
            <li>string library (<a href="#6.4">&sect;6.4</a>);</li>
            <li>math library (<a href="#6.5">&sect;6.5</a>);</li>
            <li>input and output library (<a href="#6.6">&sect;6.6</a>);</li>
            <li>operating system library (<a href="#6.7">&sect;6.7</a>);</li>
            <li>regular expression library (<a href="#6.8">&sect;6.8</a>);</li>
            <li>UTF-8 library (<a href="#6.9">&sect;6.9</a>);</li>
            <li>list library <a href="#6.10">&sect;6.10</a>);</li>
            <li>debug library <a href="#6.11">&sect;6.11</a>);</li>
        </ul>
        Except for the basic and the package libraries,
        each library provides all its functions as fields of a global table.
        </p>


        <h2>6.1 &ndash; <a name="6.1">Loading the Libraries in C code</a></h2>
        <p>
        A C&nbsp;host program must explicitly load the standard libraries into
        a state, if it wants its scripts to use them.
        For that, the host program can call the function
        <a href="#tokuL_openlibs"><code>tokuL_openlibs</code></a>.
        Alternatively, the host can select which libraries to open,
        by using <a href="#tokuL_openlibsx"><code>tokuL_openlibsx</code></a>.
        Both functions are defined in the header file <code>tokudaelib.h</code>.
        <br/><br/>
        The stand-alone interpreter <code>tokudae</code>
        (see <a href="#7">&sect;7</a>) already opens all standard libraries.
        </p>

        <hr><h3><a name="tokuL_openlibs"><code>tokuL_openlibs</code></a></h3><p>
        <span class="apii">[-0, +0, <em>e</em>]</span>
        <pre>void tokuL_openlibs (toku_State *T);</pre>
        <p>
        Opens all standard Tokudae libraries into the given state.
        </p>

        <hr><h3><a name="tokuL_openlibsx"><code>tokuL_openlibsx</code></a></h3><p>
        <span class="apii">[-0, +0, <em>e</em>]</span>
        <pre>void tokuL_openlibsx (toku_State *T, int libload, int libpreload);</pre>
        <p>
        Opens (loads) and preloads selected standard libraries into the state
        <code>T</code>.
        (To <em>preload</em> means to add the library loader into the table
        <a href="#package.preload"><code>package.preload</code></a>,
        so that the library can be imported later by the program.
        Keep in mind that <a href="#import"><code>import</code></a> itself is
        provided by the <em>package</em> library.
        If a program does not load that library, it will be unable to import anything.)
        <br/><br/>
        The integer <code>libload</code> selects which libraries to load;
        the integer <code>libpreload</code> selects which to libpreload,
        among those not loaded.
        Both are masks formed by a bitwise OR of the following constants:
        <ul>
            <li>
                <b><a name="TOKU_LIB_BASIC"><code>TOKU_LIB_BASIC</code></a> </b>:
                the basic library.
            </li>
            <li>
                <b><a name="TOKU_LIB_PACKAGE"><code>TOKU_LIB_PACKAGE</code></a> </b>:
                the package library.
            </li>
            <li>
                <b><a name="TOKU_LIB_STRING"><code>TOKU_LIB_STRING</code></a> </b>:
                the string library.
            </li>
            <li>
                <b><a name="TOKU_LIB_REGEX"><code>TOKU_LIB_REGEX</code></a> </b>:
                the regular expression library.
            </li>
            <li>
                <b><a name="TOKU_LIB_UTF8"><code>TOKU_LIB_UTF8</code></a> </b>:
                the UTF-8 library.
            </li>
            <li>
                <b><a name="TOKU_LIB_LIST"><code>TOKU_LIB_LIST</code></a> </b>:
                the list library.
            </li>
            <li>
                <b><a name="TOKU_LIB_MATH"><code>TOKU_LIB_MATH</code></a> </b>:
                the math library.
            </li>
            <li>
                <b><a name="TOKU_LIB_IO"><code>TOKU_LIB_IO</code></a> </b>:
                the I/O library.
            </li>
            <li>
                <b><a name="TOKU_LIB_OS"><code>TOKU_LIB_OS</code></a> </b>:
                the operating system library.
            </li>
            <li>
                <b><a name="TOKU_LIB_DEBUG"><code>TOKU_LIB_DEBUG</code></a> </b>:
                the debug library.
            </li>
        </ul>
        </p>




        <h2>6.2 &ndash; <a name="6.2">Basic Library</a></h2>
        <p>
        The basic library provides core functions to Tokudae.
        If you do not include this library in your application,
        you should check carefully whether you need to provide
        implementations for some of its facilities.
        </p>

        <!-- clone -->
        <hr/><h3><a name="clone"><code>clone (v)</code></a></h3>
        <p>
        Returns the deep or shallow copy of the value <code>v</code>.
        <br/><br/>
        Values such as a string, a number, a boolean, a nil, a function,
        a light userdata or a thread are shallow copied,
        while all the other values are deep copied.
        Additionally this function makes sure to re-use already existing
        clones of the value that is seen more than once while traversing
        the value that is being deep copied.
        <br/><br/>
        Shallow copy returns that same value, while deep copy creates
        a new value of the same type and deep copies the components of
        that value.
        For instance, if we were to clone a class value, this would also
        clone the class metatable, class method table and finally class
        superclass.
        This cloning works the same for all the other deep copied values
        except the full userdata (read next).
        <br/><br/>
        There is an exception on how cloning works for full userdata values.
        When cloning full userdata, new userdata is created, all of the
        uservalues are cloned and the underlying memory block bytes are copied
        over, however the metatable is not cloned, instead the metatable of
        the full userdata that is being cloned is set as the metatable of
        the new full userdata.
        <details class = "example">
            <summary>Example</summary>
            <pre>
local repeated = {};
local l = [
    5, "ok", false, true, /* shallow copy values */
    {a=5,b=6}, class{}, (class{ fn a() {} })(), /* deep copy values */
    repeated, repeated,
];

local l2 = clone(l);
assert(typeof(l2) == "list" and l2 != l);
assert(l[0] == l2[0] and l[1] == l2[1] and l[2] == l2[2] and l[3] == l2[3]);
assert(l[4].a == l2[4].a and l[4].b == l2[4].b and l[4] != l2[4]);
assert(l[5] != l2[5] and typeof(l[5]) == typeof(l2[5]));
assert(getclass(l[6]) != getclass(l2[6]) and typeof(l[6]) == typeof(l2[6]));
assert(getclass(getclass(l[6]), "a") == getclass(getclass(l2[6]), "a"));
assert(l[7] == repeated and l2[7] != repeated);
assert(l[8] == l[7] and l2[8] == l2[7]);</pre>
        </details>
        </p>

        <!-- error -->
        <hr/><h3><a name="error"><code>error (message[, level])</code></a></h3>
        <p>
        Raises an error (see <a href="#2.3">&sect;2.3</a>) with
        <code>message</code> as the error object.
        This function never returns.
        <br/> <br/>
        Usually, <code>error</code> adds some information about the error
        position at the beginning of the message, if the message is a string.
        The <code>level</code> argument specifies how to get the error position.
        With level&nbsp;1 (the default), the error position is where the
        <code>error</code> function was called.
        Level&nbsp;2 points the error to where the function that called
        <code>error</code> was called; and so on.
        Passing a level&nbsp;0 avoids the addition of error position
        information to the message.
        <details class = "example">
            <summary>Example</summary>
            <pre>
local fn blabla(lvl) {
    local x = 0;
    for local i = 0; i &lt; 50; i++;
        x += i;
    error("ehmm, error!", lvl);
    return x;
}

blabla(0);      /* errors with "ehmm, error!" */
blabla(1);      /* errors with "{source}:5: ehmm, error!" */
blabla(2);      /* errors with "{source}:11: ehmm, error!" */
blabla(3);      /* errors with "ehmm, error!" */</pre>
        </details>
        </p>

        <!-- assert -->
        <hr/><h3><a name="assert"><code>assert (v[, message])</code></a></h3>
        <p>
        Raises an error if the value of its argument <code>v</code> is false
        (i.e., <b>nil</b> or <b>false</b>); otherwise, returns all its
        arguments.
        <br/><br/>
        In case of error, <code>message</code> is the error object;
        when absent, it defaults to "<code>assertion failed!</code>"
        <details class = "example">
            <summary>Example</summary>
            <pre>
assert(nil or false, "whoops!");    /* errors with "{source}:1: whoops!" */
print(assert(true, "ok"));          /* this prints "true\tok\n" */
assert(!true);                      /* errors with "{source}:3: assertion failed!" */</pre>
        </details>
        </p>

        <!-- gc -->
        <hr/><h3><a name="gc"><code>gc ([opt[, arg]])</code></a></h3>
        <p>
        This function is a generic interface to the garbage collector.
        It performs different functions according to its first argument,
        <code>opt</code>:
        <ul>
            <li>
                <b>"<code>collect</code>": </b>
                Performs a full garbage-collection cycle.
                This is the default option.
            </li>
            <li>
                <b>"<code>stop</code>": </b>
                Stops automatic execution of the garbage collector.
                The collector will run only when explicitly invoked,
                until a call to restart it.
            </li>
            <li>
                <b>"<code>restart</code>": </b>
                Restarts automatic execution of the garbage collector.
            </li>
            <li>
                <b>"<code>check</code>": </b>
                Returns true if any memory has been swept (this does not
                necessarily mean <em>collected</em>) by the garbage collector.
            </li>
            <li>
                <b>"<code>count</code>": </b>
                Returns the total memory in use by Tokudae in Kbytes.
                The value has a fractional part, so that it multiplied by
                1024 gives the exact number of bytes in use by Tokudae.
            </li>
            <li>
                <b>"<code>step</code>": </b>
                Performs a garbage-collection step.
                The step "size" is controlled by <code>arg</code>.
                With a zero value, the collector will perform one basic
                (indivisible) step.
                For non-zero values, the collector will perform as if that
                amount of memory (in Kbytes) had been allocated by Tokudae.
                Returns <b>true</b> if the step finished a collection cycle.
            </li>
            <li>
                <b>"<code>param</code>": </b>
                Changes and/or retrieves the values of a parameter of the
                collector. This option must be followed by one or two extra
                arguments: The name of the parameter being changed or
                retrieved (a string) and an optional new value for that
                parameter, an integer in the range <em>[0,1000]</em>, or
                an integer in the range <em>[0,255]</em> in case first
                argument is "<code>stepsize</code>".
                The first argument must have one of the following values:
                <ul>
                    <li>
                        <b>"<code>pause</code>"</b>:
                        The garbage-collector pause.
                    </li>
                    <li><b>"<code>stepmul</code>"</b>: The step multiplier.</li>
                    <li><b>"<code>stepsize</code>"</b>: The step size.</li>
                </ul>
                The call always returns the previous value of the parameter.
                If the call does not give a new value, the value is left
                unchanged.
            </li>
            <li>
                <b>"<code>isrunning</code>": </b>
                Returns a boolean that tells whether the collector is running
                (i.e., not stopped).
            </li>
        </ul>
        See <a href="#2.5">&sect;2.5</a> for more details about garbage
        collection and some of these options.
        <br/><br/>
        This function should not be called by a finalizer.
        <br/><br/>
        <details class = "example">
            <summary>Example</summary>
            <pre>
gc();                                   /* full cycle */
local memkb = gc("count");              /* get total memory in Kbytes */
gc("stop");                             /* stop automatic collection */
gc("check");                            /* reset check */
foreach i in range(1000)                /* make 1000 lists (garbage) */
    assert([2, 3]);
local memkbdiff = gc("count") - memkb;  /* garbage in Kbytes */
assert(1 &lt; memkbdiff);                  /* at least 2 or more Kbytes of garbage */
assert(!gc("check"));                   /* nothing was swept, collector is stopped */
gc("step", math.ceil(memkbdiff/2));     /* collect half or more garbage */
assert(memkb &lt;= gc("count"));           /* still might have more garbage */
gc("collect");                          /* collect all (full cycle) */
assert(gc("count") &lt;= memkb);
gc("restart");                          /* again enable automatic collection */</pre>
        </details>
        </p>

        <!-- load -->
        <hr/><h3><a name="load"><code>load (chunk[, chunkname[, mode[, env]]])</code></a></h3>
        <p>
        Loads a chunk.
        <br/><br/>
        If <code>chunk</code> is a string, the chunk is this string.
        If <code>chunk</code> is a function, <code>load</code> calls it
        repeatedly to get the chunk pieces. Each call to <code>chunk</code>
        must return a string that concatenates with previous results.
        A return of an empty string, <b>nil</b>, or no value signals the end
        of the chunk.
        <br/><br/>
        If there are no syntactic errors, <code>load</code> returns the
        compiled chunk as a function; otherwise, it returns <b>fail</b> plus
        the error message.
        <br/><br/>
        When you load a main chunk, the resulting function will always have
        exactly one upvalue, the <code>__ENV</code> variable
        (see <a href="#2.2">&sect;2.2</a>).
        However, when you load a binary chunk created from a function
        (see <a href="#string.dump"><code>string.dump</code></a>),
        the resulting function can have an arbitrary number of upvalues,
        and there is no guarantee that its first upvalue will be
        the <code>__ENV</code> variable.
        (A non-main function may not even have an <code>__ENV</code> upvalue.)
        <br/><br/>
        Regardless, if the resulting function has any upvalues,
        its first upvalue is set to the value of <code>env</code>,
        if that parameter is given,
        or to the value of the global environment.
        Other upvalues are initialized with <b>nil</b>.
        All upvalues are fresh, that is,
        they are not shared with any other function.
        <br/><br/>
        <code>chunkname</code> is used as the name of the chunk for error
        messages and debug information
        (see <a href="#toku_Debug"><code>toku_Debug</code></a>).
        When absent, it defaults to <code>chunk</code>, if <code>chunk</code>
        is a string, or to "<code>=(load)</code>" otherwise.
        <br/><br/>
        The string <code>mode</code> controls whether the chunk can be
        text or binary (that is, a precompiled chunk).
        It may be the string "<code>b</code>" (only binary chunks),
        "<code>t</code>" (only text chunks),
        or "<code>bt</code>" (both binary and text).
        The default is "<code>bt</code>".
        <br/><br/>
        Tokudae does not check the consistency of binary chunks.
        Maliciously crafted binary chunks can crash the interpreter.
        You can use the <code>mode</code> parameter to prevent loading
        binary chunks.
        <details class = "example">
            <summary>Example</summary>
            <pre>
/* load 'chunk' from string named "string chunk" and __ENV is set to the __G */
local chunk = [=[
    a = 420;
    return 69;
]=];
local func = load(chunk, "string chunk");
assert(a == nil);
assert(func() == 69);
assert(a == 420);
a = nil;

/* load 'chunk' from string named "string chunk" but set environment */
func = load(chunk, "string chunk", "t", { assert = assert });
assert(a == nil);
assert(func() == 69);
assert(a == nil);

/* load chunk from function and __ENV is set to the __G */
local err;
local npieces = 1;
chunk = fn () {
    local s = nil;
    switch (npieces) {
        case 1: s = "a = 69;"; break;
        case 2: s = "assert(true);"; break;
        case 3: s = "assert(!false);"; break;
        case 4: s = "return 420;"; break;
        default: break;
    }
    npieces = npieces + 1;
    return s;
};
func, err = load(chunk);
assert(!err);
assert(a == nil);
assert(func() == 420);
assert(a == 69);
a = nil;

/* load chunk from function but the final chunk has syntactical error */
chunk = || { return "break;"; };
func, err = load(chunk);
assert(func == nil and err and typeof(err) == "string");</pre>
        </details>
        </p>

        <!-- loadfile -->
        <hr/><h3><a name="loadfile"><code>loadfile ([filename[, mode[, env]]])</code></a></h3>
        <p>
        Similar to <a href="#load"><code>load</code></a>,
        but gets the chunk from file <code>filename</code> or from the
        standard input, if no file name is given.
        <details class = "example">
            <summary>Example</summary>
            <details class = "example">
                <summary>test.toku</summary>
                <pre>
a, b, c = 69, 69, 69;
return a,b,c;</pre>
            </details>
            <details class = "example">
                <summary>testerr.toku</summary>
                <pre>
false;</pre>
            </details>
            <pre>
local t = {};   /* environment */
local func, err = loadfile("test.toku", "t", t);
assert(func and !err);
func();         /* call the pre-compiled chunk */
assert(!a and !b and !c);
assert(t.a == 69 and t.b == 420 and t.c == 1337);

#func, err = loadfile();    /// uncomment to read the func from stdin

func, err = loadfile("testerr.toku");
assert(!func and err and typeof(err) == "string");</pre>
        </details>
        </p>

        <!-- runfile -->
        <hr/><h3><a name="runfile"><code>runfile ([filename])</code></a></h3>
        <p>
        Opens the named file and executes its content as a Tokudae chunk.
        When called without arguments, <code>runfile</code> executes the
        content of the standard input (<code>stdin</code>).
        Returns all values returned by the chunk.
        In case of errors, <code>runfile</code> propagates the error to its
        caller.
        (That is, <code>runfile</code> does not run in protected mode.)
        <details class = "example">
            <summary>Example</summary>
            <details class = "example">
                <summary>testfile</summary>
                <pre>
a, b, c = 69, 420, 1337;
return a, b, c;</pre>
            </details>
            <pre>
local x, y, z = runfile("testfile");
assert(a == 69 and b == 420 and c == 1337);
assert(x == a and y == b and z == c);</pre>
        </details>
        </p>

        <!-- getmetatable -->
        <hr/><h3><a name="getmetatable"><code>getmetatable (object)</code></a></h3>
        <p>
        If <code>object</code> does not have a metatable, returns <b>nil</b>.
        Otherwise, if the object's metatable has a <code>__metatable</code>
        field, returns the associated value.
        Otherwise, returns the metatable of the given object.
        <details class = "example">
            <summary>Example</summary>
            <pre>
class X {
    __init = || {
        self.x = 69;
        return self;
    };
    bla = 420;
}
local mt = getmetatable(X);
assert(mt.__init and mt.bla == 420);

class Y inherits X {
    __metatable = {};
}
mt = getmetatable(Y);
assert(typeof(mt) == "table" and len(mt) == 0);

local yins = Y();
assert(getmetatable(yins) == mt);

yins = "I am just a string :(";
assert(getmetatable(yins) == nil);</pre>
        </details>
        </p>

        <!-- setmetatable -->
        <hr/><h3><a name="setmetatable"><code>setmetatable (class, metatable)</code></a></h3>
        <p>
        Sets the metatable for the given class.
        If <code>metatable</code> is <b>nil</b>,
        removes the metatable of the given class.
        If the original metatable has a <code>__metatable</code> field,
        raises an error.
        <br/><br/>
        This function returns <code>class</code>.
        <br/><br/>
        To can change the metatable of full userdata from Tokudae code,
        you must use the debug library (<a href="#6.11">&sect;6.11</a>).
        <details class = "example">
            <summary>Example</summary>
            <pre>
class X {}
setmetatable(X, {
    __init = |self, x| {
        self.x = x or 0;
        return self;
    };
    __add = |self,other| {
        return getclass(self)(self.x + other.x);
    };
});

local x = X(4);
x += X(1);
assert(x.x == 5);
x = x + X(2) + X();
assert(getclass(x) == X and x.x == 7);

class Y inherits X {
    __metatable = {};
}
x = Y();
setmetatable(Y, {});    /* raises error */</pre>
        </details>
        </p>

        <!-- unwrapmethod -->
        <hr/><h3><a name="unwrapmethod"><code>unwrapmethod (boundmethod)</code></a></h3>
        <p>
        Returns the <em>self</em> object and the <em>method</em> object from
        the given bound method (<a href="#2.1">&sect;2.1</a>).
        <details class = "example">
            <summary>Example</summary>
            <pre>
class X {
    fn test1() { return 5; }
    fn test2() { return 5; }
}
local x = X();
local bm = x.test1;
assert(typeof(bm) == "bound methood" and bm != x);

local self, method = unwrapmethod(bm);
assert(self == x and typeof(method) == "function");</pre>
        </details>
        </p>

        <!-- getmethods -->
        <hr/><h3><a name="getmethods"><code>getmethods (class)</code></a></h3>
        <p>
        If the class has a <code>__methodtable</code> metafield, then the
        value of that metafield is returned.
        Otherwise, the method table of the class is returned, or <b>nil</b>
        if the class has no method table.
        <details class = "example">
            <summary>Example</summary>
            <pre>
class X {
    fn getx() { return self.x; }
    fn gety() { return self.y; }
    fn getz() { return self.z; }
}
local mt = getmethods(X);
assert(typeof(mt) == "table" and len(mt) == 3);
assert(mt.getx and mt.gety and mt.getz);

class Y inherits X {
    __methodtable = { x = 69; };
}
mt = getmethods(Y);
assert(len(mt) == 1 and mt.x == 69);
assert(!mt.getx and !mt.gety and !mt.getz);</pre>
        </details>
        </p>

        <!-- setmethods -->
        <hr/><h3><a name="setmethods"><code>setmethods (class, methodtable)</code></a></h3>
        <p>
        Sets the method table for the given class.
        If <code>methodtable</code> is <b>nil</b>,
        removes the method table of the given class.
        If the class has a metatable with a <code>__methodtable</code> field,
        raises an error.
        <br/><br/>
        This function returns <code>class</code>.
        <details class = "example">
            <summary>Example</summary>
            <pre>
class X {}
local x = X();
assert(!x.getx and !x.gety and !x.getz);
setmethods(X, {
    getx = |self| { return self.x; };
    gety = |self| { return self.y; };
    getz = |self| { return self.z; };
});
assert(x.getx and x.gety and x.getz);

class Y inherits X {
    __methodtable = {};
}
x = Y();
assert(x.getx and x.gety and x.getz);
setmethods(Y, {});  /* raises an error */</pre>
        </details>
        </p>

        <!-- nextfield -->
        <hr/><h3><a name="nextfield"><code>nextfield (v[, index])</code></a></h3>
        <p>
        Allows a program to traverse all fields of <code>v</code>.
        Its first argument <code>v</code> is a table or an instance and its
        second argument is an index in <code>v</code>.
        A call to <code>nextfield</code> returns the next index of
        <code>v</code> and its associated value.
        When called with <b>nil</b> as its second argument,
        <code>nextfield</code> returns an initial index and
        its associated value.
        When called with the last index, or with <b>nil</b> in an empty
        table or instance without fields,
        <code>nextfield</code> returns <b>nil</b>.
        If the second argument is absent,
        then it is interpreted as <b>nil</b>.
        In particular, you can use <code>nextfield(v)</code> to check whether
        <code>v</code> is empty or has no fields.
        <br/><br/>
        The order in which the indices are enumerated is not specified.
        <br/><br/>
        You should not assign any value to a non-existent field in
        <code>v</code> during its traversal.
        You may however modify existing fields.
        In particular, you may set existing fields to <b>nil</b>.
        <details class = "example">
            <summary>Example</summary>
            <pre>
local x = "Water";
local t = {
    a = "69",
    b = "420",
    c = "1337",
    ["x"] = 69,
    ["y"] = 420,
    ["z"] = 1337,
    [x] = true
};
toku_assert(len(t) == 7);   /* will do 7 valid iterations */
local k, v = nextfield(t);  /* 1st iteration (index is nil) */
assert(k and v);
k, v = nextfield(t, k);     /* 2nd iteration */
assert(k and v);
k, v = nextfield(t, k);     /* 3rd iteration */
assert(k and v);
k, v = nextfield(t, k);     /* 4th iteration */
assert(k and v);
k, v = nextfield(t, k);     /* 5th iteration */
assert(k and v);
k, v = nextfield(t, k);     /* 6th iteration */
assert(k and v);
k, v = nextfield(t, k);     /* 7th iteration */
assert(k and v);
k, v = nextfield(t, k);     /* 8th iteration */
assert(!k and !v);          /* no more */</pre>
        </details>
        </p>

        <!-- fields -->
        <hr/><h3><a name="fields"><code>fields (v)</code></a></h3>
        <p>
        If <code>v</code> has a metamethod <code>__fields</code>,
        calls it with <code>v</code> as argument and returns the first
        three results from the call.
        <br/><br/>
        Otherwise, returns three values:
        the <a href="#nextfield"><code>nextfield</code></a> function,
        <code>v</code>, and <b>nil</b>, so that the construction

        <pre>
    foreach k,v in fields(v) <em>body</em></pre>

        will iterate over all the fields of <code>v</code>;
        <code>v</code> should be either a <em>table</em> or an <em>instance</em>.
        <br/><br/>
        See function <a href="#nextfield"><code>nextfield</code></a> for the
        caveats of modifying <code>v</code> during its traversal.
        <br/><br/>
        <details class = "example">
            <summary>Example</summary>
            <pre>
local t = {
    a = "69",
    b = "420",
    c = "1337",
    ["x"] = 69,
    ["y"] = 420,
    ["z"] = 1337,
};

local i = 0;
foreach k, v in fields(t) i++;
assert(i == 6);

local class X {
    __init = |x, y, z| {
        self.x = x;
        self.y = y;
        self.z = z;
        return self;
    };
};
local x = X(69, 420, 1337);
foreach k, v in fields(x) i++;
assert(i == 9);

local class MyTable {
    __init = || {
        self.table = { a = 1, b = 2, c = 3, d = 4 };
        return self;
    };
    __fields = || {
        local fn iter(self, k) {
            if (typeof(self) != "instance" or getclass(self) != MyTable)
                error("iteratora expects instance of MyTable");
            return nextfield(self.table, k);
        }
        return iter, self, nil;
    };
}
x = MyTable();
foreach k, v in fields(ins) i++;
assert(i == 13);

local iter, state, index = fields(x);
assert(state == x and index == nil);
iter({ a = 5 }, index);     /* error is raised */
iter((class{})(), index);   /* error is raised */</pre>
        </details>
        </p>

        <!-- indices -->
        <hr/><h3><a name="indices"><code>indices (v)</code></a></h3>
        <p>
        If <code>v</code> has a metamethod <code>__indices</code>,
        calls it with <code>v</code> as argument and returns the first
        three results from the call.
        <br/><br/>
        Otherwise, argument <code>v</code> must be a list.
        Returns three values:
        an iterator function, the list <code>v</code>, and -1,
        so that the construction

        <pre>
    foreach i,v in indices(l) <em>body</em></pre>

        will iterate over the index&nbsp;value pairs
        (<code>0,l[0]</code>), (<code>1,l[1]</code>), ...,
        up to the <em>length</em> of the list <code>l</code>.
        <br/><br/>
        <details class = "example">
            <summary>Example</summary>
            <pre>
local l = [0, 69, 420, 1337, 133742069, 1337, 420, 69, 0];
foreach i, v in indices(l) {
    switch (i) {
        case 0: assert(v == 0); break;
        case 1: assert(v == 69); break;
        case 2: assert(v == 420); break;
        case 3: assert(v == 1337); break;
        case 4: assert(v == 133742069); break;
        case 5: assert(v == 1337); break;
        case 6: assert(v == 420); break;
        case 7: assert(v == 69); break;
        case 8: assert(v == 0); break;
        default: assert(false);
    }
}

local class MyList {
    __init = || {
        self.list = [5, 5, 10, 15, 25, 40, 65];
        return self;
    };
    __indices = || {
        fn iter(self, i) {
            if typeof(self) != "instance" or getclass(self) != MyList
                error("expected instance of MyList");
            i++;
            if (i >= self.list.len)
                return nil;
            else
                return i, self.list[i];
        }
        return iter, self, -1;
    };
}
l = MyList();
local j = 0;
foreach i,v in indices(l) j++;
assert(j == l.list.len);

local iter, state, index = indices(l);
iter([], index);            /* error is raised */
iter((class{})(), index);   /* error is raised */</pre>
        </details>
        </p>

        <!-- pcall -->
        <hr/><h3><a name="pcall"><code>pcall (f[, arg1, &middot;&middot;&middot;])</code></a></h3>
        </p>
        Calls the function <code>f</code> with the given arguments in
        <em>protected mode</em>.
        This means that any error inside&nbsp;<code>f</code> is not propagated;
        instead, <code>pcall</code> catches the error and returns a status code.
        Its first result is the status code (a boolean), which is <b>true</b>
        if the call succeeds without errors.
        In such case, <code>pcall</code> also returns all results from the call,
        after this first result.
        <br/><br/>
        In case of any error, <code>pcall</code> returns <b>false</b> plus
        the error object.
        Note that errors caught by <code>pcall</code> do not call
        a message handler.
        <br/><br/>
        <details class = "example">
            <summary>Example</summary>
            <pre>
fn test1() { local x <close> = "invalid close value"; }

local res, err = pcall(test1);
assert(res == false and !res and typeof(err) == "string");

fn test2() { return 69, 55, 32; }

local res1,res2,res3;
res, err, res1, res2, res3 = pcall(test2);
assert(res == true and err == 69 and res1 == 55 and res2 == 32 and res3 == nil);

fn test3() error("pupu kaka");
res, err = pcall(test3);
assert(!res and string.find(err, "pupu kaka"));</pre>
        </details>
        <p>

        <!-- xpcall -->
        <hr/><h3><a name="xpcall"><code>xpcall (f, msgh[, arg1, &middot;&middot;&middot;])</code></a></h3>
        <p>
        This function is similar to <a href="#pcall"><code>pcall</code></a>,
        except that it sets a new message handler <code>msgh</code>.
        <details class = "example">
            <summary>Example</summary>
            <pre>
/* this message handler concats " 69" to the original error */
local fn msgh(err) { return err .. " 69"; }

/* functions that errors */
fn test1() { local x <close> = "invalid close value"; }

/* call the function that errors with our message handler */
local res, err = xpcall(test1, msgh);
assert(!res and string.find(err, " 69"));</pre>
        </details>
        </p>

        <!-- print -->
        <hr/><h3><a name="print"><code>print (&middot;&middot;&middot;)</code></a></h3>
        <p>
        Receives any number of arguments and prints their values to
        <code>stdout</code>, converting each argument to a string
        following the same rules of <a href="#tostr"><code>tostr</code></a>.
        After each argument, the tab character '<code>\t</code>' is printed,
        and before returning newline character '<code>\n</code>' is printed.
        <br/><br/>
        The function <code>print</code> is not intended for formatted output,
        but only as a quick way to show a value, for instance for debugging.
        For complete control over the output, use
        <a href="#string.fmt"><code>string.fmt</code></a> and
        <a href="#io.write"><code>io.write</code></a>.
        <details class = "example">
            <summary>Example</summary>
            <pre>
print("ok", true, false, nil, 420);     /// prints "ok\ttrue\tfalse\tnil\t420\n"
print();    /// prints "\n"</pre>
        </details>
        </p>

        <!-- printf -->
        <hr/><h3><a name="printf"><code>printf (fmt, &middot;&middot;&middot;)</code></a></h3>
        <p>
        Receives any number of arguments after the string <code>fmt</code>,
        then for each '<code>%</code>' character in <code>fmt</code>,
        substitutes it with the received argument, after the argument was
        converted to a string following the same rules of
        <a href="#tostr"><code>tostr</code></a>.
        The arguments are substituted with the specifier '<code>%</code>' in
        order the function received them (left to right).
        In order to have a literal '<code>%</code>' in <code>fmt</code>,
        you escape the specifier with another specifier ("<code>%%</code>").
        <br/><br/>
        If there are too little arguments, meaning there is unmatched
        '<code>%</code>', this raises error.
        Any extra arguments are ignored.
        <br/><br/>
        Final string, after the substitution, is printed to
        <code>stdout</code> together with a newline character
        '<code>\n</code>'.
        <br/><br/>
        Similar to <a href="#print"><code>print</code></a> function,
        this function also serves for a quick way to show a value in
        a bit nicer format.
        For complete control over the output, use
        <a href="#string.fmt"><code>string.fmt</code></a> and
        <a href="#io.write"><code>io.write</code></a>.
        <details class = "example">
            <summary>Example</summary>
            <pre>
printf("% % % % %%%", "ok", true, false, nil, 420);  /// prints "ok true false nil %420\n"

local st, err = pcall(printf, "I have one unmatched %%! % %", 6);
assert(!st and string.find(err, "unmatched"));</pre>
        </details>
        </p>

        <!-- warn -->
        <hr/><h3><a name="warn"><code>warn (msg1, &middot;&middot;&middot;)</code></a></h3>
        <p>
        Emits a warning with a message composed by the concatenation
        of all its arguments (which should be strings).
        <br/><br/>
        By convention, a one-piece message starting with '<code>@</code>'
        is intended to be a <em>control message</em>,
        which is a message to the warning system itself.
        In particular, the standard warning function in Tokudae
        recognizes the control messages "<code>@off</code>",
        to stop the emission of warnings, and "<code>@on</code>", to
        (re)start the emission; it ignores unknown control messages.
        <details class = "example">
            <summary>Example</summary>
            <pre>
warn("@on");
warn("this is a", " warning for ", "'69' users");
warn("@this is ignored");
warn("this is a", " warning for ", "'420' users");
warn("@off");
warn("warnings are off ", "so this is ignored");
warn("warnings are still off");
warn("@on");
warn("this is a", " warning for ", "'1337' users");</pre>
        </details>
        </p>

        <!-- len -->
        <hr/><h3><a name="len"><code>len (v)</code></a></h3>
        <p>
        Returns the length of the value <code>v</code>, which must be
        a list, a table, an instance, a class or a string.
        <br/> <br/>
        <em>List</em> length is is explained in <a href="#2.1">&sect;2.1</a>,
        <em>table</em> and <em>instance</em> length is total number of fields
        with non-<b>nil</b> values; <em>class</em> length is the total number
        of methods in a method table; <em>string</em> length is the size of
        string in bytes.
        <br/><br/>
        Returns an integer.
        <details class = "example">
            <summary>Example</summary>
            <pre>
assert(len([69, 420, 1337]) == 3);
assert(len({ a = 69, b = 420, c = "1337"}) == 3);
assert(len("69,420,1337") == 11);
local a = class {
    __init = fn() {
        self.x = 69;
        self.y = 420;
        self.z = 1337;
        self.k = 'k';
        return self;
    };
    fn test1() {} fn test2() {} fn test3() {} fn test4() {} fn test5() {}
};
assert(len(a) == 5);
assert(len(a()) == 4);</pre>
        </details>
        </p>

        <!-- rawequal -->
        <hr/><h3><a name="rawequal"><code>rawequal (v1, v2)</code></a></h3>
        <p>
        Checks whether <code>v1</code> is equal to <code>v2</code>,
        without invoking the <code>__eq</code> metamethod.
        <br/><br/>
        Returns a boolean.
        <details class = "example">
            <summary>Example</summary>
            <pre>
local a = class { __eq = fn(rhs) { return nil; }; };
local x = a();
assert(!(x == x));
assert(rawequal(x, x));
assert(rawequal(5, 5));
assert(!rawequal(5, 3));
assert(rawequal(5.2, 5.2));
assert(!rawequal(5.2, 5.1));
assert(rawequal("ok", "ok"));
assert(!rawequal("ok", "ko"));
assert(rawequal(true, true));
assert(!rawequal(true, false));
assert(rawequal(nil, nil));
assert(!rawequal(nil, !nil));
assert(rawequal(inf, infinity));
assert(!rawequal(inf, -infinity));
x = [69, 420];
assert(rawequal(x, x));
assert(!rawequal(x, [69, 420]));
x = { a = 69, b = 420 };
assert(rawequal(x, x));
assert(!rawequal(x, { a = 69, b = 420 }));
assert(rawequal(a, a));
assert(!rawequal(a, class {}));

class X { fn a() {} }
local y = X();
x = X();
assert(!rawequal(x.a, y.a));
assert(rawequal(unwrapmethod(x.a), x));
assert(rawequal(unwrapmethod(y.a), y));

local _, method1 = unwrapmethod(x.a);
local _, method2 = unwrapmethod(y.a);
assert(rawequal(method1, method2));</pre>
        </details>
        </p>

        <!-- rawget -->
        <hr/><h3><a name="rawget"><code>rawget (v, index[, any])</code></a></h3>
        <p>
        Gets the real value of <code>v[index]</code>,
        without calling the <code>__getidx</code> metamethod.
        <code>v</code> must be an instance or a table,
        and <code>index</code> may be any Tokudae value.
        <br/><br/>
        Optional third argument <code>any</code> is a flag, which is ignored
        if <code>v</code> is a table.
        Otherwise, if <code>any</code> is neither a <b>nil</b> nor <b>false</b>, 
        then this function can return a bound method if the <code>index</code>
        is not present in field table, but is present in method table of the
        class of the instance.
        By default if <b>any</b> is not provided, it is set to <b>nil</b>.
        <details class = "example">
            <summary>Example</summary>
            <pre>
local a = class {
    __getidx = fn(k) {
        assert(k);
        return nil;
    };
};
local x = a();
x.ok = 69;
assert(x["ok"] == nil);
assert(rawget(x, "ok") == 69);

x = {ok = 69};
assert(x["ok"] == 69);
assert(rawget(x, "ok") == 69);
assert(rawget(x, "notok") == undef);

/// rawget only fields
local class X {
    fn a() {}
    fn b() {}
}
x = X();
x.c = 5;
assert(x.c == 5 and rawget(x, "c") == 5);
assert(rawget(x, "a") == nil);
assert(typeof(x.a) == "bound method");
assert(rawget(x, "b") == nil);
assert(typeof(x.b) == "bound method");

/// allow bound methods
assert(typeof(rawget(x, "a", true)) == "bound method");
assert(typeof(rawget(x, "b", true)) == "bound method");
assert(rawget(x, "c", true) == 5);</pre>
        </details>
        </p>

        <!-- rawset -->
        <hr/><h3><a name="rawset"><code>rawset (v, index, value)</code></a></h3>
        <p>
        Sets the real value of <code>v[index]</code> to <code>value</code>,
        without using the <code>__setidx</code> metamethod.
        <code>v</code> must be an instance or a table;
        <code>index</code> any value different from <b>nil</b> and NaN;
        <code>value</code> any Tokudae value.
        (This function when called with <code>v</code> being a table is
        quite useless, the regular table field assignment has less overhead.)
        <br/><br/>
        This function returns <code>v</code>.
        <details class = "example">
            <summary>Example</summary>
            <pre>
local a = class {
    __setidx = fn(k, v) {
        assert(k and (typeof(v) == "number"));
        rawset(self, k, v*2);
    };
};
local x = a();
x.a = 210;
assert(x.a == 420);
rawset(x, "a", 69);
assert(x.a == 69);</pre>
        </details>
        </p>

        <!-- getargs -->
        <hr/><h3><a name="getargs"><code>getargs (index, &middot;&middot;&middot;)</code></a></h3>
        <p>
        If <code>index</code> is a number, this returns all arguments from
        argument at number <code>index</code> (starting from 0); a negative
        number indexes from the end (-1 is the last argument).
        Otherwise, <code>index</code> must be one of these strings:
        <code>"list"</code>, <code>"table"</code>, <code>"last"</code> or
        <code>"len"</code>.
        <br/>
        If <code>index</code> is <code>"list"</code> string,
        this returns all of the extra arguments it received inside of
        a list (elements are stored in the same order).
        <br/>
        If <code>index</code> is <code>"table"</code> string,
        this returns all of the extra arguments it received inside of
        a table where every argument is a <b>true</b> field.
        <br/>
        If <code>index</code> is <code>"last"</code> string,
        this returns only the last extra argument it received (if any).
        <br/>
        If <code>index</code> is <code>"len"</code> string,
        this returns integer corresponding to total number of extra
        arguments it received.
        <details class = "example">
            <summary>Example</summary>
            <pre>
local x, y, z = getargs(1, 5, 6, 7);
assert(x == 6 and y == 7 and z == nil);
x, y, z = getargs(-2, 5, 6, 7);
assert(x == 6 and y == 7 and z == nil);

local args = [ 1, 2, "ok" ];
x = getargs("list", list.flatten(args));
assert(x and typeof(x) == "list" and len(x) == 3);
assert(x[0] == 1 and x[1] == 2 and x[2] == "ok" and x[3] == undef);

x = getargs("table", list.flatten(args));
assert(x and typeof(x) == "table" and len(x) == 3);
assert(x[args[0]] == true and x[args[1]] == true and x[args[2]] == true);

assert(getargs(0) == nil);
x, y = getargs(0);
assert(!x and !y);

assert(getargs("len", list.flatten(args)) == 3);
assert(getargs("len") == 0);

assert(getargs("last", list.flatten(args)) == "ok");
assert(getargs("last") == nil);

assert(!pcall(getargs));
assert(!pcall(getargs, "bla"));
assert(!pcall(getargs, -4, args));
assert(!pcall(getargs, 1));</pre>
        </details>
        </p>

        <!-- tonum -->
        <hr/><h3><a name="tonum"><code>tonum (v[, base])</code></a></h3>
        <p>
        When called with no <code>base</code>,
        <code>tonum</code> tries to convert its argument to a number.
        If the argument <code>v</code> is already a number or a string
        convertible to a number, then <code>tonum</code> returns this
        number and overflow integer (if any);
        otherwise, it returns <b>fail</b>.
        <br/><br/>
        The conversion of strings can result in integers or floats,
        according to the lexical conventions of Tokudae
        (see <a href="#3.1">&sect;3.1</a>), with the exception that this
        function does not allow digit separator '<code>_</code>'.
        The string may have leading and trailing spaces and a sign.
        <br/><br/>
        When called with <code>base</code>, then <code>v</code> must be a
        string to be interpreted as an integer numeral in that base.
        The base may be any integer between 2 and 36, inclusive.
        In bases above&nbsp;10, the letter '<code>A</code>' (in either upper
        or lower case) represents&nbsp;10, '<code>B</code>' represents&nbsp;11,
        and so forth, with '<code>Z</code>' representing&nbsp;35.
        If the string <code>v</code> is not a valid numeral in the given base,
        the function returns <b>fail</b>.
        <details class = "example">
            <summary>Example</summary>
            <pre>
local res, of = tonum("69");
assert(res == 69 and of == nil);
res, of = tonum("-69");
assert(res == -69 and of == nil);
res, of = tonum("69.420");
assert(res == 69.420 and of == nil);
res, of = tonum("-69.420");
assert(res == -69.420 and of == nil);
res, of = tonum(".420");
assert(res == .420 and of == nil);
res, of = tonum("-.420");
assert(res == -.420 and of == nil);
res, of = tonum("05");
assert(res == 05 and of == nil);
res, of = tonum("0055");
assert(res == 0055 and of == nil);
res, of = tonum("69.420e2");
assert(res == 69.420e2 and of == nil);
res, of = tonum(".420e-2");
assert(res == .420e-2 and of == nil);
res, of = tonum("0x15");
assert(res == 0x15 and of == nil);
res, of = tonum("-0x15");
assert(res == -0x15 and of == nil);
res, of = tonum("0x15P4");
assert(res == 0x15P4 and of == nil);
res, of = tonum("-0x15p-4");
assert(res == -0x15p-4 and of == nil);
res, of = tonum("inf");
assert(res == inf and of == nil);
res, of = tonum("-inf");
assert(res == -inf and of == nil);
res, of = tonum("infinity");
assert(res == infinity and of == nil);
res, of = tonum("-infinity");
assert(res == -infinity and of == nil);
res, of = tonum("InfiNity");
assert(res == infinity and of == nil);
res, of = tonum("15e15324234");
assert(res == inf and of == 1);
res, of = tonum("-15e153234");
assert(res == -inf and of == 1);
res, of = tonum("15e-400");
assert(res and of == -1);
res, of = tonum("63ab", 16);
assert(res == 25515 and of == nil);
res, of = tonum("63abzg42z", 36);
assert(res == 17184244426667 and of == nil);
res, of = tonum("-63abzg42z", 36);
assert(res == -17184244426667 and of == nil);
res, of = tonum("63abzg42zzzzzzzzzz5555zzzzzzzzzzzzzzzzzzzzzzzz", 36);
assert(res and of == 1);
res, of = tonum("-63abzg42zzzzzzzzzz5555zzzzzzzzzzzzzzzzzzzzzzzz", 36);
assert(res and of == -1);

assert(!tonum("NaN"));
assert(!tonum("nan"));

/*
** Asserts below depends on the types Tokudae was compiled with.
** Here we assume 64 bit integers and double precision floats.
*/
res, of = tonum("0x7fffffffffffffff", 16);
assert(res == 0x7fffffffffffffff and of == nil);
res, of = tonum("-0x8000000000000000", 16);
assert(res == -0x8000000000000000 and of == nil);
res, of = tonum("0x8000000000000001", 16);
assert(res == 0x7fffffffffffffff and of == 1);
res, of = tonum("-0x8000000000000001", 16);
assert(res == 0x7fffffffffffffff+1 and of == -1);
res, of = tonum("0b1111111111111111111111111111111111111111111111111111111111111111");
assert(res == 0b1111111111111111111111111111111111111111111111111111111111111111 and !of);
res, of = tonum("0b0111111111111111111111111111111111111111111111111111111111111111",2);
assert(res == 0b0111111111111111111111111111111111111111111111111111111111111111 and !of);</pre>
        </details>
        </p>

        <!-- tostr -->
        <hr/><h3><a name="tostr"><code>tostr (v)</code></a></h3>
        <p>
        Receives a value of any type and converts it to a string in a
        human-readable format.
        <br/><br/>
        If the metatable of <code>v</code> has a <code>__tostring</code> field,
        then <code>tostr</code> calls the corresponding value
        with <code>v</code> as argument,
        and uses the result of the call as its result.
        Otherwise, if the metatable of <code>v</code> has a
        <code>__name</code> field with a string value,
        <code>tostr</code> may use that string in its final result.
        <br/><br/>
        For complete control of how numbers are converted,
        use <a href="#string.fmt"><code>string.fmt</code></a>.
        <details class = "example">
            <summary>Example</summary>
            <pre>
assert(tostr("already a string") == "already a string");
assert(tostr(nil) == "nil");
assert(tostr(true) == "true");
assert(tostr(false) == "false");
assert(tostr(52) == "52");
assert(tostr(52.25) == "52.25");
assert(tostr(52.69e2) == "5269.0");
assert(tostr(0000) == "0");
assert(string.find(tostr([]), "list"));
assert(string.find(tostr({}), "table"));
assert(string.find(tostr(fn (x){ return x; }), "function"));
local class X {}
assert(string.find(tostr(X), "class"));
assert(string.find(tostr(X()), "instance"));

X = class {
    __init = |name| { self.name = name; return self; };
    __tostring = || { return self.name .. " Banana"; };
};
local x = X("Green");
assert(tostr(x) == "Green Banana");

X = class { __name = "Mango"; };
x = X();
assert(string.find(tostr(x), "Mango"));</pre>
        </details>
        </p>

        <!-- typeof -->
        <hr/><h3><a name="typeof"><code>typeof (v)</code></a></h3>
        <p>
        Returns the type of its only argument, coded as a string.
        The possible results of this function are
        "<code>nil</code>" (a string, not the value <b>nil</b>),
        "<code>boolean</code>",
        "<code>number</code>",
        "<code>userdata</code>",
        "<code>light userdata</code>",
        "<code>string</code>",
        "<code>list</code>",
        "<code>table</code>",
        "<code>function</code>",
        "<code>bound method</code>",
        "<code>class</code>",
        "<code>instance</code>"
        and "<code>thread</code>".
        <details class = "example">
            <summary>Example</summary>
            <pre>
assert(typeof(5) == "number");
assert(typeof(5.5) == "number");
assert(typeof(true) == "boolean");
assert(typeof(false) == "boolean");
assert(typeof("69") == "string");
assert(typeof([]) == "list");
assert(typeof({}) == "table");
assert(typeof(fn (){}) == "function");

local X = class { fn x() {} };
assert(typeof(X) == "class");
assert(typeof(X()) == "instance");
assert(typeof(X().x) == "bound method");

/// full userdata type
assert(typeof(io.stdout) == "userdata");</pre>
        </details>
        </p>

        <!-- getclass -->
        <hr/><h3><a name="getclass"><code>getclass (v[, method])</code></a></h3>
        <p>
        The function takes a value <code>v</code>, which must be either a
        class or an instance, and an optional parameter <code>method</code>.
        If <code>method</code> is omitted or <b>nil</b>, then if
        <code>v</code> is a class, this returns <code>v</code>,
        or if <code>v</code> is an instance, this returns the class of that
        instance.
        <br/><br/>
        Otherwise if <code>method</code> is not <b>nil</b>,
        the behavior depends on whether <code>v</code> is a class or
        an instance.
        Additionally in the following text, <em>method table</em> is the
        value returned by <a href="#getmethods"><code>getmethods</code></a>,
        but with one deviation, if <code>__methodtable</code> metafield
        is present but not a table or an instance, this returns <b>nil</b>.
        <br/>
        When <code>v</code> is an instance, this gets the class of
        <code>v</code>, queries the method table of that class with
        <code>method</code> as key, and if field is present, returns a
        bound method where <code>v</code> is the <em>self</em> object
        and the field value is the <em>method</em> object.
        If <code>method</code> field is not present, it returns <b>nil</b>.
        <br/>
        When <code>v</code> is a class, this returns the value of the
        <code>method</code> field in the method table.
        <details class = "example">
            <summary>Example</summary>
            <pre>
local class X {}
local x = X();
assert(getclass(x) == X);
assert(getclass(X) == X);

X = class {
    fn test1() {}
    fn test2() {}
};

x = X();
local res = getclass(x, "test1");
assert(typeof(res) == "bound method");
local self, method = unwrapmethod(res);
assert(self == x and method == getclass(X, "test1"));
_, method = unwrapmethod(getclass(x, "test2"));
assert(method == getclass(X, "test2"));
assert(!getclass(x, "test3") and !getclass(X, "test3"));</pre>
        </details>
        </p>

        <!-- getsuper -->
        <hr/><h3><a name="getsuper"><code>getsuper (v[, method])</code></a></h3>
        <p>
        The function returns information from the superclass of <code>v</code>,
        where <code>v</code> can be either an instance or a class.
        <br/>
        If the optional <code>method</code> argument is omitted or <b>nil</b>,
        the function simply returns the superclass itself.
        <br/>
        Otherwise if <code>method</code> is present the behaviour is
        similar to <a href="#getclass"><code>getclass</code></a>,
        except the operations defined in that functions would operate
        on the superclass of <code>v</code>.
        Additionally if <code>v</code> has no superclass, this returns
        <b>nil</b>.
        <details class = "example">
            <summary>Example</summary>
            <pre>
class X {
    fn name() return "X";
}
local x = X();
assert(x.name() == "X");

class Y inherits X {
    fn name() {
        assert(super.name() == "X");
        assert(getsuper(super) == nil);
        assert(super == X);
        assert(super.name == super.name);
        assert(super.name == getsuper(self, "name"));
        return "Y" .. super.name();
    }
}
local y = Y();
assert(y.name() == "YX");
assert(getsuper(x) == nil);
assert(!getsuper(x, "name"));
assert(getsuper(y) == X);
assert(getsuper(y, "name"));
assert(!getsuper(y, "bla"));
assert(getsuper(y) == getclass(x));

assert(getsuper(Y, "name")() == "X");</pre>
        </details>
        </p>

        <!-- range -->
        <hr/><h3><a name="range"><code>range (start, stop[, step])</code></a></h3>
        <p>
        This returns an iterator, which is a closure with three upvalues
        which are the arguments to this function.
        All of the arguments must be integers.
        If <code>start</code> is omitted, it defaults to 0.
        If <code>step</code> is omitted, it defaults to 1.
        The optional argument <code>step</code> if provided,
        can be either a positive or negative integer but not 0.
        After a call to <code>range</code> the iterator is returned,
        so the construction,

        <pre>
    foreach i in range(6, 20, 2) <em>body</em></pre>

        iterates over the integers: 6, 8, 10, ..., 18,
        where 6 is the <code>start</code>, 20 is the <code>end</code>,
        and 2 is the <code>step</code>.
        <br/>
        After each call to this iterator,
        if the range is not ended, the current value of
        <code>start</code> is returned and the <code>start</code> upvalue
        is updated to the <code>start + step</code> or is set to
        <code>stop</code> if the increment/decrement would (under)overflow
        the <code>start</code>.
        <br/><br/>
        The iterator returns <b>nil</b> when the range is ended.
        This is when the <code>start</code> is equal or greater than
        <code>stop</code> for a positive <code>step</code>,
        or when the <code>start</code> is equal or less than
        <code>stop</code> for a negative <code>step</code>.
        <br/><br/>
        <details class = "example">
            <summary>Example</summary>
            <pre>
local counter = 0;
foreach i in range(50)
    counter++;
assert(counter == 50);

counter = 0;
foreach i in range(25, 50, 5)
    counter++;
assert(counter == 5);

counter = 0;
foreach i in range(50, 25, -5)
    counter++;
assert(counter == 5);

counter = 0;
foreach i in range(50, 25)
    counter++;
assert(counter == 0);</pre>
        </details>
        </p>

        <!-- __G -->
        <hr/><h3><a name="__G"><code>__G</code></a></h3>
        <p>
        A global variable that holds the global environment
        (see <a href="#2.2">&sect;2.2</a>).
        Tokudae itself does not use this variable;
        changing its value does not affect any environment,
        nor vice versa.
        </p>

        <!-- __VERSION -->
        <hr/><h3><a name="__VERSION"><code>__VERSION</code></a></h3>
        A global variable that holds a string containing the running Tokudae
        version. The current value of this variable is
        "<code>Tokudae 1.0</code>".
        </p>

        <!-- __POSIX -->
        <hr/><h3><a name="__POSIX"><code>__POSIX</code></a></h3>
        A global variable that is set to an integer that corresponds
        to the release year of the POSIX specification.
        For example, if the current instalation of Tokudae is internally
        using API's defined by POSIX 2004 revision, then this would have the
        integer value <code>2004</code>.
        Otherwise this is set to <b>nil</b>.
        </p>

        <!-- __WINDOWS -->
        <hr/><h3><a name="__WINDOWS"><code>__WINDOWS</code></a></h3>
        A global variable that is set to an integer that corresponds to
        the major and minor version of the Microsoft C/C++ compiler.
        For example, if the version number of Microsoft C/C++ compiler is
        17.00.51106.1, the value of
        <a href="#__WINDOWS"><code>__WINDOWS</code></a> will be
        <code>1700</code>.
        Otherwise, if the current installation wasn't built with
        Microsoft C/C++ compiler (or is not using Windows API),
        this is set to <b>nil</b>.
        </p>


        <h2>6.3 &ndash; <a name="6.3">Package Library</a></h2>
        <p>
        The package library provides basic facilities for loading modules
        in Tokudae.
        It exports one function directly in the global environment:
        <a href="#import"><code>import</code></a>.
        Everything else is exported in the table
        <a name="package"><code>package</code></a>.

        <hr><h3><a name="import"><code>import (modname)</code></a></h3>
        <p>
        Loads the given module.
        The function starts by looking into the
        <a href="#package.loaded"><code>package.loaded</code></a> table
        to determine whether <code>modname</code> is already loaded.
        If it is, then <code>import</code> returns the value stored
        at <code>package.loaded[modname]</code>.
        (The absence of a second result in this case
        signals that this call did not have to load the module.)
        Otherwise, it tries to find a <em>loader</em> for the module.
        <br/><br/>
        To find a loader, <code>import</code> is guided by the list
        <a href="#package.searchers"><code>package.searchers</code></a>.
        Each item in this list is a search function, that searches for the
        module in a particular way.
        By changing this list, we can change how <code>import</code> looks
        for a module.
        The following explanation is based on the default configuration
        for <a href="#package.searchers"><code>package.searchers</code></a>.
        <br/><br/>
        First <code>import</code> queries <code>package.preload[modname]</code>.
        If it has a value, this value (which must be a function) is the loader.
        Otherwise <code>import</code> searches for a Tokudae loader using the
        path stored in <a href="#package.path"><code>package.path</code></a>.
        If that also fails, it searches for a C&nbsp;loader using the
        path stored in <a href="#package.cpath"><code>package.cpath</code></a>.
        If that also fails, it tries an <em>all-in-one</em> loader
        (see <a href="#package.searchers"><code>package.searchers</code></a>).
        <br/><br/>
        Once a loader is found, <code>import</code> calls the loader with
        two arguments:
        <code>modname</code> and an extra value, a <em>loader data</em>,
        also returned by the searcher.
        The loader data can be any value useful to the module;
        for the default searchers,
        it indicates where the loader was found.
        (For instance, if the loader came from a file,
        this extra value is the file path.)
        If the loader returns any non-nil value,
        <code>import</code> assigns the returned value to
        <code>package.loaded[modname]</code>.
        If the loader does not return a non-nil value and
        has not assigned any value to <code>package.loaded[modname]</code>,
        then <code>import</code> assigns <b>true</b> to this entry.
        In any case, <code>import</code> returns the
        final value of <code>package.loaded[modname]</code>.
        Besides that value, <code>import</code> also returns as a second
        result the loader data returned by the searcher,
        which indicates how <code>import</code> found the module.
        <br/><br/>
        If there is any error loading or running the module,
        or if it cannot find any loader for the module,
        then <code>import</code> raises an error.
        <details class = "example">
            <summary>Example</summary>
            <pre>
/* importing standard libraries */
assert(import("string") == string);
assert(import("math") == math);
assert(import("io") == io);
assert(import("os") == os);
assert(import("reg") == reg);
assert(import("list") == list);
assert(import("debug") == debug);


/* Below is example of error message if module is not found */

/* save paths */
local oldpath = package.path;
local oldcpath = package.cpath;

package.path = "?.toku;?/?";    /* define new search template for Tokudae path */
package.cpath = "?.so;?/init";  /* define new search template for C path */

local st, msg = pcall(import, "XXX");   /* this fails */

local expected = [=[
module 'XXX' not found:
        no field package.preload['XXX']
        no file 'XXX.toku'
        no file 'XXX/XXX'
        no file 'XXX.so'
        no file 'XXX/init']=];

assert(msg == expected); /* error message matches the expected error */

/* finally restore old paths */
package.path = oldpath;
package.cpath = oldcpath;</pre>
        </details>
        </p>

        <hr><h3><a name="package.config"><code>package.config</code></a></h3>
        <p>
        A string describing some compile-time configurations for packages.
        This string is a sequence of lines:
        <ul>
            <li>
                The first line is the directory separator string.
                Default is '<code>\</code>' for Windows and '<code>/</code>'
                for all other systems.
            </li>
            <li>
                The second line is the character that separates templates
                in a path.
                Default is '<code>;</code>'.
            </li>
            <li>
                The third line is the string that marks the substitution
                points in a template.
                Default is '<code>?</code>'.
            </li>
            <li>
                The fourth line is a string that, in a path in Windows,
                is replaced by the executable's directory.
                Default is '<code>!</code>'.
            </li>
            <li>
                The fifth line is a mark to ignore all text after it
                when building the <code>tokuopen_</code> function name.
                Default is '<code>-</code>'.
            </li>
        </ul>
        </p>

        <hr><h3><a name="package.cpath"><code>package.cpath</code></a></h3>
        <p>
        A string with the path used by <a href="#import"><code>import</code></a>
        to search for a C&nbsp;loader.
        <br/><br/>
        Tokudae initializes the C&nbsp;path
        <a href="#package.cpath"><code>package.cpath</code></a> in the same
        way it initializes the Tokudae path
        <a href="#package.path"><code>package.path</code></a>,
        using the environment variable
        <a name="TOKU_CPATH_1_0"><code>TOKU_CPATH_1_0</code></a>,
        or the environment variable
        <a name="TOKU_CPATH"><code>TOKU_CPATH</code></a>,
        or a default path defined in <code>tokudaeconf.h</code>.
        </p>

        <hr><h3><a name="package.loaded"><code>package.loaded</code></a></h3>
        <p>
        A table used by <a href="#import"><code>import</code></a> to control
        which modules are already loaded.
        When you import a module <code>modname</code> and
        <code>package.loaded[modname]</code> is not false,
        <a href="#import"><code>import</code></a> simply returns the value
        stored there.
        <br/><br/>
        This variable is only a reference to the real table;
        assignments to this variable do not change the
        table used by <a href="#import"><code>import</code></a>.
        The real table is in the C table (see <a href="#4.3">&sect;4.3</a>)
        under the key
        <a name="TOKU_LOADED_TABLE"><code>TOKU_LOADED_TABLE</code></a>,
        a string.
        <details class = "example">
            <summary>Example</summary>
            <pre>
assert(import("string") == package.loaded.string);
assert(import("math") == package.loaded.math);
assert(import("io") == package.loaded.io);
assert(import("os") == package.loaded.os);
assert(import("reg") == package.loaded.reg);
assert(import("list") == package.loaded.list);
assert(import("debug") == package.loaded.debug);</pre>
        </details>
        </p>

        <hr><h3><a name="package.loadlib"><code>package.loadlib (libname, funcname)</code></a></h3>
        <p>
        Dynamically links the host program with the C&nbsp;library
        <code>libname</code>.
        <br/><br/>
        If <code>funcname</code> is "<code>*</code>", then it only links with
        the library, making the symbols exported by the library available
        to other dynamically linked libraries.
        Otherwise, it looks for a function <code>funcname</code> inside the
        library and returns this function as a C&nbsp;function.
        So, <code>funcname</code> must follow the
        <a href="#toku_CFunction"><code>toku_CFunction</code></a> prototype
        (see <a href="#toku_CFunction"><code>toku_CFunction</code></a>).
        <br/><br/>
        This is a low-level function.
        It completely bypasses the package and module system.
        Unlike <a href="#import"><code>import</code></a>, it does not perform
        any path searching and does not automatically adds extensions.
        <code>libname</code> must be the complete file name of the
        C&nbsp;library, including if necessary a path and an extension.
        <code>funcname</code> must be the exact name exported by the
        C&nbsp;library (which may depend on the C&nbsp;compiler and linker
        used).
        <br/><br/>
        This functionality is not supported by ISO&nbsp;C.
        As such, it is only available on some platforms
        (Windows, Linux, Mac OS X, Solaris, BSD, plus other Unix systems
        that support the <code>dlfcn</code> standard).
        <br/><br/>
        This function is inherently insecure, as it allows Tokudae to call
        any function in any readable dynamic library in the system.
        (Tokudae calls any function assuming the function has a proper
        prototype and respects a proper protocol
        (see <a href="#toku_CFunction"><code>toku_CFunction</code></a>).
        Therefore, calling an arbitrary function in an arbitrary dynamic
        library more often than not results in an access violation.)
        </p>

        <hr><h3><a name="package.path"><code>package.path</code></a></h3>
        <p>
        A string with the path used by
        <a href="#import"><code>import</code></a> to search for a
        Tokudae loader.
        <br/><br/>
        At start-up, Tokudae initializes this variable with the value of the
        environment variable
        <a name="TOKU_PATH_1_0"><code>TOKU_PATH_1_0</code></a>
        or the environment variable
        <a name="TOKU_PATH"><code>TOKU_PATH</code></a>
        or with a default path defined in <code>tokudaeconf.h</code>,
        if those environment variables are not defined.
        A "<code>;;</code>" in the value of the environment variable is
        replaced by the default path.
        </p>

        <hr><h3><a name="package.preload"><code>package.preload</code></a></h3>
        <p>
        A table to store loaders for specific modules
        (see <a href="#import"><code>import</code></a>).
        <br/><br/>
        This variable is only a reference to the real table;
        assignments to this variable do not change the table used by
        <a href="#import"><code>import</code></a>.
        The real table is stored in the C table
        (see <a href="#4.3">&sect;4.3</a>), under the key
        <a name="TOKU_PRELOAD_TABLE"><code>TOKU_PRELOAD_TABLE</code></a>,
        a string.
        </p>

        <hr><h3><a name="package.searchers"><code>package.searchers</code></a></h3>
        <p>
        List used by <a href="#import"><code>import</code></a> to control
        how to find modules.
        <br/><br/>
        Each entry in this list is a <em>searcher function</em>.
        When looking for a module, <a href="#import"><code>import</code></a>
        calls each of these searchers in ascending order,
        with the module name
        (the argument given to <a href="#import"><code>import</code></a>)
        as its sole argument.
        If the searcher finds the module, it returns another function,
        the module <em>loader</em>, plus an extra value,
        a <em>loader data</em>, that will be passed to that loader and
        returned as a second result by
        <a href="#import"><code>import</code></a>.
        If it cannot find the module, it returns a string explaining why
        (or <b>nil</b> if it has nothing to say).
        <br/><br/>
        Tokudae initializes this list with four searcher functions.
        <br/><br/>
        The first searcher simply looks for a loader in the
        <a href="#package.preload"><code>package.preload</code></a> list.
        <br/><br/>
        The second searcher looks for a loader as a Tokudae library,
        using the path stored at
        <a href="#package.path"><code>package.path</code></a>.
        The search is done as described in function
        <a href="#package.searchpath"><code>package.searchpath</code></a>.
        <br/><br/>
        The third searcher looks for a loader as a C&nbsp;library,
        using the path given by the variable
        <a href="#package.cpath"><code>package.cpath</code></a>.
        Again, the search is done as described in function
        <a href="#package.searchpath"><code>package.searchpath</code></a>.
        For instance, if the C&nbsp;path is the string

        <pre>
    "./?.so;./?.dll;/usr/local/?/init.so"</pre>

        the searcher for module <code>foo</code> will try to open the files
        <code>./foo.so</code>, <code>./foo.dll</code>,
        and <code>/usr/local/foo/init.so</code>, in that order.
        Once it finds a C&nbsp;library, this searcher first uses a dynamic
        link facility to link the application with the library.
        Then it tries to find a C&nbsp;function inside the library to
        be used as the loader.
        The name of this C&nbsp;function is the string "<code>tokuopen_</code>"
        concatenated with a copy of the module name where each dot
        is replaced by an underscore.
        Moreover, if the module name has a hyphen, its suffix after
        (and including) the first hyphen is removed.
        For instance, if the module name is <code>a.b.c-v2.1</code>,
        the function name will be <code>tokuopen_a_b_c</code>.
        <br/><br/>
        The fourth searcher tries an <em>all-in-one loader</em>.
        It searches the C&nbsp;path for a library for the root name of the
        given module.
        For instance, when requiring <code>a.b.c</code>, it will search for
        a C&nbsp;library for <code>a</code>.
        If found, it looks into it for an open function for the submodule;
        in our example, that would be <code>tokuopen_a_b_c</code>.
        With this facility, a package can pack several C&nbsp;submodules
        into one single library, with each submodule keeping its original
        open function.
        <br/><br/>
        All searchers except the first one (preload) return as the extra
        value the file path where the module was found, as returned by
        <a href="#package.searchpath"><code>package.searchpath</code></a>.
        The first searcher always returns the string "<code>:preload:</code>".
        <br/><br/>
        Searchers should raise no errors and have no side effects in Tokudae.
        (They may have side effects in C, for instance by linking the
        application with a library.)
        </p>

        <hr><h3><a name="package.searchpath"><code>package.searchpath (name, path[, sep[, rep]])</code></a></h3>
        </p>
        Searches for the given <code>name</code>
        in the given <code>path</code>.
        <br/><br/>
        A path is a string containing a sequence of <em>templates</em>
        separated by semicolons.
        For each template, the function replaces each interrogation mark
        (if any) in the template with a copy of <code>name</code> wherein
        all occurrences of <code>sep</code> (a dot, by default) were replaced
        by <code>rep</code> (the system's directory separator, by default),
        and then tries to open the resulting file name.
        <br/><br/>
        For instance, if the path is the string

        <pre>
    "./?.csp;./?.lc;/usr/local/?/init.csp"</pre>

        the search for the name <code>foo.a</code> will try to open the
        files <code>./foo/a.csp</code>, <code>./foo/a.lc</code>, and
        <code>/usr/local/foo/a/init.csp</code>, in that order.
        <br/><br/>
        Returns the resulting name of the first file that it can open in read
        mode (after closing the file), or <b>fail</b> plus an error message
        if none succeeds.
        (This error message lists all file names it tried to open.)
        </p>


        <h2>6.4 &ndash; <a name="6.4">String Library</a></h2>
        <p>
        This library provides generic functions for string manipulation,
        such as finding and extracting substrings and other common operations.
        All of the functionality is provided in the global table 
        <a name="string"><code>string</code></a>.
        When indexing strings in Tokudae, the first character is at position
        &nbsp;0 (same as in C).
        Indices are allowed to be negative and are interpreted as indexing
        backwards, from the end of the string.
        Thus, the last character is at position -1, and so on.
        <br/><br/>
        The string library assumes one-byte character encodings.
        </p>

        <!-- string.split -->
        <hr/><h3><a name="string.split"><code>string.split (s[, sep[, maxsplit]])</code></a></h3>
        <p>
        Return list of the words in the string, using <code>sep</code>
        as the delimiter string.
        If <code>maxsplit</code> is given, at most <code>maxsplit</code>
        splits are done (thus, the list will have at most
        <code>maxsplit+1</code> elements).
        If <code>maxsplit</code> is not specified or is <b>nil</b>, then there
        is no limit on the number of splits (all possible splits are made).
        <br/>
        If <code>sep</code> is given, consecutive delimiters are not grouped
        together and are deemed to delimit empty strings.
        <br/>
        If <code>sep</code> is not specified or is <b>nil</b>, a different
        splitting algorithm is applied: runs of consecutive whitespace are
        regarded as a single separator, and the result will contain no empty
        strings at the start or end if the string has leading or trailing
        whitespace.
        Consequently, splitting an empty string or a string consisting of
        just whitespace without specified separator or a <b>nil</b> separator
        returns <code>[]</code> (an empty list).
        <details class="example">
            <summary>Example</summary>
            <pre>
/* consecutive "," delimiters are not grouped together */
local l = string.split("1,,2", ",");
assert(l.len == 3 and l[0] == "1" and l[1] == "" and l[2] == "2");

/* splitting an empty string using whitespace algorithm */
assert(string.split("").len == 0);

/* splitting an empty string with a specified separator */
l = string.split("", "asdc");
assert(l.len == 1 and l.x == "");

/* whitespace algorithm */
l = string.split(" 1  2   3  ");
assert(l.len == 3 and l.x == "1" and l.y == "2" and l.z == "3");

/* whitespace algorithm, 1 split limit */
l = string.split("  1  2   3  ", nil, 1);
assert(l.len == 2 and l[0] == "1" and l[1] == "2   3  ");</pre>
        </details>
        </p>

        <!-- string.rsplit -->
        <hr/><h3><a name="string.rsplit"><code>string.rsplit (s[, sep[, maxsplit]])</code></a></h3>
        <p>
        Similar to <a href="#string.split"><code>string.split</code></a>
        except this does the splitting in reverse, starting from the end
        of <code>s</code>.
        <details class="example">
            <summary>Example</summary>
            <pre>
/* use whitespace algorithm as no delimiter is provided */
local l = string.rsplit("a  b  c");
assert(l[0] == "c" and l[1] == "b" and l[2] == "a");

/* 2 splits limit */
l = string.rsplit("&lt;&gt;a &lt;&gt;bc&lt;&gt;dead ", "&lt;&gt;", 2);
assert(l.len == 3);
assert(l[0] == "dead " and l[1] == "bc" and l[2] == "&lt;&gt;a ");

/* 3 splits limit */
l = string.rsplit("&lt;&gt;a &lt;&gt;bc&lt;&gt;dead ", "&lt;&gt;", 3);
assert(l.len == 4);
assert(l[0] == "dead " and l[1] == "bc" and l[2] == "a " and l[3] == "");</pre>
        </details>
        </p>

        <!-- string.startswith -->
        <hr/><h3><a name="string.startswith"><code>string.startswith (s, prefix[, i[, j]])</code></a></h3>
        <p>
        Checks if the string <code>s</code> starts with the <code>prefix</code>
        string and it returns the index in <code>s</code> after the
        <code>prefix</code>.
        If the <code>prefix</code> is not the prefix of <code>s</code> this
        returns <b>fail</b> and the non-matching index in <code>s</code>.
        There are two optional arguments, start index to where to start the
        search from in <code>s</code>, and end index that specifies to
        stop comparing the string after that index.
        In case where start index <code>i</code> and end index <code>j</code>
        is specified and <code>i</code> is greater than <code>j</code> or the
        range between <code>i</code> and <code>j</code> is smaller than the
        length of <code>prefix</code> string, <b>fail</b> is returned
        (as usual) and -1 representing invalid index.
        <br/><br/>
        If <code>i</code> is not specified it is set to 0, if <code>j</code>
        is not specified, it is set to -1 (last index).
        <br/>
        If, after the translation of negative indices,
        <code>i</code> is less than 0, it is corrected to 0.
        <br/>
        If <code>j</code> is greater than the last index,
        it is corrected to that index.
        <details class="example">
            <summary>Example</summary>
            <pre>
local s = "This is a test string, used for testing, get it?";
local res, extra = string.startswith(s, "This");
assert(res == 4 and extra == nil);
res, extra = string.startswith(s, "This", 0, 3);
assert(res == 4 and extra == nil);
res, extra = string.startswith(s, "This", 0, -1);
assert(res == 4 and extra == nil);
res, extra = string.startswith(s, "it?", 45);
assert(res == 48 and extra == nil);
res, extra = string.startswith(s, "it?", 45, -1);
assert(res == 48 and extra == nil);
res, extra = string.startswith(s, "it?", 45, -2);
assert(res == nil and extra == -1);
res, extra = string.startswith(s, "his?");
assert(res == nil and extra == 0);
res, extra = string.startswith(s, "is a", 5);
assert(res == 9 and extra == nil);
res, extra = string.startswith(s, "is a", 5, 8);
assert(res == 9 and extra == nil);
res, extra = string.startswith(s, "is a", 5, 7);
assert(res == nil and extra == -1);
res, extra = string.startswith(s, "is a", 2, 1);
assert(res == nil and extra == -1);
res, extra = string.startswith(s, "");
assert(res == 0 and extra == nil);</pre>
        </details>
        </p>

        <!-- string.reverse -->
        <hr/><h3><a name="string.reverse"><code>string.reverse (s)</code></a></h3>
        <p>
        Returns reversed string <code>s</code>.
        <details class="example">
            <summary>Example</summary>
        <pre>
local s = "?ti teg ,gnitset rof desu ,gnirts tset a si sihT";
assert(string.reverse(s) == "This is a test string, used for testing, get it?");
assert(string.reverse("This is a test string, used for testing, get it?") == s);</pre>
        </details>
        </p>

        <!-- string.repeat -->
        <hr/><h3><a name="string.repeat"><code>string.repeat (s, n[, sep])</code></a></h3>
        <p>
        Returns string <code>s</code> that is repeated <code>n</code> times.
        Optional separator <code>sep</code> can be specified which will
        separate repeated string <code>s</code>.
        If <code>n</code> is less than 1, empty string will be returned.
        <details class="example">
            <summary>Example</summary>
        <pre>
local s = "RepeatMe";
assert(string.repeat(s, 1, " ") == "RepeatMe");
assert(string.repeat(s, 2, " ") == "RepeatMe RepeatMe");
assert(string.repeat(s, 3, " ") == "RepeatMe RepeatMe RepeatMe");
assert(string.repeat(s, 1, "#") == "RepeatMe");
assert(string.repeat(s, 2, "#") == "RepeatMe#RepeatMe");
assert(string.repeat(s, 3, "#") == "RepeatMe#RepeatMe#RepeatMe");
assert(string.repeat(s, -1, " ") == "");
assert(string.repeat(s, 0, " ") == "");
assert(string.repeat(s, 1, "") == "RepeatMe");
assert(string.repeat(s, 2, "") == "RepeatMeRepeatMe");
assert(string.repeat(s, 1) == "RepeatMe");
assert(string.repeat(s, 2) == "RepeatMeRepeatMe");
assert(len(string.repeat(s, 10000)) == len(s)*10000);</pre>
        </details>
        </p>

        <!-- string.join -->
        <hr/><h3><a name="string.join"><code>string.join (s, v)</code></a></h3>
        <p>
        Return a string which is the concatenation of the strings in the
        list or table <code>v</code>.
        The separator between elements is the string <code>s</code>.
        <details class="example">
            <summary>Example</summary>
            <pre>
local s = "<sep>";
local x = [ "420", "69", "1337" ];
assert(string.join(s, x) == "420<sep>69<sep>1337");
x = { x = "420", y = "69", z = "1377" };
assert(len(string.join(s, x)) == len("420<sep>69<sep>1337"));
assert(string.join(s, ["ok"]) == "ok");
assert(string.join(s, {a = "ok"}) == "ok");
assert(string.join(s, []) == "");
assert(string.join(s, {}) == "");</pre>
        </details>
        </p>

        <!-- string.fmt -->
        <hr/><h3><a name="string.fmt"><code>string.fmt (fmts, &middot;&middot;&middot;)</code></a></h3>
        <p>
        Returns a formatted version of its variable number of arguments
        following the description given in its first argument
        <code>fmts</code>, which must be a string.
        The format string follows the same rules as the ISO&nbsp;C function
        <code>sprintf</code>.
        The only differences are that the conversion specifiers and modifiers
        <code>F</code>, <code>n</code>, <code>*</code>, <code>h</code>,
        <code>L</code>, and <code>l</code> are not supported and that there
        is an extra specifier, <code>q</code>.
        Both width and precision, when present, are limited to two digits.
        <br/><br/>
        The specifier <code>q</code> formats booleans, nil, numbers, and
        strings in a way that the result is a valid constant in Tokudae
        source code.
        Booleans and nil are written in the obvious way
        (<code>true</code>, <code>false</code>, <code>nil</code>).
        Floats are written in hexadecimal,
        to preserve full precision.
        A string is written between double quotes,
        using escape sequences when necessary to ensure that
        it can safely be read back by the Tokudae interpreter.
        For instance, the call

        <pre>
    string.fmt('%q', "a string with \"quotes\" and \n new line")</pre>

        may produce the string:

        <pre>
    "a string with \"quotes\" and \
     new line"</pre>

        This specifier does not support modifiers (flags, width, precision).
        <br/><br/>
        The conversion specifiers
        <code>A</code>, <code>a</code>, <code>E</code>, <code>e</code>,
        <code>f</code>, <code>G</code>, and <code>g</code> all expect a
        number as argument.
        The specifiers <code>c</code>, <code>d</code>, <code>i</code>,
        <code>o</code>, <code>u</code>, <code>X</code>, and <code>x</code>
        expect an integer.
        <br/><br/>
        The specifier <code>s</code> expects a string;
        if its argument is not a string,
        it is converted to one following the same rules of
        <a href="#tostr"><code>tostr</code></a>.
        If the specifier has any modifier, the corresponding string argument
        should not contain embedded zeros.
        <br/><br/>
        The specifier <code>p</code> formats the pointer returned by
        <a href="#toku_to_pointer"><code>toku_to_pointer</code></a>.
        That gives a unique string identifier for tables, userdata,
        threads, strings, and functions.
        For other values (numbers, nil, booleans),
        this specifier results in a string representing
        the pointer <code>NULL</code>.
        <br/><br/>
        <details class="example">
            <summary>Example</summary>
            <pre>
{ /* %p */
    local fn topointer(s) return string.fmt("%p", s);
    local null = "(null)";
    assert(string.fmt("%p", 4) == null);
    assert(string.fmt("%p", inf) == null);
    assert(string.fmt("%p", infinity) == null);
    assert(string.fmt("%p", -inf) == null);
    assert(string.fmt("%p", -infinity) == null);
    assert(string.fmt("%p", true) == null);
    assert(string.fmt("%p", false) == null);
    assert(string.fmt("%p", nil) == null);
    assert(string.fmt("%p", {}) != null);
    assert(string.fmt("%p", []) != null);
    assert(string.fmt("%p", class {}) != null);
    assert(string.fmt("%p", fn (){}) != null);
    assert(string.fmt("%p", print) != null);
    assert(string.fmt("%p", topointer) != null);
    assert(string.fmt("%p", print) == string.fmt("%p", print));
    assert(string.fmt("%p", print) != string.fmt("%p", assert));
}

{ /* %q + %s */
    local x = "\"ílo\"\n\\";
    assert(string.fmt("%q%s", x, x) == "\"\\\"ílo\\\"\\\n\\\\\"\"ílo\"\n\\");
    assert(string.fmt("%q", "\0") == "\"\\0\"");
    assert(load(string.fmt("return %q;", x))() == x);
}

{ /* %f */
    assert(10**38 &lt; inf);
    s = string.fmt("%.99f", -(10**38));
    assert(len(s) &gt;= 38 + 101);
    assert(tonum(s) == -(10**38));
}

{ /* %x + %d + %u + %o */
    local max, min = 0x7fffffff, -0x80000000;
    assert(string.substr(string.fmt("%8x", -1), -8) == "ffffffff");
    assert(string.fmt("%x", max) == "7fffffff");
    assert(string.substr(string.fmt("%x", min), -8) == "80000000");
    assert(string.fmt("%d", max) ==  "2147483647");
    assert(string.fmt("%d", min) == "-2147483648");
    assert(string.fmt("%u", 0xffffffff) == "4294967295");
    assert(string.fmt("%o", 0xABCD) == "125715");
}

{ /* %a + %A */
    assert(string.find(string.fmt("%a", 1/0), "inf"));
    assert(string.find(string.fmt("%A", -1/0), "-INF"));
    assert(string.find(string.fmt("%a", 0/0), "nan"));
    assert(string.find(string.fmt("%a", -0.0), "-0x0"));
}

{ /* other flags */
    assert(string.fmt("%#12o", 10) == "         012");
    assert(string.fmt("%#10x", 100) == "      0x64");
    assert(string.fmt("%#-17X", 100) == "0X64             ");
    assert(string.fmt("%013i", -100) == "-000000000100");
    assert(string.fmt("%2.5d", -100) == "-00100");
    assert(string.fmt("%.u", 0) == "");
    assert(string.fmt("%+#014.0f", 100) == "+000000000100.");
    assert(string.fmt("%-16c", 97) == "a               ");
    assert(string.fmt("%+.3G", 1.5) == "+1.5");
    assert(string.fmt("%.0s", "alo")  == "");
    assert(string.fmt("%.s", "alo")  == "");
}

{ /* errors in format */
    local fn checkerror(msg, f, ...) {
        local s, err = pcall(f, ...);
        assert(!s and string.find(err, msg));
    }

    local fn check(fmt, msg)
        checkerror(msg, string.fmt, fmt, 10);

    local aux = string.repeat("0", 600);
    check("%100.3d", "invalid conversion");
    check("%1"..aux..".3d", "too long");
    check("%1.100d", "invalid conversion");
    check("%10.1"..aux.."004d", "too long");
    check("%t", "invalid conversion");
    check("%"..aux.."d", "too long");
    check("%d %d", "missing format value");
    check("%010c", "invalid conversion");
    check("%.10c", "invalid conversion");
    check("%0.34s", "invalid conversion");
    check("%#i", "invalid conversion");
    check("%3.1p", "invalid conversion");
    check("%0.s", "invalid conversion");
    check("%10q", "cannot have modifiers");
    check("%F", "invalid conversion");
}</pre>
        </details>
        </p>

        <!-- string.toupper -->
        <hr/><h3><a name="string.toupper"><code>string.toupper (s[, i[, j]])</code></a></h3>
        <p>
        Returns string <code>s</code> which has all its characters converted
        to uppercase.
        Start index <code>i</code> and end index <code>j</code> can be
        specified to define range of the operation.
        <br/><br/>
        If <code>i</code> is not specified it is set to 0, if <code>j</code>
        is not specified, it is set to -1 (last index).
        <br/>
        If, after the translation of negative indices,
        <code>i</code> is less than 0, it is corrected to 0.
        <br/>
        If, after these corrections, <code>i</code> is greater than
        <code>j</code>, this function returns <code>s</code>.
        <details class="example">
            <summary>Example</summary>
            <pre>
local s = "This is a test string, used for testing, get it?";
assert(string.toupper(s) == "THIS IS A TEST STRING, USED FOR TESTING, GET IT?");
local x = "THIS IS A TEST STRING, USED FOR TESTING, GET IT?";
assert(string.toupper(x) == "THIS IS A TEST STRING, USED FOR TESTING, GET IT?");
assert(string.toupper(s, 4) == "This IS A TEST STRING, USED FOR TESTING, GET IT?");
assert(string.toupper(s, 4, 2) == "This is a test string, used for testing, get it?");
assert(string.toupper(s, 4, 2) == "This is a test string, used for testing, get it?");
assert(string.toupper(s, 0, -1) == "THIS IS A TEST STRING, USED FOR TESTING, GET IT?");
assert(string.toupper(s, 4, -1) == "This IS A TEST STRING, USED FOR TESTING, GET IT?");
assert(string.toupper(s, 4, -8) == "This IS A TEST STRING, USED FOR TESTING, get it?");
assert(string.toupper(s, 4, -100) == "This is a test string, used for testing, get it?");
assert(string.toupper("this", 0, -100) == "this");
assert(string.toupper("this", 1, -100) == "this");
assert(string.toupper("this", -2) == "thIS");
assert(string.toupper("this", -2, -2) == "thIs");
assert(string.toupper("this", -10, -2) == "THIs");</pre>
        </details>
        </p>

        <!-- string.tolower -->
        <hr/><h3><a name="string.tolower"><code>string.tolower (s[, i[, j]])</code></a></h3>
        <p>
        Returns string <code>s</code> which has all its characters converted
        to lowercase.
        Start index <code>i</code> and end index <code>j</code> can be
        specified to define range of the operation.
        <br/><br/>
        If <code>i</code> is not specified it is set to 0, if <code>j</code>
        is not specified, it is set to -1 (last index).
        <br/>
        If, after the translation of negative indices,
        <code>i</code> is less than 0, it is corrected to 0.
        <br/>
        If, after these corrections, <code>i</code> is greater than
        <code>j</code>, this function returns <code>s</code>.
        <details class="example">
            <summary>Example</summary>
            <pre>
local s = "THIS IS A TEST STRING, USED FOR TESTING, GET IT?";
assert(string.tolower(s) == "this is a test string, used for testing, get it?");
local x = "this is a test string, used for testing, get it?";
assert(string.tolower(x) == "this is a test string, used for testing, get it?");
assert(string.tolower(s, 4) == "THIS is a test string, used for testing, get it?");
assert(string.tolower(s, 4, 2) == "THIS IS A TEST STRING, USED FOR TESTING, GET IT?");
assert(string.tolower(s, 4, 2) == "THIS IS A TEST STRING, USED FOR TESTING, GET IT?");
assert(string.tolower(s, 0, -1) == "this is a test string, used for testing, get it?");
assert(string.tolower(s, 4, -1) == "THIS is a test string, used for testing, get it?");
assert(string.tolower(s, 4, -8) == "THIS is a test string, used for testing, GET IT?");
assert(string.tolower(s, 4, -100) == "THIS IS A TEST STRING, USED FOR TESTING, GET IT?");
assert(string.tolower("THIS", 0, -100) == "THIS");
assert(string.tolower("THIS", 1, -100) == "THIS");
assert(string.tolower("THIS", -2) == "THis");
assert(string.tolower("THIS", -2, -2) == "THiS");
assert(string.tolower("THIS", -10, -2) == "thiS");</pre>
        </details>
        </p>

        <!-- string.find -->
        <hr/><h3><a name="string.find"><code>string.find (s, sub[, i[, j]])</code></a></h3>
        <p>
        Return the lowest index in the string <code>s</code> where substring
        <code>sub</code> is found, such that <code>sub</code> is contained in
        the slice s[i:j].
        Optional arguments <code>i</code> and <code>j</code> are interpreted
        as in slice notation. Return <b>fail</b> if <code>sub</code> is not
        found.
        <br/><br/>
        If <code>i</code> is not specified it is set to 0, if <code>j</code>
        is not specified, it is set to -1 (last index).
        <br/>
        If, after the translation of negative indices,
        <code>i</code> is less than 0, it is corrected to 0.
        <details class="example">
            <summary>Example</summary>
            <pre>
local s = "Find cat, if the cat is in this string, then cat shall be found, cat.";
local i = string.find(s, "cat");
assert(i == 5);
i = string.find(s, "cat", i+1);
assert(i == 17);
i = string.find(s, "cat", i+1);
assert(i == 45);
i = string.find(s, "cat", i+1);
assert(i == 65);
i = string.find(s, "cat", i+1);
assert(i == nil);
i = string.find(s, "cat", 6);
assert(i == 17);
i = string.find(s, "cat", 6, 7);
assert(i == nil);
i = string.find(s, "cat", 5, 7);
assert(i == 5);
i = string.find(s, "cat", 6, -1);
assert(i == 17);
i = string.find(s, "cat", 6, -51);
assert(i == nil);
i = string.find(s, "cat", 6, -50);
assert(i == 17);
i = string.find(s, "cat", i+1, -i);
assert(i == 45);
i = string.find(s, "cat", i+1, -i);
assert(i == nil);
assert(string.find("cat", "cats") == nil);
assert(string.find("cat", "") == 0);</pre>
        </details>
        </p>

        <!-- string.rfind -->
        <hr/><h3><a name="string.rfind"><code>string.rfind (s, sub[, i[, j]])</code></a></h3>
        <p>
        Similar to <a href="#string.find"><code>string.find</code></a>,
        except the search for <code>sub</code> is done in reverse.
        <details class="example">
            <summary>Example</summary>
            <pre>
local s = "Find cat, if the cat is in this string, then cat shall be found, cat.";
local i = string.rfind(s, "cat");
assert(i == 65);
i = string.rfind(s, "cat", 0, i-1);
assert(i == 45);
i = string.rfind(s, "cat", 0, i-1);
assert(i == 17);
i = string.rfind(s, "cat", 0, i-1);
assert(i == 5);
i = string.rfind(s, "cat", 0, i-1);
assert(i == nil);
i = string.rfind(s, "cat", 0, -4);
assert(i == 45);
i = string.rfind(s, "cat", 6, 7);
assert(i == nil);
i = string.rfind(s, "cat", 5, 7);
assert(i == 5);
i = string.rfind(s, "cat", 0, -6);
assert(i == 45);
i = string.rfind(s, "cat", 6, -51);
assert(i == nil);
i = string.rfind(s, "cat", 6, -50);
assert(i == 17);
i = string.rfind(s, "cat", i+1, -i);
assert(i == 45);
i = string.rfind(s, "cat", i+1, -i);
assert(i == nil);
assert(string.rfind("cat", "cats") == nil);
assert(string.rfind("cat", "") == 0);</pre>
        </details>
        </p>

        <!-- string.span -->
        <hr/><h3><a name="string.span"><code>string.span (s, accept[, i[, j]])</code></a></h3>
        <p>
        Returns the length of the initial segment of string <code>s</code>
        which consists entirely of bytes in the string <code>accept</code>.
        There are two optional arguments, the start index <code>i</code> which
        is the index where the string <code>s</code> starts, and end index
        <code>j</code> which defines where the string <code>s</code> ends.
        This returns fail if index <code>i</code> is greater than index
        <code>j</code>.
        <br/><br/>
        If <code>i</code> is not specified it is set to 0, if <code>j</code>
        is not specified, it is set to -1 (last index).
        <br/>
        If, after the translation of negative indices,
        <code>i</code> is less than 0, it is corrected to 0.
        <details class="example">
            <summary>Example</summary>
            <pre>
local s = "What is your favorite animal?";
assert(string.span(s, "tahwW siyorufv") == 20);
assert(string.span(s, "tahwW syorufv") == 5);
assert(string.span(s, "animal") == 0);

assert(string.span(s, "") == 0);
assert(string.span(s, "What isyourfvtenml?") == len(s));
assert(string.span(s, string.ascii_lowercase) == 0);
assert(string.span(s, string.ascii_uppercase) == 1);
assert(string.span(s, string.ascii_letters) == 4);
assert(string.span(s, string.ascii_letters .. " ") == len(s) - 1);
assert(string.span(s, string.ascii_letters .. " ?") == len(s));

assert(string.span(s, "What ", 3) == 2);
assert(string.span(s, "What ", 2, 3) == 2);
assert(string.span(s, "What ", 2, 2) == 1);
assert(string.span(s, "What ", 2, 1) == nil);
assert(string.span(s, "What ", nil, -(len(s)) - 1) == nil);</pre>
        </details>
        </p>

        <!-- string.cspan -->
        <hr/><h3><a name="string.cspan"><code>string.cspan (s, reject[, i[, j]])</code></a></h3>
        <p>
        Similar to <a href="#string.span"><code>string.span</code></a>,
        except this returns the length of the initial segment which consists
        entirely of bytes <b>not</b> in the string <code>reject</code>.
        <details class="example">
            <summary>Example</summary>
            <pre>
local s = "What is your favorite animal?";
assert(string.cspan(s, "siroy") == 5);
assert(string.cspan(s, "sroy") == 6);
assert(string.cspan(s, "roy") == 8);
assert(string.cspan(s, "ro") == 9);
assert(string.cspan(s, "r") == 11);

assert(string.cspan(s, "") == len(s));
assert(string.cspan(s, "x") == len(s));

assert(string.cspan(s, "a", 3) == 11);
assert(string.cspan(s, "a", 2, 3) == 0);
assert(string.cspan(s, "a", 1, 2) == 1);
assert(string.cspan(s, "a", 2, 1) == nil);
assert(string.cspan(s, "a", nil, -(len(s)) - 1) == nil);</pre>
        </details>
        </p>

        <!-- string.replace -->
        <hr/><h3><a name="string.replace"><code>string.replace (s, sub, new[, n])</code></a></h3>
        <p>
        Return a copy of the string <code>s</code> with all occurrences of
        substring <code>sub</code> replaced by <code>new</code>.
        If the optional argument <code>n</code> is given, only the first
        <code>n</code> occurrences are replaced.
        <details class="example">
            <summary>Example</summary>
            <pre>
local s = "<this> many people, <this> many houses";
s = string.replace(s, "<this>", "how");
assert("how many people, how many houses" == s);
s = string.replace(s, "how many", "what are");
assert("what are people, what are houses" == s);
s = string.replace(s, "what are", "how many", 1);
assert("how many people, what are houses" == s);
assert(string.replace(s, "how many", "what are", 0) == s);
assert(string.replace(s, "how many", "what are", -1) == s);
assert(string.replace(s, "", "return this") == "return this");</pre>
        </details>
        </p>

        <!-- string.substr -->
        <hr/><h3><a name="string.substr"><code>string.substr (s[, i[, j[, abs]]])</code></a></h3>
        <p>
        Returns the substring of <code>s</code> that starts at <code>i</code>
        and continues up to (including) <code>j</code>.
        Lastly, if the optional parameter <code>abs</code> is not <b>nil</b>,
        then the optional indices <code>i</code> and <code>j</code> must
        be absolute, if they are not, this returns an empty string
        (<code>""</code>).
        <br/><br/>
        If <code>i</code> is not specified it is set to 0, if <code>j</code>
        is not specified, it is set to -1 (last index).
        <br/>
        If, after the translation of negative indices,
        <code>i</code> is less than 0, it is corrected to 0.
        <br/>
        If, after these corrections, <code>i</code> is greater than
        <code>j</code>, the function returns the empty string.
        <details class="example">
            <summary>Example</summary>
            <pre>
local s = "A whole string";
assert(string.substr(s, 0) == "A whole string");
assert(string.substr(s, 1) == " whole string");
assert(string.substr(s, 13) == "g");
assert(string.substr(s, 14) == "");
assert(string.substr(s, 15) == "");
assert(string.substr(s, 0, -1) == "A whole string");
assert(string.substr(s, 0, -2) == "A whole strin");
assert(string.substr(s, 0, -3) == "A whole stri");
assert(string.substr(s, 0, -13) == "A ");
assert(string.substr(s, 0, -14) == "A");
assert(string.substr(s, 0, -15) == "");
assert(string.substr(s, 1, 0) == "");
assert(string.substr(s, 2, 4) == "who");</pre>
        </details>
        </p>

        <!-- string.swapcase -->
        <hr/><h3><a name="string.swapcase"><code>string.swapcase (s[, i[, j]])</code></a></h3>
        <p>
        Swaps case of characters of string <code>s</code> in range starting
        from index <code>i</code> up to (including) <code>j</code>.
        <br/><br/>
        If <code>i</code> is not specified it is set to 0, if <code>j</code>
        is not specified, it is set to -1 (last index).
        <br/>
        If, after the translation of negative indices,
        <code>i</code> is less than 0, it is corrected to 0.
        <br/>
        If, after these corrections, <code>i</code> is greater than
        <code>j</code>, the function returns <code>s</code>.
        <details class="example">
            <summary>Example</summary>
            <pre>
local s = "SwAp CaSe";
assert(string.swapcase(s) == "sWaP cAsE");
assert(string.swapcase(s, 0) == "sWaP cAsE");
assert(string.swapcase(s, 0, -1) == "sWaP cAsE");
assert(string.swapcase(s, 4, -1) == "SwAp cAsE");
assert(string.swapcase(s, 4, 3) == "SwAp CaSe");
assert(string.swapcase("") == "");
assert(string.swapcase(s, 4, -2) == "SwAp cAse");
assert(string.swapcase("A") == "a");
assert(string.swapcase("a") == "A");
assert(string.swapcase("ab") == "AB");
assert(string.swapcase("AB") == "ab");
assert(string.swapcase("a", 1) == "a");</pre>
        </details>
        </p>

        <!-- string.swapupper -->
        <hr/><h3><a name="string.swapupper"><code>string.swapupper (s[, i[, j]])</code></a></h3>
        <p>
        Swaps lowercase characters to uppercase of string <code>s</code> in
        range starting from index <code>i</code> up to (including)
        <code>j</code>.
        <br/><br/>
        If <code>i</code> is not specified it is set to 0, if <code>j</code>
        is not specified, it is set to -1 (last index).
        <br/>
        If, after the translation of negative indices,
        <code>i</code> is less than 0, it is corrected to 0.
        <br/>
        If, after these corrections, <code>i</code> is greater than
        <code>j</code>, the function returns <code>s</code>.
        <details class="example">
            <summary>Example</summary>
            <pre>
local s = "SwAp CaSe";
assert(string.swapupper(s) == "swap case");
assert(string.swapupper(s, 0) == "swap case");
assert(string.swapupper(s, 0, -1) == "swap case");
assert(string.swapupper(s, 4, -1) == "SwAp case");
assert(string.swapupper(s, 4, 3) == "SwAp CaSe");
assert(string.swapupper("") == "");
assert(string.swapupper(s, 4, -2) == "SwAp case");
assert(string.swapupper("A") == "a");
assert(string.swapupper("A", 0, -1) == "a");
assert(string.swapupper("a") == "a");
assert(string.swapupper("a", 0, -1) == "a");
assert(string.swapupper("ab") == "ab");
assert(string.swapupper("AB") == "ab");
assert(string.swapupper("A", 1) == "A");</pre>
        </details>
        </p>

        <!-- string.swaplower -->
        <hr/><h3><a name="string.swaplower"><code>string.swaplower (s[, i[, j]])</code></a></h3>
        <p>
        Swaps uppercase characters to lowercase of string <code>s</code> in
        range starting from index <code>i</code> up to (including)
        <code>j</code>.
        <br/><br/>
        If <code>i</code> is not specified it is set to 0, if <code>j</code>
        is not specified, it is set to -1 (last index).
        <br/>
        If, after the translation of negative indices,
        <code>i</code> is less than 0, it is corrected to 0.
        <br/>
        If, after these corrections, <code>i</code> is greater than
        <code>j</code>, the function returns <code>s</code>.
        <details class="example">
            <summary>Example</summary>
            <pre>
local s = "SwAp CaSe";
assert(string.swaplower(s) == "SWAP CASE");
assert(string.swaplower(s, 0) == "SWAP CASE");
assert(string.swaplower(s, 0, -1) == "SWAP CASE");
assert(string.swaplower(s, 4, -1) == "SwAp CASE");
assert(string.swaplower(s, 4, 3) == "SwAp CaSe");
assert(string.swaplower("") == "");
assert(string.swaplower(s, 4, -2) == "SwAp CASe");
assert(string.swaplower("A") == "A");
assert(string.swaplower("A", 0, -1) == "A");
assert(string.swaplower("a") == "A");
assert(string.swaplower("a", 0, -1) == "A");
assert(string.swaplower("ab") == "AB");
assert(string.swaplower("AB") == "AB");
assert(string.swaplower("A", 1) == "A");
assert(string.swaplower("a", 1) == "a");</pre>
        </details>
        </p>

        <!-- string.byte -->
        <hr/><h3><a name="string.byte"><code>string.byte (s[, i[, j]])</code></a></h3>
        <p>
        Returns the internal numeric codes of the characters
        <code>s[i]</code>, <code>s[i+1]</code>, ..., <code>s[j]</code>.
        <br/><br/>
        The default value for <code>i</code> is&nbsp;0;
        the default value for <code>j</code> is&nbsp;i.
        <br/>
        If, after the translation of negative indices,
        <code>i</code> is less than 0, it is corrected to 0.
        <br/>
        If, after these corrections, <code>i</code> is greater than
        <code>j</code>, or the string <code>s</code> is empty,
        the function will not return any results.
        <details class="example">
            <summary>Example</summary>
            <pre>
local a, b, c, d, e, f = string.byte("Hello", 0, -1);
assert(a == 'H');
assert(b == 'e');
assert(c == 'l');
assert(d == 'l');
assert(e == 'o');
assert(f == nil);

a, b, c = string.byte("World", 1, -3);
assert(a == 'o');
assert(b == 'r');
assert(c == nil);

assert(string.byte("") == nil);
assert(string.byte("a", 2) == nil);
assert(string.byte("a") == 'a');

a, b = string.byte("ab");
assert(a == 'a');
assert(b == nil);</pre>
        </details>
        </p>

        <!-- string.bytes -->
        <hr/><h3><a name="string.bytes"><code>string.bytes (s[, i[, j]])</code></a></h3>
        <p>
        Similar to <a href="#string.byte"><code>string.byte</code></a>,
        except this returns results in a list.
        <details class="example">
            <summary>Example</summary>
            <pre>
local a = string.bytes("Hello");
assert(len(a) == 5);
assert(a[0] == 'H');
assert(a[1] == 'e');
assert(a[2] == 'l');
assert(a[3] == 'l');
assert(a[4] == 'o');
assert(a[5] == nil);

a = string.bytes("World", 1, -3);
assert(len(a) == 2);
assert(a[0] == 'o');
assert(a[1] == 'r');
assert(a[2] == nil);

assert(string.bytes("") == nil);
assert(string.bytes("a", 2) == nil);</pre>
        </details>
        </p>

        <!-- string.char -->
        <hr/><h3><a name="string.char"><code>string.char (&middot;&middot;&middot;)</code></a></h3>
        <p>
        Receives zero or more integers.
        Returns a string with length equal to the number of arguments,
        in which each character has the internal numeric code equal
        to its corresponding argument.
        <br/><br/>
        Numeric codes are not necessarily portable across platforms.
        <details class="example">
            <summary>Example</summary>
            <pre>
local char = string.char;
local s = char('H','e','l','l','o',' ','W','o','r','l','d','!');
assert(s and s == "Hello World!");
assert(s == char(0x48,0x65,0x6C,0x6C,0x6F,0x20,0x57,0x6F,0x72,0x6C,0x64,0x21));
assert(char() == "");

/* out of range errors */
local fn checkerr(msg, f, ...) {
    st, err = pcall(f, ...);
    assert(!st and string.find(err, msg));
}
checkerr("out of range", char, 256);
checkerr("out of range", char, 0x100);
checkerr("out of range", char, -1);</pre>
        </details>
        </p>

        <!-- string.cmp -->
        <hr/><h3><a name="string.cmp"><code>string.cmp (s1, s2)</code></a></h3>
        <p>
        Compares strings <code>s1</code> and <code>s2</code> and returns a
        negative integer if <code>s1 &lt; s2</code>, a positive integer
        if <code>s1 &gt; s2</code>, or 0 if both strings are equal.
        Additionally if the strings are not equal, this returns additional
        result, which is the number of bytes equal in both <code>s1</code>
        and <code>s2</code> starting from position 0 (from the start).
        <details class="example">
            <summary>Example</summary>
            <pre>
local s1 = "\0\0blabla,\0what Ever\0*[]";
local s2 = "\0\0blabla,\0what Ever\0*[]";
assert(s1 == s2);
local res, pos = string.cmp(s1, s2);
assert(res == 0 and !pos);
res, pos = string.cmp(s1, "\0\0blabla,\0what Ever\0*[");
assert(res &gt; 0  and pos == 22);
res, pos = string.cmp(s1, "A");
assert(res &lt; 0 and pos == 0);</pre>
        </details>
        </p>

        <!-- string.dump -->
        <hr/><h3><a name="string.dump"><code>string.dump (function[, strip])</code></a></h3>
        <p>
        Returns a string containing a binary representation
        (a <em>binary chunk</em>) of the given function,
        so that a later <a href="#load"><code>load</code></a> on this string
        returns a copy of the function (but with new upvalues).
        If <code>strip</code> is a true value,
        the binary representation may not include all debug information
        about the function, to save space.
        <br/><br/>
        Functions with upvalues have only their number of upvalues saved.
        When (re)loaded, those upvalues receive fresh instances.
        (See the <a href="#load"><code>load</code></a> function for details
        about how these upvalues are initialized.
        You can use the debug library to serialize and reload the upvalues
        of a function in a way adequate to your needs.)
        <details class="example">
            <summary>Example</summary>
            <pre>
local fn add(x,y) :: return x + y;

/// dump the 'add' function and strip debug information
local f = string.dump(add, true);
assert(load(f)(2,2) == 4);

/// no debug information
assert(debug.getlocal(load(f), 1) == nil);</pre>
        </details>
        </p>

        <!-- string.pack -->
        <hr/><h3><a name="string.pack"><code>string.pack (fmt, v1, v2, &middot;&middot;&middot;)</code></a></h3>
        <p>
        Returns a binary string containing the values
        <code>v1</code>, <code>v2</code>, etc.
        serialized in binary form (packed) according to the format string
        <code>fmt</code> (see <a href="#6.4.1">&sect;6.4.1</a>).
        <br/><br/>
        For example see <a href="#string.unpack"><code>string.unpack</code></a>.
        </p>

        <!-- string.pack -->
        <hr/><h3><a name="string.packsize"><code>string.packsize (fmt)</code></a></h3>
        <p>
        Returns the length of a string resulting from
        <a href="#string.pack"><code>string.pack</code></a>
        with the given format.
        The format string cannot have the variable-length options
        '<code>s</code>' or '<code>z</code>'
        (see <a href="#6.4.1">&sect;6.4.1</a>).
        <details class="example">
            <summary>Example</summary>
            <pre>
local sizeshort = packsize("h");
local sizeint = packsize("i");
local sizelong = packsize("l");
local sizesize_t = packsize("T");
local sizeTI = packsize("j");
local sizefloat = packsize("f");
local sizedouble = packsize("d");
local sizenumber = packsize("n");
local little = (pack("i2", 1) == "\1\0");
local align = packsize("!xXi16");</pre>
        </details>
        </p>

        <!-- string.unpack -->
        <hr/><h3><a name="string.unpack"><code>string.unpack (fmt, s[, pos])</code></a></h3>
        <p>
        Returns the values packed in string <code>s</code>
        (see <a href="#string.pack"><code>string.pack</code></a>)
        according to the format string <code>fmt</code>
        (see <a href="#6.4.1">&sect;6.4.1</a>).
        An optional <code>pos</code> marks where to start reading in
        <code>s</code> (default is 0).
        After the read values, this function also returns the index of the
        first unread byte in <code>s</code>.
        <details class="example">
            <summary>Example</summary>
            <pre>
assert(string.unpack("B", string.pack("B", 0xff)) == 0xff);
assert(string.unpack("b", string.pack("b", 0x7f)) == 0x7f);
assert(string.unpack("b", string.pack("b", -0x80)) == -0x80);

assert(string.unpack("H", string.pack("H", 0xffff)) == 0xffff);
assert(string.unpack("h", string.pack("h", 0x7fff)) == 0x7fff);
assert(string.unpack("h", string.pack("h", -0x8000)) == -0x8000);

assert(string.unpack("L", string.pack("L", 0xffffffff)) == 0xffffffff);
assert(string.unpack("l", string.pack("l", 0x7fffffff)) == 0x7fffffff);
assert(string.unpack("l", string.pack("l", -0x80000000)) == -0x80000000);

assert(string.pack("&gt;i2 &lt;i2", 10, 20) == "\0\10\20\0");
local a, b, c = string.unpack("&lt;i2 &gt;i2", "\10\0\0\20");
assert(a == 10 and b == 20 and c == 4);

a, b, c = string.unpack("!4 z c3", "abcdefghi\0xyz");
assert(a == "abcdefghi" and b == "xyz" and c == 13);</pre>
        </details>
        </p>

        <!-- string.ascii_uppercase -->
        <hr/><h3><a name="string.ascii_uppercase"><code>string.ascii_uppercase</code></a></h3>
        <p>
        A string <code>"ABCDEFGHIJKLMNOPQRSTUVWXYZ"</code>.
        </p>

        <!-- string.ascii_lowercase -->
        <hr/><h3><a name="string.ascii_lowercase"><code>string.ascii_lowercase</code></a></h3>
        <p>
        A string <code>"abcdefghijklmnopqrstuvwxyz"</code>.
        </p>

        <!-- string.ascii_letters -->
        <hr/><h3><a name="string.ascii_letters"><code>string.ascii_letters</code></a></h3>
        <p>
        A string that is concatenation of
        <a href="#string.ascii_uppercase"><code>string.ascii_uppercase</code></a>
        and
        <a href="#string.ascii_lowercase"><code>string.ascii_lowercase</code></a>,
        in that order.
        </p>

        <!-- string.octdigits -->
        <hr/><h3><a name="string.octdigits"><code>string.octdigits</code></a></h3>
        <p>
        A string <code>"01234567"</code>.
        </p>

        <!-- string.digits -->
        <hr/><h3><a name="string.digits"><code>string.digits</code></a></h3>
        <p>
        A string that is concatenation of
        <a href="#string.octdigits"><code>string.octdigits</code></a> and
        a string <code>"89"</code>, in that order.
        </p>

        <!-- string.hexdigits -->
        <hr/><h3><a name="string.hexdigits"><code>string.hexdigits</code></a></h3>
        <p>
        A string that is concatenation of
        <a href="#string.digits"><code>string.digits</code></a> and
        a string <code>"abcdef"</code>, in that order.
        </p>

        <!-- string.punctuation -->
        <hr/><h3><a name="string.punctuation"><code>string.punctuation</code></a></h3>
        <p>
        A string <code>"!\"#$%&amp;'()*+,-./:;&lt;=&gt;?@[\\]^_`{|}~"</code>.
        </p>

        <!-- string.whitespace -->
        <hr/><h3><a name="string.whitespace"><code>string.whitespace</code></a></h3>
        <p>
        A string <code>" \t\n\r\v\f"</code>.
        </p>

        <!-- string.printable -->
        <hr/><h3><a name="string.printable"><code>string.printable</code></a></h3>
        <p>
        A string that is concatenation of
        <a href="#string.digits"><code>string.digits</code></a>,
        <a href="#string.ascii_letters"><code>string.ascii_letters</code></a>,
        <a href="#string.punctuation"><code>string.punctuation</code></a> and
        <a href="#string.whitespace"><code>string.whitespace</code></a>,
        in that order.
        </p>


        <h2>6.4.1 &ndash; <a name="6.4.1">Format Strings for Pack and Unpack</a></h2>
        <p>
        The first argument to
        <a href="#string.pack"><code>string.pack</code></a>,
        <a href="#string.packsize"><code>string.packsize</code></a>,
        and <a href="#string.unpack"><code>string.unpack</code></a>
        is a format string, which describes the layout of the structure
        being created or read.
        <br/><br/>
        A format string is a sequence of conversion options.
        The conversion options are as follows:
        <ul>
            <li><b><code>&lt;</code></b>: sets little endian</li>
            <li><b><code>&gt;</code></b>: sets big endian</li>
            <li><b><code>=</code></b>: sets native endian</li>
            <li>
                <b><code>![<em>n</em>]</code></b>:
                sets maximum alignment to <code>n</code>
                (default is native alignment)
            </li>
            <li><b><code>b</code></b>: a signed byte (<code>char</code>)</li>
            <li><b><code>B</code></b>: an unsigned byte (<code>char</code>)</li>
            <li><b><code>h</code></b>: a signed <code>short</code> (native size)</li>
            <li><b><code>H</code></b>: an unsigned <code>short</code> (native size)</li>
            <li><b><code>l</code></b>: a signed <code>long</code> (native size)</li>
            <li><b><code>L</code></b>: an unsigned <code>long</code> (native size)</li>
            <li><b><code>j</code></b>: a <code>toku_Integer</code></li>
            <li><b><code>J</code></b>: a <code>toku_Unsigned</code></li>
            <li><b><code>T</code></b>: a <code>size_t</code> (native size)</li>
            <li>
                <b><code>i[<em>n</em>]</code></b>:
                a signed <code>int</code> with <code>n</code> bytes
                (default is native size)
            </li>
            <li>
                <b><code>I[<em>n</em>]</code></b>:
                an unsigned <code>int</code> with <code>n</code> bytes
                (default is native size)
            </li>
            <li><b><code>f</code></b>: a <code>float</code> (native size)</li>
            <li><b><code>d</code></b>: a <code>double</code> (native size)</li>
            <li><b><code>n</code></b>: a <code>toku_Number</code></li>
            <li>
                <b><code>c<em>n</em></code></b>:
                a fixed-sized string with <code>n</code> bytes
            </li>
            <li><b><code>z</code></b>: a zero-terminated string</li>
            <li>
                <b><code>s[<em>n</em>]</code></b>:
                a string preceded by its length coded as an unsigned integer
                with <code>n</code> bytes (default is a <code>size_t</code>)
            </li>
            <li><b><code>x</code></b>: one byte of padding</li>
            <li>
                <b><code>X<em>op</em></code></b>:
                an empty item that aligns according to option <code>op</code>
                (which is otherwise ignored)
            </li>
            <li><b>'<code> </code>'</b>: (space) ignored</li>
        </ul>
        (A "<code>[<em>n</em>]</code>" means an optional integral numeral.)
        Except for padding, spaces, and configurations
        (options "<code>xX &lt;=&gt;!</code>"),
        each option corresponds to an argument in
        <a href="#string.pack"><code>string.pack</code></a>
        or a result in
        <a href="#string.unpack"><code>string.unpack</code></a>.
        <br/><br/>
        For options "<code>!<em>n</em></code>", "<code>s<em>n</em></code>",
        "<code>i<em>n</em></code>", and "<code>I<em>n</em></code>",
        <code>n</code> can be any integer between 1 and 16.
        All integral options check overflows;
        <a href="#string.pack"><code>string.pack</code></a> checks whether
        the given value fits in the given size;
        <a href="#string.unpack"><code>string.unpack</code></a> checks whether
        the read value fits in a Tokudae integer.
        For the unsigned options,
        Tokudae integers are treated as unsigned values too.
        <br/><br/>
        Any format string starts as if prefixed by "<code>!1=</code>",
        that is, with maximum alignment of 1 (no alignment)
        and native endianness.
        <br/><br/>
        Native endianness assumes that the whole system is
        either big or little endian.
        The packing functions will not emulate correctly the behavior
        of mixed-endian formats.
        <br/><br/>
        Alignment works as follows:
        For each option,
        the format gets extra padding until the data starts
        at an offset that is a multiple of the minimum between the
        option size and the maximum alignment;
        this minimum must be a power of 2.
        Options "<code>c</code>" and "<code>z</code>" are not aligned;
        option "<code>s</code>" follows the alignment of its starting integer.
        <br/><br/>
        All padding is filled with zeros by
        <a href="#string.pack"><code>string.pack</code></a>
        and ignored by
        <a href="#string.unpack"><code>string.unpack</code></a>.
        </p>


        <h2>6.5 &ndash; <a name="6.5">Math Library</a></h2>
        <p>
        This library provides basic mathematical functions.
        It provides all its functions and constants inside the table
        <a name="math"><code>math</code></a>.
        Functions with the annotation "<code>integer/float</code>" give
        integer results for integer arguments
        and float results for non-integer arguments.
        The rounding functions
        <a href="math.ceil"><code>math.ceil</code></a>,
        <a href="math.floor"><code>math.floor</code></a>,
        and <a href="math.modf"><code>math.modf</code></a>
        return an integer when the result fits in the range of an integer,
        or a float otherwise.
        </p>

        <!-- math.abs -->
        <hr/><h3><a name="math.abs"><code>math.abs (x)</code></a></h3>
        <p>
        Returns the maximum value between <code>x</code> and <code>-x</code>.
        (integer/float)
        <details class = "example">
            <summary>Example</summary>
            <pre>
local x = -5;
assert(math.abs(x) == 5);
assert(math.abs(-x) == 5);
assert(math.abs(-5) == 5);
assert(math.abs(--5) == 5);
x = -6.420e-2;
assert(math.abs(x) == -x);
assert(math.abs(x) == 6.420e-2);

local minint = math.minint;
local maxint = math.maxint;
assert(math.abs(minint), minint);
assert(math.abs(maxint), maxint);
assert(math.abs(-maxint), maxint);</pre>
        </details>
        </p>

        <!-- math.acos -->
        <hr/><h3><a name="math.acos"><code>math.acos (x)</code></a></h3>
        <p>
        Returns the arc cosine of <code>x</code> (in radians).
        <details class = "example">
            <summary>Example</summary>
            <pre>
local fn floateq(a,b) :: return (a == b or math.abs(a-b) &lt;= 1E-11);

assert(floateq(math.acos(0), math.pi/2));</pre>
        </details>
        </p>

        <!-- math.asin -->
        <hr/><h3><a name="math.asin"><code>math.asin (x)</code></a></h3>
        <p>
        Returns the arc sine of <code>x</code> (in radians).
        <details class = "example">
            <summary>Example</summary>
            <pre>
local fn floateq(a,b) :: return (a == b or math.abs(a-b) &lt;= 1E-11);

assert(floateq(math.asin(1), math.pi/2));</pre>
            </pre>
        </details>
        </p>

        <!-- math.atan -->
        <hr/><h3><a name="math.atan"><code>math.atan (y [, x])</code></a></h3>
        <p>
        Returns the arc tangen of <code>y/x</code> (in radians),
        using the sign of both arguments to find the quadrant of the result.
        It also handles correctly the case of <code>x</code> being zero.
        <br/><br/>
        The default value for <code>x</code> is 1, so that the call
        <code>math.atan(y)</code> returns the arc tangent of <code>y</code>.
        <details class = "example">
            <summary>Example</summary>
            <pre>
local fn floateq(a,b) :: return (a == b or math.abs(a-b) &lt;= 1E-11);

assert(floateq(math.atan(1), math.pi/4));
assert(floateq(math.atan(1,0), math.pi/2));</pre>
        </details>
        </p>

        <!-- math.ceil -->
        <hr/><h3><a name="math.ceil"><code>math.ceil (x)</code></a></h3>
        <p>
        Returns the smallest integral value greater than or equal to
        <code>x</code>.
        <details class = "example">
            <summary>Example</summary>
            <pre>
local fn eqt(x,y) :: return a == b and math.type(a) == math.type(b);

assert(eqt(math.ceil(3.4), 4));
assert(eqt(math.ceil(-3.4), -3));
assert(eqt(math.ceil(math.maxint), math.maxint));
assert(eqt(math.ceil(math.minint), math.minint));
assert(eqt(math.ceil(math.minint + 0.0), math.minint));
assert(math.ceil(1e50) == 1e50);
assert(math.ceil(-1e50) == -1e50);
assert(math.ceil(math.huge) == math.huge);
assert(math.ceil(-math.huge) == -math.huge);</pre>
        </details>
        </p>

        <!-- math.cos -->
        <hr/><h3><a name="math.cos"><code>math.cos (x)</code></a></h3>
        <p>
        Returns the cosine of <code>x</code> (assumed to be in radians).
        <details class = "example">
            <summary>Example</summary>
            <pre>
local fn floateq(a,b) :: return (a == b or math.abs(a-b) &lt;= 1E-11);

assert(floateq(math.cos(math.pi/2), 0));
assert(floateq(math.acos(0), math.pi/2));
assert(floateq(math.sin(-9.8)**2 + math.cos(-9.8)**2, 1));</pre>
        </details>
        </p>

        <!-- math.deg -->
        <hr/><h3><a name="math.deg"><code>math.deg (x)</code></a></h3>
        <p>
        Converts the angle <code>x</code> from radians to degrees.
        <details class = "example">
            <summary>Example</summary>
            <pre>
local fn floateq(a,b) :: return (a == b or math.abs(a-b) &lt;= 1E-11);

assert(floateq(math.deg(math.pi/2), 90));</pre>
        </details>
        </p>

        <!-- math.exp -->
        <hr/><h3><a name="math.exp"><code>math.exp (x)</code></a></h3>
        <p>
        Returns the value <em>e<sup>x</sup></em>
        (where <code>e</code> is the base of natural logarithms).
        <details class = "example">
            <summary>Example</summary>
            <pre>
local fn floateq(a,b) :: return (a == b or math.abs(a-b) &lt;= 1E-11);

assert(floateq(math.exp(0), 1));</pre>
        </details>
        </p>

        <!-- math.floor -->
        <hr/><h3><a name="math.floor"><code>math.floor (x)</code></a></h3>
        <p>
        Returns the largest integral value less than or equal to
        <code>x</code>.
        <details class = "example">
            <summary>Example</summary>
            <pre>
assert(math.floor(1e50) == 1e50);
assert(math.floor(-1e50) == -1e50);
assert(math.floor(math.huge) == math.huge);
assert(math.floor(-math.huge) == -math.huge);

local fn eqt(x,y) :: return a == b and math.type(a) == math.type(b);

assert(eqt(math.floor(3.4), 3));
assert(eqt(math.floor(-3.4), -4));
assert(eqt(math.floor(math.maxint), math.maxint));
assert(eqt(math.floor(math.minint), math.minint));
assert(eqt(math.floor(math.minint + 0.0), math.minint));</pre>
        </details>
        </p>

        <!-- math.fmod -->
        <hr/><h3><a name="math.fmod"><code>math.fmod (x, y)</code></a></h3>
        <p>
        Returns the remainder of the division of <code>x</code> by
        <code>y</code> that rounds the quotient towards zero. (integer/float)
        <details class = "example">
            <summary>Example</summary>
            <pre>
assert(math.fmod(10,3) == 1);
assert(math.fmod(3,2.5) == 0.5);

local fn eqt(x,y) :: return a == b and math.type(a) == math.type(b);

assert(eqt(math.fmod(math.minint, math.minint), 0));
assert(eqt(math.fmod(math.maxint, math.maxint), 0));
assert(eqt(math.fmod(math.minint + 1, math.minint), math.minint + 1));
assert(eqt(math.fmod(math.maxint - 1, math.maxint), math.maxint - 1));</pre>
        </details>
        </p>

        <!-- math.huge -->
        <hr/><h3><a name="math.huge"><code>math.huge</code></a></h3>
        <p>
        The float value <code>TOKU_HUGE_VAL</code>
        (see <code>tokudaeconf.h</code>),
        a value greater than any other numeric value
        (almost always equal to <code>infinity</code>).
        <details class = "example">
            <summary>Example</summary>
            <pre>
assert(math.huge &gt; 10e30);
assert(-math.huge &lt; -10e30);
assert(inf &lt;= math.huge);
assert(-inf &lt;= math.huge);
assert(-math.huge &lt;= inf);
assert(-math.huge &lt;= -inf);</pre>
        </details>
        </p>

        <!-- math.max -->
        <hr/><h3><a name="math.max"><code>math.max (x, &middot;&middot;&middot;)</code></a></h3>
        <p>
        Returns the argument with the maximum value,
        according to the Tokudae operator <code>&lt;</code>.
        <details class = "example">
            <summary>Example</summary>
            <pre>
local fn eqt(x,y) :: return a == b and math.type(a) == math.type(b);

assert(eqt(math.max(3), 3));
assert(eqt(math.max(3, 5, 9, 1), 9));
assert(math.max(math.maxint, 10e60) == 10e60);
assert(eqt(math.max(math.minint, math.minint + 1), math.minint + 1));</pre>
        </details>
        </p>

        <!-- math.maxint -->
        <hr/><h3><a name="math.maxint"><code>math.maxint</code></a></h3>
        <p>
        An integer with the maximum value for an integer.
        </p>

        <!-- math.min -->
        <hr/><h3><a name="math.min"><code>math.min (x, &middot;&middot;&middot;)</code></a></h3>
        <p>
        Returns the argument with the minimum value,
        according to the Tokudae operator <code>&lt;</code>.
        <details class = "example">
            <summary>Example</summary>
            <pre>
local fn eqt(x,y) :: return a == b and math.type(a) == math.type(b);

assert(eqt(math.min(3), 3));
assert(eqt(math.min(3, 5, 9, 1), 1));
assert(math.min(3.2, 5.9, -9.2, 1.1) == -9.2);
assert(math.min(1.9, 1.7, 1.72) == 1.7);
assert(math.min(-10e60, math.minint) == -10e60);
assert(eqt(math.min(math.maxint, math.maxint - 1), math.maxint - 1));
assert(eqt(math.min(math.maxint - 2, math.maxint, math.maxint - 1), math.maxint - 2));</pre>
        </details>
        </p>

        <!-- math.minint -->
        <hr/><h3><a name="math.minint"><code>math.minint</code></a></h3>
        <p>
        An integer with the minimum value for an integer.
        </p>

        <!-- math.modf -->
        <hr/><h3><a name="math.modf"><code>math.modf (x)</code></a></h3>
        <p>
        Returns the integral part of <code>x</code> and the fractional part
        of <code>x</code>.
        Its second result is always a float.
        <details class = "example">
            <summary>Example</summary>
            <pre>
local a,b = math.modf(3.5);
assert(a == 3.0 and b == 0.5);
a,b = math.modf(-2.5);
assert(a == -2.0 and b == -0.5);
a,b = math.modf(-3e23);
assert(a == -3e23 and b == 0.0);
a,b = math.modf(3e35);
assert(a == 3e35 and b == 0.0);
a,b = math.modf(-1/0);
assert(a == -1/0 and b == 0.0);
a,b = math.modf(1/0);
assert(a == 1/0 and b == 0.0);

local fn isnan(x) :: return x != x;

a,b = math.modf(0/0);
assert(isnan(a) and isnan(b));

local fn eqt(x, y) :: return x == y and math.type(x) == math.type(y);

a,b = math.modf(3);
assert(eqt(a, 3) and eqt(b, 0.0));
a,b = math.modf(math.minint);
assert(eqt(a, math.minint) and eqt(b, 0.0));</pre>
        </details>
        </p>

        <!-- math.pi -->
        <hr/><h3><a name="math.pi"><code>math.pi</code></a></h3>
        <p>
        The value of <em>&pi;</em>.
        </p>

        <!-- math.rad -->
        <hr/><h3><a name="math.rad"><code>math.rad (x)</code></a></h3>
        <p>
        Converts the angle <code>x</code> from degrees to radians.
        <details class = "example">
            <summary>Example</summary>
            <pre>
local fn floateq(a,b) :: return (a == b or math.abs(a-b) &lt;= 1E-11);

assert(floateq(math.rad(90), math.pi/2));</pre>
        </details>
        </p>

        <!-- math.srand -->
        <hr/><h3><a name="math.srand"><code>math.srand ([v])</code></a></h3>
        <p>
        Seeds pseudo-random number generator (PRNG).
        <br/>
        If <code>v</code> is not specified, Tokudae seeds the PRNG with
        its own implementation of generating seed.
        <br/>
        If <code>v</code> is a list or a table, the PRNG is seeded by the
        non-<b>nil</b> values inside the list or a table, if the value is
        collectable or has a pointer, its pointer is used as the seed value,
        otherwise the Tokudae generates the seed, in the way as if no
        arguments were provided.
        This is done for all the values inside the list or table.
        <br/>
        Finally if <code>v</code> is an integer, this integer is converted
        to unsigned integer, and is then used as the seed for the PRNG.
        <details class = "example">
            <summary>Example</summary>
            <pre>
math.srand(1000);
math.srand(-52);
math.srand([69, 420, "1337", { ["ok"] = || :: {} }, []]);
math.srand({ a = 69, ["420"] = || :: {}, ok = "1337"});</pre>
        </details>
        </p>

        <!-- math.rand -->
        <hr/><h3><a name="math.rand"><code>math.rand ([m[, n]])</code></a></h3>
        <p>
        Returns a pseudo-random integer with uniform distribution.
        When called without arguments, the "random" integer is in range
        <em>[math.minint, math.maxint]</em>.
        When called with two integers <code>m</code> and <code>n</code>,
        the "random" integer is in range <em>[m, n]</em>.
        When called with one integer <code>m</code>, the "random" integer
        is in range <em>[1, m]</em>.
        <br/><br/>
        This function uses the <code>MT19937-64</code>
        (64-bit Mersenne Twister) algorithm to produce pseudo-random 64-bit
        integers.
        <br/><br/>
        Tokudae initializes its pseudo-random generator with the equivalent
        of a call to <a href="#math.srand"><code>math.srand</code></a> with
        no arguments, so that <code>math.rand</code> should generate
        different sequences of results each time the program runs.
        <details class = "example">
            <summary>Example</summary>
            <pre>
local r = math.rand();
assert(math.minint &lt;= r and r &lt;= math.maxint);

r = math.rand(5);
assert(1 &lt;= r and r &lt;= 5);
assert(math.rand(1) == 1);

r = math.rand(4, 5);
assert(r == 4 or r == 5);
assert(math.rand(5, 5) == 5);
r = math.rand(-4, -1);
assert(-4 &lt;= r and r &lt;= -1);</pre>
        </details>
        </p>

        <!-- math.randf -->
        <hr/><h3><a name="math.randf"><code>math.randf ()</code></a></h3>
        <p>
        Similar to <a href="#math.rand"><code>math.rand</code></a>, except
        this generates and returns a double-precision float in the range (0, 1).
        <details class = "example">
            <summary>Example</summary>
            <pre>
local x = math.randf();
local n = 0;
loop {
    assert(0.0 &lt; x and x &lt; 1.0);
    if (n &gt; 1000) break;
    n = n + 1;
    x = math.randf();
}</pre>
        </details>
        </p>

        <!-- math.sin -->
        <hr/><h3><a name="math.sin"><code>math.sin (x)</code></a></h3>
        <p>
        Returns the sine of <code>x</code> (assumed to be in radians).
        <details class = "example">
            <summary>Example</summary>
            <pre>
local fn floateq(a,b) :: return (a == b or math.abs(a-b) &lt;= 1E-11);

assert(floateq(math.sin(math.pi/2), 1));
assert(floateq(math.sin(10), math.sin(10%(2*math.pi))));</pre>
        </details>
        </p>

        <!-- math.sqrt -->
        <hr/><h3><a name="math.sqrt"><code>math.sqrt (x)</code></a></h3>
        <p>
        Returns the square root of <code>x</code>.
        (You can also use the expression <code>x**0.5</code> to compute this
        value.)
        <details class = "example">
            <summary>Example</summary>
            <pre>
local fn floateq(a,b) :: return (a == b or math.abs(a-b) &lt;= 1E-11);

assert(floateq(math.sqrt(10)**2, 10));
assert(floateq(math.sqrt(4), 2));</pre>
        </details>
        </p>

        <!-- math.tan -->
        <hr/><h3><a name="math.tan"><code>math.tan (x)</code></a></h3>
        <p>
        Returns the tangent of <code>x</code>
        (assumed to be an angle in radians).
        <details class = "example">
            <summary>Example</summary>
            <pre>
local fn floateq(a,b) :: return (a == b or math.abs(a-b) &lt;= 1E-11);

assert(floateq(math.tan(math.pi/4), 1));</pre>
        </details>
        </p>

        <!-- math.toint -->
        <hr/><h3><a name="math.toint"><code>math.toint (x)</code></a></h3>
        <p>
        If the value <code>x</code> is convertible to an integer,
        returns that integer.
        Otherwise, returns <b>fail</b>.
        <details class = "example">
            <summary>Example</summary>
            <pre>
assert(math.toint(5) == 5);
assert(math.toint(math.maxint) == math.maxint);
assert(math.toint(math.minint) == math.minint);
assert(math.toint(52.0) == 52);
assert(math.toint(52.05 * 100) == 5205);
assert(math.toint(tonum("52.0")) == 52);
assert(!math.toint(math.pi));
assert(!math.toint(math.huge));
assert(!math.toint(-math.huge));
assert(!math.toint(inf));
assert(!math.toint(infinity));</pre>
        </details>
        </p>

        <!-- math.type -->
        <hr/><h3><a name="math.type"><code>math.type (x)</code></a></h3>
        <p>
        Returns "<code>integer</code>" if <code>x</code> is an integer,
        "<code>float</code>" if it is a float,
        or <b>fail</b> if <code>x</code> is not a number.
        <details class = "example">
            <summary>Example</summary>
            <pre>
assert(math.type(0) == "integer");
assert(math.type(0.0) == "float");
assert(math.type(-5) == "integer");
assert(math.type(-3.2) == "float");
assert(math.type(inf) == "float");
assert(math.type(-inf) == "float");
assert(math.type(infinity) == "float");
assert(math.type(math.maxint) == "integer");
assert(math.type(math.minint) == "integer");
assert(math.type(math.huge) == "float");
assert(!math.type("10"));
assert(!math.type(true));
assert(!math.type(false));
assert(!math.type(nil));</pre>
        </details>
        </p>

        <!-- math.log -->
        <hr/><h3><a name="math.log"><code>math.log (x[, base])</code></a></h3>
        <p>
        Returns the logarithm of <code>x</code> in the given base.
        The default for <code>base</code> is <em>e</em>
        (so that the function returns the natural logarithm of <code>x</code>).
        <details class = "example">
            <summary>Example</summary>
            <pre>
/// logarithm base 10
assert(math.log(100, 10) == 2);

/// logarithm base 2
assert(math.log(8, 2) == 3);</pre>
        </details>
        </p>

        <!-- math.ult -->
        <hr/><h3><a name="math.ult"><code>math.ult (m, n)</code></a></h3>
        <p>
        Returns a boolean, <b>true</b> if and only if integer <code>m</code>
        is below integer <code>n</code> when they are compared as unsigned
        integers ("Unsigned Less Than").
        <details class = "example">
            <summary>Example</summary>
            <pre>
assert(math.ult(3, 4));
assert(!math.ult(4, 4));
assert(math.ult(-2, -1));
assert(math.ult(2, -1));
assert(!math.ult(-2, -2));
assert(math.ult(math.maxint, math.minint));
assert(!math.ult(math.minint, math.maxint));</pre>
        </details>
        </p>




        <h2>6.6 &ndash; <a name="6.6">Input and Output Library</a></h2>
        <p>
        The I/O library provides two different styles for file manipulation.
        The first one uses implicit file handles;
        that is, there are operations to set a default input file and a
        default output file,
        and all input/output operations are done over these default files.
        The second style uses explicit file handles.
        <br/><br/>
        When using implicit file handles, all operations are supplied by
        table <a name="io"><code>io</code></a>.
        When using explicit file handles, the operation
        <a href="io.open"><code>io.open</code></a> returns a file handle
        and then all operations are supplied as methods of the file handle.
        <br/><br/>
        The metatable for file handles provides metamethods
        for <code>__gc</code> and <code>__close</code> that try
        to close the file when called,
        and metamethod for <code>__getidx</code> so that when file is
        indexed with present file method name, it returns a bound method.
        <br/><br/>
        The table <code>io</code> also provides three predefined file handles
        with their usual meanings from C:
        <a name="io.stdin"><code>io.stdin</code></a>,
        <a name="io.stdout"><code>io.stdout</code></a>,
        and <a name="io.stderr"><code>io.stderr</code></a>.
        The I/O library never closes these files.
        <br/><br/>
        Unless otherwise stated, all I/O functions return <b>fail</b> on
        failure, plus an error message as a second result and a
        system-dependent error code as a third result, and some non-false
        value on success.
        On non-POSIX systems, the computation of the error message and error
        code in case of errors may be not thread safe, because they rely on
        the global C variable <code>errno</code>.
        </p>

        <!-- io.open -->
        <hr/><h3><a name="io.open"><code>io.open (filename[, mode])</code></a></h3>
        <p>
        This function opens a file, in the mode specified in the string
        <code>mode</code>.
        In case of success, it returns a new file handle.
        <br/><br/>
        The <code>mode</code> string can be any of the following:
        <ul>
            <li><b>"<code>r</code>": </b> read mode (the default);</li>
            <li><b>"<code>w</code>": </b> write mode; </li>
            <li><b>"<code>a</code>": </b> append mode; </li>
            <li>
                <b>"<code>r+</code>": </b>
                read/write mode, all previous data is preserved;
            </li>
            <li>
                <b>"<code>w+</code>": </b>
                read/write mode, all previous data is erased;
            </li>
            <li>
                <b>"<code>a+</code>": </b>
                read/write append mode, previous data is preserved,
                writing is only allowed at the end of file.
            </li>
        </ul>
        The <code>mode</code> string can also have a '<code>b</code>' at the end,
        which is needed in some systems to open the file in binary mode.
        <br/><br/>
        <details class = "example">
            <summary>Example</summary>
            <pre>
local f = io.open("log.txt"); /* opens 'log.txt' file for reading */
assert(f.read() == "info: success");
assert(f.read() == "info: log file updated");
assert(f.read() == "info: shutdown complete");
assert(!f.read());
f.close();
f = io.open("log.txt", "a+"); /* open in read/write mode and append */
f.write("Hello");
f.seek("set", 0); /* go to the start of the file */
assert(f.read() == "info: success");
assert(f.read() == "info: log file updated");
assert(f.read() == "info: shutdown complete");
assert(f.read() == "Hello");</pre>
            <details class = "example">
                <summary>log.txt (assumming the file ends with a newline)</summary>
                <pre>
info: success
info: log file updated
info: shutdown complete</pre>
            </details>
        </details>
        </p>

        <!-- io.close -->
        <hr/><h3><a name="io.close"><code>io.close ([file])</code></a></h3>
        <p>
        Equivalent to <a href="#file.close"><code>file.close()</code></a>.
        Without a <code>file</code>, closes the default output file.
        <details class = "example">
            <summary>Example</summary>
            <pre>
local f = io.open("log.txt");
assert(f.close(f));             /* closing 'f' */
local st, err = io.close();     /* closing the default output file */
assert(!st and err = "cannot close standard file");</pre>
        </details>
        </p>

        <!-- io.flush -->
        <hr/><h3><a name="io.flush"><code>io.flush ()</code></a></h3>
        <p>
        Equivalent to <code>io.output().flush()</code>
        (see <a href="#file.flush"><code>file.flush</code></a>).
        </p>

        <!-- io.input -->
        <hr/><h3><a name="io.input"><code>io.input ([file])</code></a></h3>
        <p>
        When called with <code>file</code> being a file name, it opens the
        named file (in text mode), and sets its handle as the default
        input file.
        When called with <code>file</code> being a file handle,
        it simply sets this file handle as the default input file.
        When called without arguments, it returns the current default
        input file.
        <details class = "example">
            <summary>Example</summary>
            <pre>
assert(io.input() == io.stdin);
io.input("infile.txt");
assert(io.input() != io.stdin);
assert(io.read() == "new input set");
assert(io.read() == nil);
assert(io.open("infile.txt", "r").read() == io.input("infile.txt").read());</pre>
            <details class = "example">
                <summary>infile.txt</summary>
                <pre>new input set</pre>
            </details>
        </details>
        </p>

        <!-- io.output -->
        <hr/><h3><a name="io.output"><code>io.output ([file])</code></a></h3>
        <p>
        Similar to <a href="#io.input"><code>io.input</code></a>,
        but operates over the default output file.
        <details class = "example">
            <summary>Example</summary>
            <pre>
assert(io.output() == io.stdout);
/* 'outfile.txt' is created or truncated and opened for writting */
io.output("outfile.txt");
assert(io.output() != io.stdout);
io.write("output file\n", 69);
io.output().close();
io.output(io.stdout);
assert(io.output() == io.stdout);
local f = io.open("outfile.txt", "r");
assert(f.read() == "output file");
assert(f.read() == "69");
assert(!f.read());
f.close();</pre>
        </details>
        </p>

        <!-- io.popen -->
        <hr/><h3><a name="io.popen"><code>io.popen (prog[, mode])</code></a></h3>
        <p>
        This function is system dependent and is not available on all platforms.
        <br/><br/>
        Starts the program <code>prog</code> in a separated process and returns
        a file handle that you can use to read data from this program
        (if <code>mode</code> is <code>"r"</code>, the default)
        or to write data to this program
        (if <code>mode</code> is <code>"w"</code>).
        <details class = "example">
            <summary>Example</summary>
            <pre>
local file = "testfile";
local f = assert(io.popen("cat - &gt; " .. file, "w"));
f.write("a line");
assert(f.close());
f = assert(io.popen("cat - &lt; " .. file, "r"));
assert(f.read("a") == "a line");
assert(f.close());</pre>
        </details>
        </p>

        <!-- io.tmpfile -->
        <hr/><h3><a name="io.tmpfile"><code>io.tmpfile ()</code></a></h3>
        <p>
        In case of success, returns a handle for a temporary file.
        This file is opened in read/write mode and it is automatically
        removed when it is closed or when the program ends.
        <details class = "example">
            <summary>Example</summary>
            <pre>
local f = assert(io.tmpfile());
f.write("alo");
f.seek("set");
assert(f.read("a") == "alo");
f.close();</pre>
        </details>
        </p>

        <!-- io.type -->
        <hr/><h3><a name="io.type"><code>io.type (obj)</code></a></h3>
        <p>
        Checks whether <code>obj</code> is a valid file handle.
        Returns the string <code>"file"</code> if <code>obj</code> is an
        open file handle, <code>"closed file"</code> if <code>obj</code> is
        a closed file handle, or <b>fail</b> if <code>obj</code> is not a
        file handle.
        <details class = "example">
            <summary>Example</summary>
            <pre>
/* these are not files */
assert(!io.type(8) and !io.type(class));
/* these are valid files */
assert(io.type(io.stdin) == "file");
assert(io.type(io.stdout) == "file");
assert(io.type(io.stderr) == "file");
local f = io.open("bla", "w");
f.close();
assert(io.type(f) == "closed file");</pre>
        </details>
        </p>

        <!-- io.lines -->
        <hr/><h3><a name="io.lines"><code>io.lines ([filename, &middot;&middot;&middot;])</code></a></h3>
        <p>
        Opens the given file name in read mode and returns an iterator
        function that works like
        <code>file.lines(&middot;&middot;&middot;)</code> over the opened file.
        When the iterator function fails to read any value,
        it automatically closes the file.
        Besides the iterator function, <code>io.lines</code> returns three
        other values: two <b>nil</b> values as placeholders, plus the
        created file handle.
        Therefore, when used in a <b>foreach</b> loop, the file is closed
        also if the loop is interrupted by an error or a <b>break</b>.
        <br/><br/>
        The call <code>io.lines()</code> (with no file name) is equivalent
        to <code>io.input().lines("l")</code>;
        that is, it iterates over the lines of the default input file.
        In this case, the iterator does not close the file when the loop ends.
        <br/><br/>
        In case of errors opening the file, this function raises the error,
        instead of returning an error code.
        <details class = "example">
            <summary>Example</summary>
            <pre>
local f = io.open("testfile", "w");
f.write("hi\n", "there\n", "how\n", "are\n", "you\n", "?\n");
f.close();

local n = 0;
f = io.lines("testfile");
while f() n++;
assert(n == 6); /// number of lines in the testfile

/* calling iterator after file was closed */
local st, err = pcall(f);
assert(!st and string.find(err, "file is already closed"));</pre>
        </details>
        </p>

        <!-- io.read -->
        <hr/><h3><a name="io.read"><code>io.read (&middot;&middot;&middot;)</code></a></h3>
        <p>
        Equivalent to <code>io.input().read(&middot;&middot;&middot;)</code>
        (see <a href="#file.read"><code>file.read</code></a>);
        </p>

        <!-- io.write -->
        <hr/><h3><a name="io.write"><code>io.write (&middot;&middot;&middot;)</code></a></h3>
        <p>
        Equivalent to <code>io.output().write(&middot;&middot;&middot;)</code>
        (see <a href="#file.write"><code>file.write</code></a>).
        </p>

        <!-- file.read -->
        <hr/><h3><a name="file.read"><code>file.read (&middot;&middot;&middot;)</code></a></h3>
        <p>
        Reads the file <code>file</code>, according to the given formats,
        which specify what to read.
        For each format, the function returns a string or a number with the
        characters read, or <b>fail</b> if it cannot read data with the
        specified format.
        (In this latter case, the function does not read subsequent formats.)
        When called without arguments, it uses a default format that reads
        the next line (see below).
        <br/><br/>
        The available formats are
        <ul>
            <li>
                <b>"<code>n</code>": </b>
                reads a numeral and returns it as a float or an integer,
                following the lexical conventions of Tokudae.
                (The numeral may have digit separators, leading whitespaces
                and a leading sign.)
                This format always reads the longest input sequence that
                is a valid prefix for a numeral;
                if that prefix does not form a valid numeral
                (e.g., an empty string, "<code>0x</code>", or "<code>3.4e-</code>")
                or it is too long (more than 200 characters),
                it is discarded and the format returns <b>fail</b>.
                This numeral is also allowed to touch a character outside of
                it's valid format for it's last character
                (e.g., "<code>0x5H</code>", or "<code>3.4e-3|</code>" are
                both valid numerals, meaning only the "<code>0x5</code>" and
                "<code>3.4e-3</code>" are considered).
            </li>

            <li><b>"<code>a</code>": </b>
                reads the whole file, starting at the current position.
                On end of file, it returns the empty string;
                this format never fails.
            </li>

            <li><b>"<code>l</code>": </b>
                reads the next line skipping the end of line,
                returning <b>fail</b> on end of file.
                This is the default format.
            </li>

            <li><b>"<code>L</code>": </b>
                reads the next line keeping the end-of-line character
                (if present), returning <b>fail</b> on end of file.
            </li>

            <li><b><em>number</em>: </b>
                reads a string with up to this number of bytes,
                returning <b>fail</b> on end of file.
                If <code>number</code> is zero,
                it reads nothing and returns an empty string,
                or <b>fail</b> on end of file.
            </li>

        </ul><p>
        The formats "<code>l</code>" and "<code>L</code>" should be used only for text files.
        <details class = "example">
            <summary>Example</summary>
            <pre>
local f = io.open("testfile", "w+");
f.write("hi\n", "there\n", "how\n", "69a", "are\n", "you\n", "?\n", 69);
f.seek("set"); /* go back to the start of the file */
assert(f.read(0) == "");
assert(f.read(3, "l") == "hi\n"); /* reads first 3 bytes and the next line */
assert(f.read("L") == "how\n");
assert(f.read("n") == 69);
assert(f.read(1) == "a");
assert(f.read("a") == "are\nyou\n?\n69");</pre>
        </details>
        </p>

        <!-- file.write -->
        <hr/><h3><a name="file.write"><code>file.write (&middot;&middot;&middot;)</code></a></h3>
        <p>
        Writes the value of each of its arguments to <code>file</code>.
        The arguments must be strings or numbers.
        <br/><br/>
        In case of success, this function returns <code>file</code>.
        <details class = "example">
            <summary>Example</summary>
            <pre>
local f = io.open("testfile", "w+");
f.write("(reading docs is so boring) ? ", 0b1, " : ", 0b0, "\n");
f.seek("set"); /* go back to the start of the file */
assert(f.read("a") == "(reading docs is so boring) ? 1 : 0\n");</pre>
        </details>
        </p>

        <!-- file.lines -->
        <hr/><h3><a name="file.lines"><code>file.lines (&middot;&middot;&middot;)</code></a></h3>
        <p>
        Returns an iterator function that, each time it is called, reads the
        file according to the given formats.
        When no format is given, uses "<code>l</code>" as a default.
        As an example, the construction

        <pre>
    foreach c in file.lines(1) { <em>...</em> }</pre>

        will iterate over all characters of the file, starting at the
        current position.
        Unlike <a href="#io.lines"><code>io.lines</code></a>, this function
        does not close the file when the loop ends.
        <br/><br/>
        <details class = "example">
            <summary>Example</summary>
            <pre>
local f = io.open("testfile", "w");
f.write("00\n10\n20\n30\n40\n").close();

foreach a, b in io.lines("testfile", "n", "n")
    assert((a == 40 and !b) or (a == b - 10));</pre>
        </details>
        </p>

        <!-- file.flush -->
        <hr/><h3><a name="file.flush"><code>file.flush ()</code></a></h3>
        <p>
        Saves any written data to <code>file</code>.
        </p>

        <!-- file.seek -->
        <hr/><h3><a name="file.seek"><code>file.seek ([whence[, offset]])</code></a></h3>
        <p>
        Sets and gets the file position, measured from the beginning of
        the file, to the position given by <code>offset</code> plus a base
        specified by the string <code>whence</code>, as follows:
        <ul>
            <li>
                <b>"<code>set</code>": </b>
                base is position 0 (beginning of the file);
            </li>
            <li>
                <b>"<code>cur</code>": </b>
                base is current position;
            </li>
            <li>
                <b>"<code>end</code>": </b>
                base is end of file;
            </li>
        </ul>
        In case of success, <code>seek</code> returns the final file position,
        measured in bytes from the beginning of the file.
        If <code>seek</code> fails, it returns <b>fail</b>, plus a string
        describing the error.
        <br/><br/>
        The default value for <code>whence</code> is <code>"cur"</code>,
        and for <code>offset</code> is 0.
        Therefore, the call <code>file.seek()</code> returns the current
        file position, without changing it;
        the call <code>file.seek("set")</code> sets the position to the
        beginning of the file (and returns 0);
        and the call <code>file.seek("end")</code> sets the position to the
        end of the file, and returns its size.
        <br/><br/>
        <details class = "example">
            <summary>Example</summary>
            <pre>
local f = io.open("testfile", "w");
local fr = io.open("testfile", "r");
f.write("x").flush();
assert(fr.read("a") == "x");
f.write("bcd").flush();
fr.seek("set", 1);
assert(fr.read("a") == "bcd");
f.write("X").flush();
fr.seek("end", -1);
assert(fr.read("a") == "X");
f.write("BCD").flush();
fr.seek("end", -3);
fr.seek("cur", 1);
assert(fr.read("a") == "CD");</pre>
        </details>
        </p>

        <!-- file.close -->
        <hr/><h3><a name="file.close"><code>file.close ()</code></a></h3>
        <p>
        Closes <code>file</code>.
        Note that files are automatically closed when their handles are
        garbage collected, but that takes an unpredictable amount of time
        to happen.
        <br/><br/>
        In case of success this returns <b>true</b>, otherwise <b>fail</b>
        is returned plus a string describing the error.
        <details class = "example">
            <summary>Example</summary>
            <pre>
/*
** Creates or truncates a "testfile" and opens it for reading and
** immediately after that, the file is closed.
*/
assert(io.open("testfile", "w").close());

/* trying to close the standard output fails */
local st, msg = io.stdout.close();
assert(!st and typeof(msg) == "string");</pre>
        </details>
        </p>

        <!-- file.setvbuf -->
        <hr/><h3><a name="file.setvbuf"><code>file.setvbuf (mode[, size])</code></a></h3>
        <p>
        Sets the buffering mode for a file.
        There are three available modes:
        <ul>
            <li>
                <b>"<code>no</code>": </b>
                no buffering.
            </li>
            <li>
                <b>"<code>full</code>": </b>
                full buffering.
            </li>
            <li>
                <b>"<code>line</code>": </b>
                line buffering.
            </li>
        </ul>
        For the last two cases, <code>size</code> is a hint for the size of
        the buffer, in bytes.
        The default is an appropriate size.
        <br/><br/>
        The specific behavior of each mode is non portable;
        check the underlying ISO&nbsp;C function <code>setvbuf</code> in
        your platform for more details.
        <br/><br/>
        <details class = "example">
            <summary>Example</summary>
            <pre>
local f = assert(io.open("testfile", "w"));
local fr = assert(io.open("testfile", "r"));
assert(f.setvbuf("full", 2000));
f.write("x");
assert(fr.read("a") == "");
f.flush();
fr.seek("set");
assert(fr.read("a") == "x"); /* buffer was flushed */
f = assert(io.open("testfile", "w"));
assert(f.setvbuf("no"));
f.write("x");
fr.seek("set");
assert(fr.read("a") == "x"); /* no buffer; output is ready */
f.close();
f = assert(io.open("testfile", "a"));
assert(f.setvbuf("line"));
f.write("x");
fr.seek("set", 1);
assert(fr.read("a") == ""); /* line buffer; no output without `\n' */
f.write("a\n").seek("set", 1);
assert(fr.read("a") == "xa\n"); /* now we have a whole line */
f.close(); fr.close();</pre>
        </details>
        </p>




        <h2>6.7 &ndash; <a name="6.7">Operating System Library</a></h2>
        <p>
        This library is implemented through table
        <a name="os"><code>os</code></a>.
        </p>

        <!-- os.clock -->
        <hr/><h3><a name="os.clock"><code>os.clock ()</code></a></h3>
        <p>
        Returns an approximation of the amount in seconds of CPU time
        used by the program, as returned by the underlying ISO&nbsp;C
        function <code>clock</code>.
        <details class = "example">
            <summary>Example</summary>
            <pre>
local clockinit = os.clock();
local lastclock = os.clock();
assert(clockinit &lt; lastclock and lastclock - clockinit &gt; 0);</pre>
        </details>
        </p>

        <!-- os.date -->
        <hr/><h3><a name="os.date"><code>os.date ([format[, time]])</code></a></h3>
        <p>
        Returns a string or a table containing date and time,
        formatted according to the given string <code>format</code>.
        <br/><br/>
        If the <code>time</code> argument is present, this is the time to
        be formatted (see the <a href="#os.time"><code>os.time</code></a>
        function for a description of this value).
        Otherwise, <code>date</code> formats the current time.
        <br/><br/>
        If <code>format</code> starts with '<code>!</code>',
        then the date is formatted in Coordinated Universal Time.
        After this optional character, if <code>format</code> is the string
        "<code>t</code>", then <code>date</code> returns a table with the
        following fields:
        <code>year</code>,
        <code>month</code> (1&ndash;12),
        <code>day</code> (1&ndash;31),
        <code>hour</code> (0&ndash;23),
        <code>min</code> (0&ndash;59),
        <code>sec</code> (0&ndash;61, due to leap seconds),
        <code>wday</code> (weekday, 1&ndash;7, Sunday is&nbsp;1),
        <code>yday</code> (day of the year, 1&ndash;366),
        and <code>isdst</code> (daylight saving flag, a boolean).
        This last field may be absent if the information is not available.
        <br/><br/>
        If <code>format</code> is not "<code>t</code>", then <code>date</code>
        returns the date as a string, formatted according to the same rules as
        the ISO&nbsp;C function <code>strftime</code>.
        <br/><br/>
        If <code>format</code> is absent, it defaults to "<code>%c</code>",
        which gives a human-readable date and time representation
        using the current locale.
        <br/><br/>
        On non-POSIX systems, this function may be not thread safe because of
        its reliance on C&nbsp;function <code>gmtime</code> and
        C&nbsp;function <code>localtime</code>.
        <details class = "example">
            <summary>Example</summary>
            <pre>
td = os.date("t", 0);
load(os.date([=[assert(td.year==%Y and td.month==%m and td.day==%d and
                       td.hour==%H and td.min==%M and td.sec==%S and
                       td.wday==%w+1 and td.yday==%j);]=], 0))();</pre>
        </details>
        </p>

        <!-- os.difftime -->
        <hr/><h3><a name="os.difftime"><code>os.difftime (t2, t1)</code></a></h3>
        <p>
        Returns the difference, in seconds, from time <code>t1</code> to time
        <code>t2</code> (where the times are values returned by
        <a href="#os.time"><code>os.time</code></a>).
        In POSIX, Windows, and some other systems, this value is exactly
        <code>t2</code><em>-</em><code>t1</code>.
        <details class = "example">
            <summary>Example</summary>
            <pre>
local d = os.date("t");
local t1 = os.time(d);
d.year--;
local t2 = os.time(d);
assert(math.abs(os.difftime(t1, t2)/(24*3600) - 365) &lt; 2);</pre>
        </details>
        </p>

        <!-- os.execute -->
        <hr/><h3><a name="os.execute"><code>os.execute ([command])</code></a></h3>
        <p>
        This function is equivalent to the ISO&nbsp;C function
        <code>system</code>.
        It passes <code>command</code> to be executed by an operating system
        shell.
        Its first result is <b>true</b> if the command terminated successfully,
        or <b>fail</b> otherwise.
        After this first result the function returns a string plus a number,
        as follows:
        <ul>
            <li>
                <b>"<code>exit</code>": </b>
                the command terminated normally;
                the following number is the exit status of the command.
            </li>
            <li>
                <b>"<code>signal</code>": </b>
                the command was terminated by a signal;
                the following number is the signal that terminated the command.
            </li>
        </ul>
        When called without a <code>command</code>, <code>os.execute</code>
        returns a boolean that is true if a shell is available.
        <br/><br/>
        <details class = "example">
            <summary>Example</summary>
            <pre>
assert(typeof(os.execute()) == "boolean");
if os.execute() { /* shell is available? */
    local cmd = __POSIX and "ls" or (__WINDOWS and "dir") or nil;
    local res, how, st;
    if cmd { /* POSIX or Windows? */
        res, how, st = os.execute(cmd);
        assert(res and how == "exit" and st == 0);
    }
    res, how, st = os.execute("?bla?labla");
    assert(!res and how == "exit" and st != 0);
}</pre>
        </details>
        </p>

        <!-- os.exit -->
        <hr/><h3><a name="os.exit"><code>os.exit ([code[, close]])</code></a></h3>
        <p>
        Calls the ISO&nbsp;C function <code>exit</code> to terminate the host
        program.
        If <code>code</code> is <b>true</b>, the returned status is
        <code>EXIT_SUCCESS</code>;
        if <code>code</code> is <b>false</b>, the returned status is
        <code>EXIT_FAILURE</code>;
        if <code>code</code> is a number, the returned status is this number.
        The default value for <code>code</code> is <b>true</b>.
        <br/><br/>
        If the optional second argument <code>close</code> is true,
        the function closes the Tokudae state before exiting
        (see <a href="#toku_close"><code>toku_close</code></a>).
        </p>

        <!-- os.getenv -->
        <hr/><h3><a name="os.getenv"><code>os.getenv (varname)</code></a></h3>
        <p>
        Returns the value of the process environment variable
        <code>varname</code> or <b>fail</b> if the variable is not defined.
        <br/><br/>
        <a href="#setenv_example"><code>Example (os.setenv)</code></a>
        </p>

        <!-- os.setenv -->
        <hr/><h3><a name="os.setenv"><code>os.setenv (varname[, value])</code></a></h3>
        <p>
        Sets or removes the environment variable <code>varname</code> from the
        environment and returns true if it was sucessfull, or <b>fail</b>
        if not.
        <br/><br/>
        If optional parameter <code>value</code> is provided, then the
        value of the environment variable <code>varname</code> is set to
        that value and the variable <code>varname</code> is created if
        it was not previously in the environment.
        <br/><br/>
        If <code>value</code> is an empty string, or it was not provided
        (defaults to an empty string <code>""</code>), the environment
        variable <code>varname</code> is removed from the environment.
        <details id="setenv_example" class="example">
            <summary>Example</summary>
            <pre>
if __WINDOWS or __POSIX {
    assert(typeof(os.getenv("PATH")) == "string");
    assert(!os.getenv("bamboozle"));
    os.setenv("bamboozle", "69");
    assert(os.getenv("bamboozle") == "69");
    os.setenv("bamboozle");
    assert(!os.getenv("bamboozle"));
    assert(!os.getenv("wut69"));
}</pre>
        </details>
        </p>

        <!-- os.remove -->
        <hr/><h3><a name="os.remove"><code>os.remove (filename)</code></a></h3>
        <p>
        Deletes the file (or empty directory, on POSIX systems) with the
        given name.
        If this function fails, it returns <b>fail</b> plus a string
        describing the error and the error code.
        Otherwise, it returns true.
        <br/><br/>
        <a href="#rename_example"><code>Example (os.rename)</code></a>
        </p>

        <!-- os.rename -->
        <hr/><h3><a name="os.rename"><code>os.rename (oldname, newname)</code></a></h3>
        <p>
        Renames the file or directory named <code>oldname</code> to
        <code>newname</code>.
        If this function fails, it returns <b>fail</b>, plus a string
        describing the error and the error code.
        Otherwise, it returns true.
        <details id = "rename_example" class = "example">
            <summary>Example</summary>
            <pre>
local fname = os.tmpname();
local otherfname = os.tmpname();
assert(os.rename(fname, otherfname));   /* replace 'fname' with 'otherfname' */
assert(!os.rename(fname, otherfname));  /* there is no 'fname', it was replaced */
os.remove(otherfname); /* (cleanup) */</pre>
        </details>
        </p>

        <!-- os.setlocale -->
        <hr/><h3><a name="os.setlocale"><code>os.setlocale (locale[, category])</code></a></h3>
        <p>
        Sets the current locale of the program.
        <code>locale</code> is a system-dependent string specifying a locale;
        <code>category</code> is an optional string describing which category
        to change: <code>"all"</code>, <code>"collate"</code>,
        <code>"ctype"</code>, <code>"monetary"</code>, <code>"numeric"</code>,
        or <code>"time"</code>; the default category is <code>"all"</code>.
        The function returns the name of the new locale, or <b>fail</b> if
        the request cannot be honored.
        <br/><br/>
        If <code>locale</code> is the empty string, the current locale is set
        to an implementation-defined native locale.
        If <code>locale</code> is the string "<code>C</code>", the current
        locale is set to the standard C locale.
        <br/><br/>
        When called with <b>nil</b> as the first argument, this function only
        returns the name of the current locale for the given category.
        <br/><br/>
        This function may be not thread safe because of its reliance on
        C&nbsp;function <code>setlocale</code>.
        <details class = "example">
            <summary>Example</summary>
            <pre>
if (os.setlocale("pt_BR.iso88591") or os.setlocale("ptb")) {
    assert(tonum("3,4") == 3.4 and tonum("3.4") == 3.4);
    assert(tonum(" 0x.1p0 ") + tonum(" 0x,1p0") + tonum("-0X.1p0\t") == 0x0.1p0);
}
assert(os.setlocale("C"), "numeric");
assert(!tonum("3,4"));</pre>
        </details>
        </p>

        <!-- os.time -->
        <hr/><h3><a name="os.time"><code>os.time ([table])</code></a></h3>
        <p>
        Returns the current time when called without arguments, or a time
        representing the local date and time specified by the given table.
        This table must have fields
        <code>year</code>,
        <code>month</code>,
        and <code>day</code>, and may have fields
        <code>hour</code> (default is 12),
        <code>min</code> (default is 0),
        <code>sec</code> (default is 0),
        and <code>isdst</code> (default is <b>nil</b>).
        Other fields are ignored.
        For a description of these fields, see the
        <a href="#os.date"><code>os.date</code></a> function.
        <br/><br/>
        When the function is called, the values in these fields do not need
        to be inside their valid ranges.
        For instance, if <code>sec</code> is -10, it means 10 seconds before
        the time specified by the other fields;
        if <code>hour</code> is 1000, it means 1000 hours after the time
        specified by the other fields.
        <br/><br/>
        The returned value is a number, whose meaning depends on your system.
        In POSIX, Windows, and some other systems, this number counts the
        number of seconds since some given start time (the "epoch").
        In other systems, the meaning is not specified, and the number
        returned by <code>time</code> can be used only as an argument to
        <a href="#os.date"><code>os.date</code></a> and
        <a href="#os.difftime"><code>os.difftime</code></a>.
        <br/><br/>
        When called with a table, <code>os.time</code> also normalizes all
        the fields documented in the
        <a href="#os.date"><code>os.date</code></a> function, so that they
        represent the same time as before the call but with values inside
        their valid ranges.
        <details class = "example">
            <summary>Example</summary>
            <pre>
local td = {year = 2005, month = 1, day = 1, hour = 1, min = 0, sec = -3602};
os.time(td);
assert(td.day == 31 and td.month == 12 and td.year == 2004 and
       td.hour == 23 and td.min == 59 and td.sec == 58 and
       td.yday == 366);</pre>
        </details>
        </p>

        <!-- os.tmpname -->
        <hr/><h3><a name="os.tmpname"><code>os.tmpname ()</code></a></h3>
        <p>
        Returns a string with a file name that can be used for a temporary file.
        The file must be explicitly opened before its use and explicitly
        removed when no longer needed.
        <br/><br/>
        In POSIX systems, this function also creates a file with that name,
        to avoid security risks.
        (Someone else might create the file with wrong permissions
        in the time between getting the name and creating the file.)
        You still have to open the file to use it and to remove it
        (even if you do not use it).
        <br/><br/>
        When possible, you may prefer to use
        <a href="#io.tmpfile"><code>io.tmpfile</code></a>,
        which automatically removes the file when the program ends.
        <br/><br/>
        <a href="#rename_example"><code>Example (os.rename)</code></a>
        </p>


        <h2>6.8 &ndash; <a name="6.8">Regular Expression Library</a></h2>
        <p>
        This library provides string pattern matching and is implemented
        through table <a name="reg"><code>reg</code></a>.
        The indexing of strings and the semantics of indices are identical
        as in <a href="#string"><code>string</code></a> library.
        </p>

        <!-- reg.find -->
        <hr/><h3><a name="reg.find"><code>reg.find (s, pattern[, init[, plain]])</code></a></h3>
        <p>
        Looks for the first match of <code>pattern</code>
        (see <a href="#6.8.1">&sect;6.8.1</a>) in the string <code>s</code>.
        If it finds a match, then <code>find</code> returns the indices
        of&nbsp;<code>s</code> where this occurrence starts and ends;
        otherwise, it returns <b>fail</b>.
        A third, optional numeric argument <code>init</code> specifies
        where to start the search; its default value is&nbsp;0 and can
        be negative.
        A <b>true</b> as a fourth, optional argument <code>plain</code>
        turns off the pattern matching facilities,
        so the function does a plain "find substring" operation
        (identical to <a href="#string.find"><code>string.find</code></a>),
        with no characters in <code>pattern</code> being considered magic.
        <br/><br/>
        If the pattern has captures, then in a successful match the captured
        values are also returned, after the two indices.
        <details class = "example">
            <summary>Example</summary>
            <pre>
/* escape magic character '(' with '%' */
assert(reg.find("(álo)", "%(á") == 0);

/* plain search from start */
assert(reg.find("(álo)", "(á", 0, true) == 0);

/* anchors */
local a = string.repeat("a", 1000);
assert(reg.find(a, "^a*.?$"));
assert(!reg.find(a, "^a*.?b$"));

/* frontier */
assert(reg.find("aba", "%f[a\0]") == 2);
assert(reg.find("aba", "%f[\0]") == 3);</pre>
        </details>
        </p>

        <!-- reg.match -->
        <hr/><h3><a name="reg.match"><code>reg.match (s, pattern[, init])</code></a></h3>
        <p>
        Looks for the first <em>match</em> of the <code>pattern</code>
        (see <a href="#6.8.1">&sect;6.8.1</a>) in the string <code>s</code>.
        If it finds one, then <code>match</code> returns the captures from
        the pattern; otherwise it returns <b>fail</b>.
        If <code>pattern</code> specifies no captures,
        then the whole match is returned.
        A third, optional numeric argument <code>init</code> specifies
        where to start the search;
        its default value is&nbsp;0 and can be negative.
        <details class = "example">
            <summary>Example</summary>
            <pre>
assert(reg.match("aaab", ".*b") == "aaab");
assert(reg.match("aaa", ".*a") == "aaa");
assert(reg.match("b", ".*b") == "b");

/* start matching after first character */
assert(!reg.match("aab", "aa", 1));

assert(reg.match("aaab", ".?b") == "ab");
assert(reg.match("aaa", ".?a") == "aa");
assert(reg.match("b", ".?b") == "b");

assert(reg.match("ab\0\1\2c", "[\0-\2]+") == "\0\1\2");

/* capture group is returned */
assert(reg.match("alo xyzK", "(%w+)K") == "xyz");

/* multiple captures are returned */
local a, b, c, d  = reg.match("0123456789", "(.+(.?)())");
assert(a == "0123456789" and b == "" and c == 10 and d == nil);</pre>
        </details>
        </p>

        <!-- reg.gmatch -->
        <hr/><h3><a name="reg.gmatch"><code>reg.gmatch (s, pattern[, init])</code></a></h3>
        <p>
        Returns an iterator function that, each time it is called,
        returns the next captures from <code>pattern</code>
        (see <a href="#6.8.1">&sect;6.8.1</a>) over the string <code>s</code>.
        If <code>pattern</code> specifies no captures,
        then the whole match is produced in each call.
        A third, optional numeric argument <code>init</code> specifies
        where to start the search;
        its default value is&nbsp;0 and can be negative.
        <details class = "example">
            <summary>Example</summary>
            <pre>
/* the loop iterates over all the words in string 's' */
local s = "hello world from Tokudae";
foreach w in reg.gmatch(s, "%a+")
    print(w);

/*
** The loop collects all pairs 'key=value' from
** the string 's' into a table.
*/
local t = {};
s = "from=world, to=Tokudae";
foreach k,v in reg.gmatch(s, "(%w+)=(%w+)")
    t[k] = v;</pre>
        </details>
        </p>

        <!-- reg.gsub -->
        <hr/><h3><a name="reg.gsub"><code>reg.gsub (s, pattern, repl[, n])</code></a></h3>
        <p>
        Returns a copy of <code>s</code> in which all
        (or the first <code>n</code>, if given) occurrences of the
        <code>pattern</code> (see <a href="#6.8.1">&sect;6.8.1</a>) have been
        replaced by a replacement string specified by <code>repl</code>,
        which can be a string, a table, an instance, a list or a function.
        <code>gsub</code> also returns, as its second value,
        the total number of matches that occurred.
        The name <code>gsub</code> comes from <em>Global SUBstitution</em>.
        <br/><br/>
        If <code>repl</code> is a string, then its value is used for replacement.
        The character&nbsp;<code>%</code> works as an escape character:
        any sequence in <code>repl</code> of the form <code>%<em>d</em></code>,
        with <em>d</em> between 1 and 9,
        stands for the value of the <em>d</em>-th captured substring;
        the sequence <code>%0</code> stands for the whole match;
        the sequence <code>%%</code> stands for a single&nbsp;<code>%</code>.
        <br/><br/>
        If <code>repl</code> is a table, an instance or a list
        (remember that lists have built-in fields),
        it is queried for every match, using the first capture as the key.
        <br/><br/>
        If <code>repl</code> is a function,
        then this function is called every time a match occurs,
        with all captured substrings passed as arguments,
        in order.
        <br/><br/>
        In any case,
        if the pattern specifies no captures,
        then it behaves as if the whole pattern was inside a capture.
        <br/><br/>
        If the value returned by the table query or by the function call
        is a string or a number,
        then it is used as the replacement string;
        otherwise, if it is <b>false</b> or <b>nil</b>,
        then there is no replacement
        (that is, the original match is kept in the string).
        <details class = "example">
            <summary>Example</summary>
            <pre>
assert(reg.gsub("abc", "%w", "%1%0") == "aabbcc");
assert(reg.gsub("abc", "%w+", "%0%1") == "abcabc");

assert(reg.gsub("alo  alo  \n 123\n ", "%s+", " ") == "alo alo 123 ");

assert(reg.gsub("a b cd", " *", "-") == "-a-b-c-d-");

assert(reg.gsub("", "^", "r") == "r");
assert(reg.gsub("", "$", "r") == "r");

assert(reg.gsub("  alo alo  ", "^%s*(.-)%s*$", "%1") == "alo alo");</pre>
        </details>
        </p>


        <h2>6.8.1 &ndash; <a name="6.8.1">Patterns</a></h2>
        <p>
        Patterns in Tokudae are described by regular strings,
        which are interpreted as patterns by the pattern-matching functions
        <a href="#reg.find"><code>reg.find</code></a>,
        <a href="#reg.gmatch"><code>reg.gmatch</code></a>,
        <a href="#reg.gsub"><code>reg.gsub</code></a>,
        and <a href="#reg.match"><code>reg.match</code></a>.
        This section describes the syntax and the meaning
        (that is, what they match) of these strings.
        </p>
        <h4>Character Class:</h4>
        <p>
        A <em>character class</em> is used to represent a set of characters.
        The following combinations are allowed in describing a character class:
        <ul>
            <li>
                <b><em>x</em></b>: 
                (where <em>x</em> is not one of the <em>magic characters</em>
                <code>^$()%.[]*+-?</code>)
                represents the character <em>x</em> itself.
            </li>
            <li><b><code>.</code></b>:  (a dot) represents all characters.</li>
            <li><b><code>%a</code></b>:  represents all letters.</li>
            <li><b><code>%c</code></b>:  represents all control characters.</li>
            <li><b><code>%d</code></b>:  represents all digits.</li>
            <li><b><code>%g</code></b>:  represents all printable characters except space.</li>
            <li><b><code>%l</code></b>:  represents all lowercase letters.</li>
            <li><b><code>%p</code></b>:  represents all punctuation characters.</li>
            <li><b><code>%s</code></b>:  represents all space characters.</li>
            <li><b><code>%u</code></b>:  represents all uppercase letters.</li>
            <li><b><code>%w</code></b>:  represents all alphanumeric characters.</li>
            <li><b><code>%x</code></b>:  represents all hexadecimal digits.</li>
            <li>
                <b><code>%<em>x</em></code></b>:  (where <em>x</em> is any non-alphanumeric character)
                represents the character <em>x</em>.
                This is the standard way to escape the magic characters.
                Any non-alphanumeric character
                (including all punctuation characters, even the non-magical)
                can be preceded by a '<code>%</code>' to represent itself in a pattern.
            </li>
            <li>
                <b><code>[<em>set</em>]</code></b>: 
                represents the class which is the union of all characters
                in <em>set</em>.
                A range of characters can be specified by separating the
                end characters of the range, in ascending order, with a
                '<code>-</code>'.
                All classes <code>%</code><em>x</em> described above can
                also be used as components in <em>set</em>.
                All other characters in <em>set</em> represent themselves.
                For example, <code>[%w_]</code> (or <code>[_%w]</code>)
                represents all alphanumeric characters plus the underscore,
                <code>[0-7]</code> represents the octal digits,
                and <code>[0-7%l%-]</code> represents the octal digits plus
                the lowercase letters plus the '<code>-</code>' character.
                <br/><br/>
                You can put a closing square bracket in a set by positioning
                it as the first character in the set.
                You can put a hyphen in a set by positioning it as the first
                or the last character in the set.
                (You can also use an escape for both cases.)
                <br/><br/>
                The interaction between ranges and classes is not defined.
                Therefore, patterns like <code>[%a-z]</code> or
                <code>[a-%%]</code> have no meaning.
            </li>
            <li>
                <b><code>[^<em>set</em>]</code></b>: 
                represents the complement of <em>set</em>,
                where <em>set</em> is interpreted as above.
            </li>
        </ul>
        For all classes represented by single letters (<code>%a</code>, <code>%c</code>, etc.),
        the corresponding uppercase letter represents the complement of the class.
        For instance, <code>%S</code> represents all non-space characters.
        <br/><br/>
        The definitions of letter, space, and other character groups
        depend on the current locale.
        In particular, the class <code>[a-z]</code> may not be equivalent
        to <code>%l</code>.
        </p>
        <h4>Pattern Item:</h4>
        <p>
        A <em>pattern item</em> can be
        <ul>
            <li>
                a single character class,
                which matches any single character in the class;
            </li>
            <li>
                a single character class followed by '<code>*</code>',
                which matches sequences of zero or more characters in the class.
                These repetition items will always match the longest possible sequence;
            </li>
            <li>
                a single character class followed by '<code>+</code>',
                which matches sequences of one or more characters in the class.
                These repetition items will always match the longest possible sequence;
            </li>
            <li>
                a single character class followed by '<code>-</code>',
                which also matches sequences of zero or more characters in the class.
                Unlike '<code>*</code>',
                these repetition items will always match the shortest possible sequence;
            </li>
            <li>
                a single character class followed by '<code>?</code>',
                which matches zero or one occurrence of a character in the class.
                It always matches one occurrence if possible;
            </li>
            <li>
                <code>%<em>n</em></code>, for <em>n</em> between 1 and 9;
                such item matches a substring equal to the <em>n</em>-th captured string
                (see below);
            </li>
            <li>
                <code>%b<em>xy</em></code>, where <em>x</em> and <em>y</em> are two distinct characters;
                such item matches strings that start with&nbsp;<em>x</em>, end with&nbsp;<em>y</em>,
                and where the <em>x</em> and <em>y</em> are <em>balanced</em>.
                This means that, if one reads the string from left to right,
                counting <em>+1</em> for an <em>x</em> and <em>-1</em> for a <em>y</em>,
                the ending <em>y</em> is the first <em>y</em> where the count reaches 0.
                For instance, the item <code>%b()</code> matches expressions with
                balanced parentheses.
            </li>
            <li>
                <code>%f[<em>set</em>]</code>, a <em>frontier pattern</em>;
                such item matches an empty string at any position such that
                the next character belongs to <em>set</em>
                and the previous character does not belong to <em>set</em>.
                The set <em>set</em> is interpreted as previously described.
                The beginning and the end of the subject are handled as if
                they were the character '<code>\0</code>'.
            </li>
        </ul>
        </p>
        <h4>Pattern:</h4>
        <p>
        A <em>pattern</em> is a sequence of pattern items.
        A caret '<code>^</code>' at the beginning of a pattern anchors the
        match at the beginning of the subject string.
        A '<code>$</code>' at the end of a pattern anchors the match at the
        end of the subject string.
        At other positions, '<code>^</code>' and '<code>$</code>'
        have no special meaning and represent themselves.
        </p>
        <h4>Captures:</h4>
        <p>
        A pattern can contain sub-patterns enclosed in parentheses;
        they describe <em>captures</em>.
        When a match succeeds, the substrings of the subject string
        that match captures are stored (<em>captured</em>) for future use.
        Captures are numbered according to their left parentheses.
        For instance, in the pattern <code>"(a*(.)%w(%s*))"</code>,
        the part of the string matching <code>"a*(.)%w(%s*)"</code> is
        stored as the first capture, and therefore has number&nbsp;1;
        the character matching "<code>.</code>" is captured with number&nbsp;2,
        and the part matching "<code>%s*</code>" has number&nbsp;3.
        <br/><br/>
        As a special case, the capture <code>()</code> captures
        the current string position (a number).
        For instance, if we apply the pattern <code>"()aa()"</code> on the
        string <code>"flaaap"</code>, there will be two captures:
        2&nbsp;and&nbsp;4.
        </p>
        <h4>Multiple matches:</h4>
        <p>
        The function <a href="#reg.gsub"><code>reg.gsub</code></a> and the
        iterator <a href="#reg.gmatch"><code>reg.gmatch</code></a>
        match multiple occurrences of the given pattern in the subject.
        For these functions, a new match is considered valid only
        if it ends at least one byte after the end of the previous match.
        In other words, the pattern machine never accepts the
        empty string as a match immediately after another match.
        As an example, consider the results of the following code:

        <pre>
     &gt; reg.gsub("abc", "()a*()", print);
     --&gt; 0   1
     --&gt; 2   2
     --&gt; 3   3</pre>

        The second and third results come from Tokudae matching an empty
        string after '<code>b</code>' and another one after '<code>c</code>'.
        Tokudae does not match an empty string after '<code>a</code>',
        because it would end at the same position of the previous match.
        </p>


        <h2>6.9 &ndash; <a name="6.9">UTF-8 Library</a></h2>
        <p>
        This library provides basic support for UTF-8 encoding.
        It provides all its functions inside the table
        <a name="utf8"><code>utf8</code></a>.
        This library does not provide any support for Unicode other
        than the handling of the encoding.
        Any operation that needs the meaning of a character,
        such as character classification, is outside its scope.
        <br/><br/>
        Unless stated otherwise,
        all functions that expect a byte position as a parameter
        assume that the given position is either the start of a byte sequence
        or one plus the length of the subject string.
        As in the <a href="#string"><code>string</code></a> and
        <a href="#reg"><code>reg</code></a> library,
        negative indices count from the end of the string.
        <br/><br/>
        Functions that create byte sequences
        accept all values up to <code>0x7FFFFFFF</code>,
        as defined in the original UTF-8 specification;
        that implies byte sequences of up to six bytes.
        <br/><br/>
        Functions that interpret byte sequences only accept
        valid sequences (well formed and not overlong).
        By default, they only accept byte sequences
        that result in valid Unicode code points,
        rejecting values greater than <code>10FFFF</code> and surrogates.
        A boolean argument <code>lax</code>, when available,
        lifts these checks,
        so that all values up to <code>0x7FFFFFFF</code> are accepted.
        (Not well formed and overlong sequences are still rejected.)
        </p>

        <!-- utf8.offset -->
        <hr/><h3><a name="utf8.offset"><code>utf8.offset (s, n[, i])</code></a></h3>
        <p>
        Returns the position of the <code>n</code>-th character of <code>s</code>
        (counting from byte at index <code>i</code>) as two integers:
        The index (in bytes) where its encoding starts and the
        index (in bytes) where it ends.
        <br/><br/>
        If the specified character is right after the end of <code>s</code>,
        the function behaves as if there was a '<code>\0</code>' there.
        If the specified character is neither in the subject
        nor right after its end,
        the function returns <b>fail</b>.
        <br/><br/>
        A negative <code>n</code> gets characters before position <code>i</code>.
        The default for <code>i</code> is 0 when <code>n</code> is non-negative
        and <code>len(s)</code> otherwise,
        so that <code>utf8.offset(s, -n)</code> gets the offset of the
        <code>n</code>-th character from the end of the string.
        <br/><br/>
        As a special case,
        when <code>n</code> is 0 the function returns the start and end
        of the encoding of the character that contains the
        <code>i</code>-th byte of <code>s</code>.
        <br/><br/>
        This function assumes that <code>s</code> is a valid UTF-8 string.
        <details class = "example">
            <summary>Example</summary>
            <pre>
local s = "Olá 🌍"; /* "Olá " + Earth Emoji */

local i,j = utf8.offset(s, 1);  /// 'O'
assert(i == 0 and j == 0);  
i,j = utf8.offset(s, 2);        /// 'l'
assert(i == 1 and j == 1);  
i,j = utf8.offset(s, 3);        /// 'á'
assert(i == 2 and j == 3);
i,j = utf8.offset(s, 4);        /// ' '
assert(i == 4 and j == 4);
i,j = utf8.offset(s, 5);        /// '🌍' (Earth Emoji)
assert(i == 5 and j == 8);
i,j = utf8.offset(s, -1);       /// '🌍' (Earth Emoji)
assert(i == 5 and j == 8);
i,j = utf8.offset(s, 0, 8);     /// (byte 9 is inside the emoji)
assert(i == 5 and j == 8);</pre>
        </details>
        </p>

        <!-- utf8.codepoint -->
        <hr/><h3><a name="utf8.codepoint"><code>utf8.codepoint (s[, i[, j[, lax]]])</code></a></h3>
        <p>
        Returns the code points (as integers) from all characters in
        <code>s</code> that start between byte index <code>i</code>
        and <code>j</code> (both included).
        The default for <code>i</code> is 0 and for <code>j</code> is
        <code>i</code>.
        It raises an error if it meets any invalid byte sequence.
        <details class = "example">
            <summary>Example</summary>
            <pre>
local s = "Olá 🌍";   /// "Olá " + Earth emoji

foreach i, cp in indices([utf8.codepoint(s)]) {
    switch (i) {
        case 0: assert(cp == 'O'); break;
        case 1: assert(cp == 'l'); break;
        case 2: assert(cp == 225); break;
        case 3: assert(cp == ' '); break;
        case 4: assert(cp == 127757); break;
        default: assert(nil); /* unreached */
    }
}

/// Get codepoint of only the first character
assert(utf8.codepoint(s, 0, 0) == 'O'); /// 79

/// Get last character (the emoji 🌍)
assert(utf8.codepoint(s, 5, 8) == 127757);

/// Iterate directly using multiple return values
local a, b, c = utf8.codepoint("Hi!", 0, 2);
assert(a == 'H' and b == 'i' and c == '!');</pre>
        </details>
        </p>

        <!-- utf8.char -->
        <hr/><h3><a name="utf8.char"><code>utf8.char (&middot;&middot;&middot;)</code></a></h3>
        <p>
        Receives zero or more integers,
        converts each one to its corresponding UTF-8 byte sequence
        and returns a string with the concatenation of all these sequences.
        <details class = "example">
            <summary>Example</summary>
            <pre>
/// Basic ASCII characters
assert(utf8.char('H', 'e', 'l', 'l', 'o') == "Hello");

/// Accented character (á = 225)
assert(utf8.char(225) == "á");

/// Earth Emoji
assert(utf8.char(127757) == "🌍");

/// Concatenating different characters
assert(utf8.char('O', 'l', 225, ' ', 127757) == "Olá 🌍");</pre>
        </details>
        </p>

        <!-- utf8.len -->
        <hr/><h3><a name="utf8.len"><code>utf8.len (s[, i[, j[, lax]]])</code></a></h3>
        <p>
        Returns the number of UTF-8 characters in string <code>s</code>
        that start between positions <code>i</code> and <code>j</code>
        (both inclusive).
        The default for <code>i</code> is 0 and for <code>j</code> is -1.
        If it finds any invalid byte sequence,
        returns <b>fail</b> plus the byte index of the first invalid byte.
        <details class = "example">
            <summary>Example</summary>
            <pre>
local s = "Olá 🌍";  /// "Olá " + Earth emoji

/// Count all characters
assert(utf8.len(s) == 5);

/// Count only first three characters ("Olá")
assert(utf8.len(s, 0, 3) == 3);

/// Count last character (the emoji 🌍)
assert(utf8.len(s, 5) == 1);

/// Invalid byte sequence example
local bad = "\xff";
local length, err = utf8.len(bad);
assert(!length and err == 0);</pre>
        </details>
        </p>

        <!-- utf8.codes -->
        <hr/><h3><a name="utf8.codes"><code>utf8.codes (s[, lax])</code></a></h3>
        <p>
        Returns values so that the construction

<pre>
    foreach i, c in utf8.codes(s) <em>body</em></pre>

        will iterate over all UTF-8 characters in string <code>s</code>,
        with <code>i</code> being the byte index and <code>c</code>
        the code point of each character.
        It raises an error if it meets any invalid byte sequence.
        </p>

        <!-- utf8.charpattern -->
        <hr/><h3><a name="utf8.charpattern"><code>utf8.charpattern</code></a></h3>
        <p>
        A string pattern "<code>[\0-\x7F\xC2-\xFD][\x80-\xBF]*</code>"
        (see <a href="#6.8.1">&sect;6.8.1</a>),
        which matches exactly one UTF-8 byte sequence,
        assuming that the subject is a valid UTF-8 string.
        <details class = "example">
            <summary>Example</summary>
            <pre>
local s = "Olá 🌍";
local l = [];

/// Iterate through each UTF-8 character
foreach c in reg.gmatch(s, utf8.charpattern)
    l[l.len] = c;
assert(l.x == "O");
assert(l.y == "l");
assert(l.z == "á");
assert(l[3] == " ");
assert(l.last == "🌍");</pre>
        </details>
        </p>


        <h2>6.10 &ndash; <a name="6.10">List Library</a></h2>
        <p>
        This library provides generic functions for list manipulation.
        It provides all its functions inside the table
        <a name="list"><code>list</code></a>.
        </p>

        <!-- list.insert -->
        <hr/><h3><a name="list.insert"><code>list.insert (list, [i, ]value)</code></a></h3>
        <p>
        Inserts element <code>value</code> at index <code>i</code>
        in <code>list</code>, shifting up the elements
        <code>list[i], list[i+1], &middot;&middot;&middot;, list.last</code>.
        The default value for <code>i</code> is <code>list.len</code>,
        so that a call <code>list.insert(l,x)</code> inserts
        <code>x</code> at the end of the list <code>l</code>
        (in other words it appends <code>x</code> into the list <code>l</code>).
        <details class = "example">
            <summary>Example</summary>
            <pre>
local l = [10, 20, 30]
assert(l.len == 3 and l.last == 30);

/// insert at the end
list.insert(l, 40);
assert(l.len == 4 and l.last == 40 and l[3] == 40);

/// insert at index 2
list.insert(l, 2, 15);
assert(l.len == 5 and l[1] == 20 and l[2] == 15 and l.last == 40);</pre>
        </details>
        </p>

        <!-- list.remove -->
        <hr/><h3><a name="list.remove"><code>list.remove (list[, i])</code></a></h3>
        <p>
        Removes from <code>list</code> the element at index <code>i</code>,
        returning the value of the removed element.
        When <code>i</code> is an integer between 0 and
        <code>list.len - 1</code>, it shifts down the elements
        <code>list[i+1], list[i+2], &middot;&middot;&middot;, list.last</code>
        and erases element <code>list.last</code>;
        <br/><br/>
        The default value for <code>i</code> is <code>list.len - 1</code>,
        so that a call <code>list.remove(l)</code> removes the last element
        of the list <code>l</code>.
        <details class = "example">
            <summary>Example</summary>
            <pre>
local l = [10, 20, 30, 40];

/// remove last element
local last = list.remove(l);
assert(l.last == 30 and last == 40);

/// remove element at index 1
local mid = list.remove(l, 1);
assert(mid == 20);

/// remove first element
local first = list.remove(l, 0);
assert(l[0] == 30 and first == 10);</pre>
        </details>
        </p>

        <!-- list.move -->
        <hr/><h3><a name="list.move"><code>list.move (lsrc, f, e, t[, ldest])</code></a></h3>
        <p>
        Moves elements from the list <code>lsrc</code> to the list
        <code>ldest</code>, performing the equivalent to the following
        multiple assignment:
        <br/>
        <code>ldest[t],&middot;&middot;&middot; = lsrc[f],&middot;&middot;&middot;,lsrc[e]</code>.
        <br/>
        The default for <code>ldest</code> is <code>lsrc</code>.
        The destination range can overlap with the source range.
        The number of elements to be moved must fit in a Tokudae integer.
        If <code>f</code> is larger than <code>e</code>,
        nothing is moved.
        <br/><br/>
        Returns the destination table <code>ldest</code>.
        <details class = "example">
            <summary>Example</summary>
            <pre>
local l = [10, 20, 30, 40, 50];

/// move elements from index 1..3 into position 0 of same list
list.move(l, 1, 3, 0);
/// l is now [20, 30, 40, 40, 50]
assert(l[0] == 20 and l[1] == 30 and l[2] == 40 and l[3] == 40 and l[4] == 50);

/// move a single element (index 4 into index 1)
list.move(l, 4, 4, 1);
/// l is now [20, 50, 40, 40, 50]
assert(l[0] == 20 and l[1] == 50 and l[2] == 40 and l[3] == 40 and l[4] == 50);

/// move elements from one list into another
local src = [1, 2, 3, 4];
local dst = [100, 200];
list.move(src, 1, 2, 2, dst);
/// moves src[1..2] -&gt; dst[2..3]
/// dst is now [100, 200, 2, 3]
assert(dst[0] == 100 and dst[1] == 200 and dst[2] == 2 and dst[3] == 3);

/// case where <code>f</code> &gt; <code>e</code>: nothing is moved
local x = [7, 8, 9];
list.move(x, 2, 1, 0);
/// x is unchanged: [7, 8, 9]
assert(x[0] == 7 and x[1] == 8 and x[2] == 9 and !x[3]);</pre>
        </details>
        </p>

        <!-- list.new -->
        <hr/><h3><a name="list.new"><code>list.new (size)</code></a></h3>
        <p>
        Creates a new empty list, preallocating memory.
        This preallocation may help performance and save memory
        when you know in advance how many elements the list will have.
        <br/><br/>
        Parameter <code>size</code> is a hint for how many elements the list
        will have.
        <details class = "example">
            <summary>Example</summary>
            <pre>
local l = list.new(8);
local oldsize = l.size;

foreach i in range(8)
    l[i] = true;

assert(l.len == 8 and l.size == oldsize);</pre>
        </details>
        </p>

        <!-- list.flatten -->
        <hr/><h3><a name="list.flatten"><code>list.flatten (list[, i[, j]])</code></a></h3>
        <p>
        Returns the elements from the given list.
        This function is equivalent to

        <pre>
    return list[i], list[i+1], &middot;&middot;&middot;, list[j]</pre>

        By default, <code>i</code> is&nbsp;0 and <code>j</code> is
        <code>list.len - 1</code>.
        </p>

        <!-- list.concat -->
        <hr/><h3><a name="list.concat"><code>list.concat (list[, sep[, i[, j]]])</code></a></h3>
        <p>
        Given a list where all elements are strings or numbers,
        returns the string
        <code>list[i]..sep..list[i+1]&nbsp;&middot;&middot;&middot;&nbsp;sep..list[j]</code>.
        <br/>
        The default value for <code>sep</code> is the empty string,
        the default for <code>i</code> is 0,
        and the default for <code>j</code> is <code>list.len - 1</code>.
        If <code>i</code> is greater than <code>j</code>,
        returns the empty string.
        <details class = "example">
            <summary>Example</summary>
            <pre>
local l = ["a", "b", "c", "d"];

/// default: sep = "", i = 0, j = l.len - 1
assert(list.concat(l) == "abcd");

/// custom separator
assert(list.concat(l, "-") == "a-b-c-d");

/// specify a subrange (i = 1, j = 2)
assert(list.concat(l, ",", 1, 2) == "b,c");
/// s3 is "b,c"

/// specify only i (j defaults to l.len - 1)
assert(list.concat(l, "", 2) == "cd");

/// case where i &gt; j -&gt; empty string
assert(list.concat(l, ",", 3, 1) == "");</pre>
        </details>
        </p>

        <!-- list.sort -->
        <hr/><h3><a name="list.sort"><code>list.sort (list[, fcmp])</code></a></h3>
        <p>
        Sorts the list elements in a given order, <em>in-place</em>,
        from <code>list[0]</code> (or <code>list.x</code>)
        to <code>list[list.len - 1]</code> (or <code>list.last</code>).
        <br/>
        If <code>fcmp</code> is given,
        then it must be a function that receives two list elements
        and returns true when the first element must come
        before the second in the final order,
        so that, after the sort,
        <code>i &lt;= j</code> implies <code>!fcmp(list[j],list[i])</code>.
        If <code>fcmp</code> is not given,
        then the standard Tokudae operator <code>&lt;</code> is used instead.
        <br/><br/>
        The <code>fcmp</code> function must define a consistent order;
        more formally, the function must define a strict weak order.
        (A weak order is similar to a total order,
        but it can equate different elements for comparison purposes.)
        <br/><br/>
        The sort algorithm is not stable:
        Different elements considered equal by the given order
        may have their relative positions changed by the sort.
        <details class = "example">
            <summary>Example</summary>
            <pre>
/// default sort (ascending)
local nums = [5, 1, 4, 3, 2];
list.sort(nums);
/// nums is now [1, 2, 3, 4, 5]
assert(nums[0] == 1 and nums[1] == 2 and nums[2] == 3 and nums[3] == 4 and nums[4] == 5);

/// sorting strings
local words = ["banana", "apple", "cherry"];
list.sort(words);
/// words is now ["apple", "banana", "cherry"]
assert(words.x == "apple" and words.y == "banana" and words.z == "cherry");

/// custom comparator function: descending order
local vals = [10, 30, 20];
list.sort(vals, |a, b| :: return a &gt; b);
/// vals is now [30, 20, 10]
assert(vals.x == 30 and vals.y == 20 and vals.z == 10);

/// custom comparator function: even numbers before odd numbers
local mix = [5, 2, 7, 4, 1, 6, 3];
list.sort(mix, |a, b| {
    if (a % 2 == b % 2)
        return a &lt; b /// same parity -&gt; ascending
    else
        return a % 2 == 0; /// even comes before odd
});
/// mix is now [2, 4, 6, 1, 3, 5, 7]
assert(mix[0] == 2 and mix[1] == 4 and mix[2] == 6 and mix[3] == 1 and
       mix[4] == 3 and mix[5] == 5 and mix[6] == 7);

/// not stable: equal elements may change relative order
local pairs = [{id=1, v=10}, {id=2, v=10}, {id=3, v=5}];
list.sort(pairs, |a, b| :: return a.v &lt; b.v);
/// pairs is now something like [{id=3, v=5}, {id=2, v=10}, {id=1, v=10}]
/// notice id=1 and id=2 swapped positions compared to the original
assert(pairs[0].id == 3 and pairs[1].id == 2 and pairs[2].id == 1);</pre>
        </details>
        </p>

        <!-- list.isordered -->
        <hr/><h3><a name="list.isordered"><code>list.isordered (list[, fcmp])</code></a></h3>
        <p>
        Checks if the list elements are ordered in a given order,
        from <code>list[0]</code> (or <code>list.x</code>)
        to <code>list[list.len - 1]</code> (or <code>list.last</code>).
        <br/>
        If optional function argument <code>fcmp</code> is provided,
        it must follow the same rules as in
        <a href="#list.sort"><code>list.sort</code></a>.
        If <code>fcmp</code> is not given,
        then the standard Tokudae operator <code>&lt;</code> is used instead.
        <br/><br/>
        If the ordering holds this returns <b>true</b>,
        otherwise <b>false</b> is returned followed by the first list index
        of the element which breaks the ordering.
        <details class = "example">
            <summary>Example</summary>
            <pre>
/// edge cases: empty or single-element list
assert(list.isordered([]) == true);
assert(list.isordered([42]) == true);

/// default check (ascending)
assert(list.isordered([1, 2, 3, 4]) == true);

/// unordered list
local res, idx = list.isordered([1, 3, 2, 4]);
assert(!res and idx == 2);
/// (l[2] = 2 breaks ascending order after 3)

/// custom comparator function: descending order
assert(list.isordered([9, 7, 5, 4, 2], |a, b| :: return a &gt; b));

/// custom comparator function: even numbers first, then ascending
assert(list.isordered([2, 4, 6, 1, 3, 5], |a, b| {
    if (a % 2 == b % 2)
        return a &lt; b;
    else
        return a % 2 == 0;
}));

/// example where the rule fails
res, idx = list.isordered([2, 6, 4, 1, 3], fn(a, b) {
    if (a % 2 == b % 2)
        return a &lt; b;
    else
        return a % 2 == 0;
});
assert(!res and idx == 2);
/// (l[2] = 4 comes before l[1] = 6, breaking order)</pre>
        </details>
        </p>

        <!-- list.shrink -->
        <hr/><h3><a name="list.shrink"><code>list.shrink (list)</code></a></h3>
        <p>
        Tries to shrink the <code>list.size</code>.
        <br/><br/>
        If the list was shrunk <b>true</b> is returned,
        otherwise <b>false</b>.
        </p>


        <h2>6.11 &ndash; <a name="6.11">Debug Library</a></h2>
        <p>
        This library provides the functionality of the debug API
        (<a href="#toku_Debug"><code>toku_Debug</code></a>)
        to Tokudae programs.
        You should exert care when using this library.
        Several of its functions
        violate basic assumptions about Tokudae code
        (e.g., that variables local to a function
        cannot be accessed from outside;
        that userdata metatables cannot be changed by Tokudae code;
        that Tokudae programs do not crash)
        and therefore can compromise otherwise secure code.
        Moreover, some functions in this library may be slow.
        <br/><br/>
        All functions in this library are provided
        inside the <a name="debug"><code>debug</code></a> table.
        All functions that operate over a thread
        have an optional first argument which is the
        thread to operate over.
        The default is always the current thread.
        </p>

        <!-- debug.debug -->
        <hr/><h3><a name="debug.debug"><code>debug.debug ()</code></a></h3>
        <p>
        Enters an interactive mode with the user,
        running each string that the user enters.
        Using simple commands and other debug facilities,
        the user can inspect global and local variables,
        change their values, evaluate expressions, and so on.
        A line containing only the word <code>cont</code> finishes this function,
        so that the caller continues its execution.
        <br/><br/>
        Note that commands for <code>debug.debug</code> are not lexically nested
        within any function and so have no direct access to local variables.
        <details class = "example">
            <summary>Example</summary>
            <pre>
x = 42;

fn test() {
    local z = 99;
    debug.debug();
    printf("resumed, z = %", z);
}

test();

/// Example interactive session:
/// &gt; print(x);
/// 42
/// &gt; y = "world";
/// &gt; print(y);
/// world
/// &gt; cont
/// resumed, z = 99;</pre>
        </details>
        </p>

        <!-- debug.getuservalue -->
        <hr/><h3><a name="debug.getuservalue"><code>debug.getuservalue (u, i)</code></a></h3>
        <p>
        Returns the value associated to the userdata <code>u</code> at the
        index <code>i</code>.
        If the userdata does not have that value, <b>nil</b> is returned,
        otherwise the associated value followed by <b>true</b>.
        <br/><br/>
        For minimal example see
        <a href="#debug.setuservalue"><code>debug.setuservalue</code></a>.
        </p>

        <!-- debug.gethook -->
        <hr/><h3><a name="debug.gethook"><code>debug.gethook ([thread])</code></a></h3>
        <p>
        Returns the current hook settings of the thread, as three values:
        the current hook function, the current hook mask,
        and the current hook count, as set by the
        <a href="#debug.sethook"><code>debug.sethook</code></a> function.
        <br/><br/>
        Returns <b>fail</b> if there is no active hook.
        <br/><br/>
        For example,
        see <a href="#debug.sethook"><code>debug.sethook</code></a>.
        </p>

        <!-- debug.getinfo -->
        <hr/><h3><a name="debug.getinfo"><code>debug.getinfo ([thread, ]f[, what])</code></a></h3>
        <p>
        Returns a table with information about a function.
        You can give the function directly or you can give a number as
        the value of <code>f</code>,
        which means the function running at level <code>f</code> of the
        call stack of the given thread:
        level&nbsp;0 is the current function (<code>getinfo</code> itself);
        level&nbsp;1 is the function that called <code>getinfo</code> and so on.
        If <code>f</code> is a number greater than the number of active functions,
        then <code>getinfo</code> returns <b>fail</b>.
        <br/><br/>
        The returned table can contain all the fields returned by
        <a href="#toku_getinfo"><code>toku_getinfo</code></a>,
        with the string <code>what</code> describing which fields to fill in.
        The default for <code>what</code> is to get all information available,
        except the table of valid lines.
        The option '<code>f</code>' adds a field named <code>func</code>
        with the function itself.
        The option '<code>L</code>' adds a field named <code>activelines</code>
        with the table of valid lines,
        provided the function is a Tokudae function.
        <br/><br/>
        For instance, the expression <code>debug.getinfo(1,"n").name</code>
        returns a name for the current function,
        if a reasonable name can be found,
        and the expression <code>debug.getinfo(print)</code>
        returns a table with all available information
        about the <a href="#print"><code>print</code></a> function.
        <details class = "example">
            <summary>Example</summary>
            <pre>
fn add(a, b) :: return a + b;
assert(debug.getinfo(add, "f").func == add);

local info1 = debug.getinfo(add);
assert(!info1.name and info1.nparams == 2 and info1.isvararg == false);

fn current() :: return debug.getinfo(1).func;
assert(current() == current);

fn caller() :: return debug.getinfo(2).func;
fn test() :: return caller();
assert(test() == test);

/// try level too deep
assert(!debug.getinfo(10));</pre>
        </details>
        </p>

        <!-- debug.getlocal -->
        <hr/><h3><a name="debug.getlocal"><code>debug.getlocal ([thread, ]f, local)</code></a></h3>
        <p>
        This function returns the name and the value of the local variable
        with index <code>local</code> of the function at level <code>f</code>
        of the stack.
        This function accesses not only explicit local variables,
        but also parameters and temporary values.
        <br/><br/>
        The first parameter or local variable has index&nbsp;1, and so on,
        following the order that they are declared in the code,
        counting only the variables that are active
        in the current scope of the function.
        Some local variables may not appear in this listing,
        if they were optimized away by the compiler (e.g. removal of dead code).
        Negative indices refer to vararg arguments;
        -1 is the first vararg argument.
        The function returns <b>fail</b>
        if there is no variable with the given index,
        and raises an error when called with a level out of range.
        (You can call <a href="#debug.getinfo"><code>debug.getinfo</code></a>
        to check whether the level is valid.)
        <br/><br/>
        Variable names starting with '<code>(</code>' (open parenthesis) 
        represent variables with no known names
        (internal variables such as loop control variables,
        switch expression, etc.).
        <br/><br/>
        The parameter <code>f</code> may also be a function.
        In that case, <code>getlocal</code> returns only the name of
        function parameters.
        <details class = "example">
            <summary>Example</summary>
            <pre>
fn sample(a, b, ...) {
    local x = 10;
    local y = 20;
    local z = a + b + x + y;

    /// get parameter a (index 1)
    local name, val = debug.getlocal(1, 1);
    assert(name == "a" and val == a);

    /// get parameter b (index 2)
    name, val = debug.getlocal(1, 2);
    assert(name == "b" and val == b);

    /// get local x (index 3)
    name, val = debug.getlocal(1, 3);
    assert(name == "x" and val == x);

    /// get local y (index 4)
    name, val = debug.getlocal(1, 4);
    assert(name == "y" and val == y);

    /// get first vararg (index -1)
    local namev, valv = debug.getlocal(1, -1);
    assert(namev == "(vararg)" and valv == getargs(0, ...));

    /// get second vararg (index -2)
    namev, valv = debug.getlocal(1, -2);
    assert(namev == "(vararg)" and valv == getargs(1, ...));

    /// temporary
    assert(debug.getlocal(1, 10) == "(temporary)");

    /// invalid index
    assert(!debug.getlocal(1, 11));
}

sample(1, 2, 3, 4);</pre>
        </details>
        </p>

        <!-- debug.getctable -->
        <hr/><h3><a name="debug.getctable"><code>debug.getctable ()</code></a></h3>
        <p>
        Returns the C table (see <a href="#4.3">&sect;4.3</a>).
        </p>

        <!-- debug.getclist -->
        <hr/><h3><a name="debug.getclist"><code>debug.getclist ()</code></a></h3>
        <p>
        Returns the C list (see <a href="#4.3">&sect;4.3</a>).
        </p>

        <!-- debug.getupvalue -->
        <hr/><h3><a name="debug.getupvalue"><code>debug.getupvalue (f, i)</code></a></h3>
        <p>
        This function returns the name and the value of the upvalue
        with index <code>i</code> (starting from 0) of the function
        <code>f</code>.
        The function returns <b>fail</b> if there is no upvalue with the
        given index.
        <br/><br/>
        (For Tokudae functions,
        upvalues are the external local variables that the function uses,
        and that are consequently included in its closure.)
        <br/><br/>
        For C&nbsp;functions, this function uses the empty string
        <code>""</code> as a name for all upvalues.
        <br/><br/>
        For example,
        see <a href="#debug.setupvalue"><code>debug.setupvalue</code></a>.
        </p>

        <!-- debug.upvaluejoin -->
        <hr/><h3><a name="debug.upvaluejoin"><code>debug.upvaluejoin (f1, i1, f2, i2)</code></a></h3>
        <p>
        Make the upvalue at index <code>i1</code> of the Tokudae closure
        <code>f1</code> refer to the upvalue at index <code>i2</code> of the
        Tokudae closure <code>f2</code>.
        <br/><br/>
        For example,
        see <a href="#debug.upvalueid"><code>debug.upvalueid</code></a>.
        </p>

        <!-- debug.upvalueid -->
        <hr/><h3><a name="debug.upvalueid"><code>debug.upvalueid (f, i)</code></a></h3>
        <p>
        Returns a unique identifier (as a light userdata)
        for the upvalue at index <code>i</code> from the given function.
        <br/><br/>
        These unique identifiers allow a program to check whether different
        closures share upvalues.
        Tokudae closures that share an upvalue
        (that is, that access a same external local variable)
        will return identical ids for those upvalue indices.
        <details class = "example">
            <summary>Example</summary>
            <pre>
local foo1, foo2, foo3;
{
    local a, b, c = 3, 5, 7;
    foo1 = || :: return a+b;
    foo2 = || :: return b+a;
    {
        local a = 10;
        foo3 = || :: return a+b;
    }
}

assert(debug.upvalueid(foo1, 0));
assert(debug.upvalueid(foo1, 1));
assert(!debug.upvalueid(foo1, 2));
assert(debug.upvalueid(foo1, 0) == debug.upvalueid(foo2, 1));
assert(debug.upvalueid(foo1, 1) == debug.upvalueid(foo2, 0));
assert(debug.upvalueid(foo3, 0));
assert(debug.upvalueid(foo1, 0) != debug.upvalueid(foo3, 0));
assert(debug.upvalueid(foo1, 1) == debug.upvalueid(foo3, 1));

assert(foo1() == 3 + 5 and foo2() == 5 + 3);
debug.upvaluejoin(foo1, 1, foo2, 1);
assert(foo1() == 3 + 3 and foo2() == 5 + 3);
assert(foo3() == 10 + 5);
debug.upvaluejoin(foo3, 1, foo2, 0);
assert(foo3() == 10 + 5);
debug.upvaluejoin(foo3, 1, foo2, 1);
assert(foo3() == 10 + 3);</pre>
        </details>
        </p>

        <!-- debug.setuservalue -->
        <hr/><h3><a name="debug.setuservalue"><code>debug.setuservalue (udata, value, i)</code></a></h3>
        <p>
        Sets the given <code>value</code> as the user value associated to
        the given <code>udata</code> at index <code>i</code>.
        <code>udata</code> must be a full userdata.
        <br/><br/>
        Returns <code>udata</code>,
        or <b>fail</b> if the userdata does not have that value.
        <details class = "example">
            <summary>Example</summary>
            <pre>
assert(!debug.setuservalue(io.stdin, 10));

local a, b = debug.getuservalue(io.stdin, 10);
assert(a == nil and !b);</pre>
        </details>
        </p>

        <!-- debug.sethook -->
        <hr/><h3><a name="debug.sethook"><code>debug.sethook ([thread, ]hook, mask[, count])</code></a></h3>
        <p>
        Sets the given function as the debug hook.
        The string <code>mask</code> and the number <code>count</code>
        describe when the hook will be called.
        The string mask may have any combination of the following characters,
        with the given meaning:
        <ul>
            <li>
                <b>'<code>c</code>'</b>:
                the hook is called every time Tokudae calls a function;
            </li>
            <li>
                <b>'<code>r</code>'</b>:
                the hook is called every time Tokudae returns from a function;
            </li>
            <li>
                <b>'<code>l</code>'</b>:
                the hook is called every time Tokudae enters a new line of code.
            </li>
        </ul>
        Moreover, with a <code>count</code> different from zero,
        the hook is called also after every <code>count</code> instructions.
        <br/><br/>
        When called without arguments,
        <a href="#debug.sethook"><code>debug.sethook</code></a>
        turns off the hook.
        <br/><br/>
        When the hook is called, its first parameter is a string
        describing the event that has triggered its call:
        <code>"call"</code>, <code>"return"</code>, <code>"line"</code>
        and <code>"count"</code>.
        For line events,
        the hook also gets the new line number as its second parameter.
        Inside a hook,
        you can call <code>getinfo</code> with level&nbsp;2 to get more
        information about the running function.
        (Level&nbsp;0 is the <code>getinfo</code> function,
        and level&nbsp;1 is the hook function.)
        <br/><br/>
        <details class = "example">
            <summary>Example</summary>
            <pre>
/// define a hook function
fn myhook(event, line) {
    assert(event == "line");
    printf("Current line: %", line);
}

/// set the hook for line events
debug.sethook(myhook, "l");

fn test() {
    local x = 10;
    local y = 20;
    local z = x + y;
    print(z);
}

test();

/// turn off the hook
assert(debug.gethook() == myhook);
debug.sethook();
assert(!debug.gethook());

/// This script prints:
/// Current line: 10
/// Current line: 15
/// Current line: 17
/// Current line: 11
/// Current line: 12
/// Current line: 13
/// Current line: 14
/// 30
/// Current line: 15
/// Current line: 20
/// Current line: 21</pre>
        </details>
        </p>

        <!-- debug.setlocal -->
        <hr/><h3><a name="debug.setlocal"><code>debug.setlocal ([thread, ]level, local, value)</code></a></h3>
        <p>
        This function assigns the value <code>value</code> to the
        local variable with index <code>local</code> of the function
        at level <code>level</code> of the stack.
        The function returns <b>fail</b> if there is no local
        variable with the given index,
        and raises an error when called with a <code>level</code> out of range.
        (You can call <code>getinfo</code> to check whether the level is valid.)
        Otherwise, it returns the name of the local variable.
        <br/><br/>
        See <a href="#debug.getlocal"><code>debug.getlocal</code></a> for
        more information about variable indices and names.
        <details class = "example">
            <summary>Example</summary>
            <pre>
fn sample(a, b, ...) {
    local x = 10;
    local y = 20;

    /// change parameter 'a' (index 1)
    local name = debug.setlocal(1, 1, 100);
    assert(name == "a" and a == 100);

    /// change local 'x' (index 3)
    name = debug.setlocal(1, 3, 999);
    assert(name == "x" and x == 999);

    /// change first vararg
    assert(... == 5);
    name = debug.setlocal(1, -1, "test");
    assert(name == "(vararg)" and ... == "test");

    /// invalid index
    assert(!debug.setlocal(1, 10, 42));
}

sample(1, 2, 5);</pre>
        </details>
        </p>

        <!-- debug.setupvalue -->
        <hr/><h3><a name="debug.setupvalue"><code>debug.setupvalue (f, i, value)</code></a></h3>
        <p>
        This function assigns the value <code>value</code> to the upvalue
        with index <code>i</code> of the function <code>f</code>.
        The function returns <b>fail</b> if there is no upvalue
        with the given index.
        Otherwise, it returns the name of the upvalue.
        <br/><br/>
        See <a href="#debug.getupvalue"><code>debug.getupvalue</code></a>
        for more information about upvalues.
        <details class = "example">
            <summary>Example</summary>
            <pre>
local env = {};
local f = assert(load("a = 1; b = 2; c = 3;"));
assert(debug.setupvalue(f, 0, env) == "__ENV");

f();

/// current chunk environment is not changed
assert(!a and !b and !c);
/// however the 'env' table is
assert(env.a == 1 and env.b == 2 and env.c == 3);

/// get the first upvalue (index 0)
local name, val = debug.getupvalue(f, 0);
assert(name == "__ENV" and val == env);

/// upvalue doesn't exist
name, val = debug.getupvalue(f, 1);
assert(!name and !val);
assert(!debug.setupvalue(f, 2, "test"));</pre>
        </details>
        </p>

        <!-- debug.traceback -->
        <hr/><h3><a name="debug.traceback"><code>debug.traceback ([thread, ][message[, level]])</code></a></h3>
        <p>
        If <code>message</code> is present but is neither a string nor
        <b>nil</b>, this function returns <code>message</code> without
        further processing.
        Otherwise,
        it returns a string with a traceback of the call stack.
        The optional <code>message</code> string is appended
        at the beginning of the traceback.
        An optional <code>level</code> number tells at which level
        to start the traceback
        (default is 1, the function calling <code>traceback</code>).
        <details class = "example">
            <summary>Example</summary>
            <pre>
fn idiv(x, y) :: return x // y;

fn safe_call(err) {
    local ok, result = pcall(idiv, 10, 0); /// division by zero
    if !ok /* error? */
        return ok, debug.traceback(err); /* propagate but append traceback */
    else
        return ok, result;
}

/* error object is a string */
local res, err = safe_call("my prefix");
assert(!res and string.startswith(err, "my prefix\n"));

/* error object is not a string */
res, err = safe_call(5);
assert(!res and err == 5);
local l = ["bla", 5];
res, err = safe_call(l);
assert(!res and err == l);</pre>
        </details>
        </p>

        <!-- debug.stackinuse -->
        <hr/><h3><a name="debug.stackinuse"><code>debug.stackinuse ([thread])</code></a></h3>
        <p>
        Returns the total stack usage of a thread, a number.
        </p>

        <!-- debug.cstacklimit -->
        <hr/><h3><a name="debug.cstacklimit"><code>debug.cstacklimit</code></a></h3>
        <p>
        Maximum depth for nested C calls (a number, not a function).
        <br/>
        This is installation dependant
        (see <code>TOKUI_MAXSTACK</code> in <code>tokudaeconf.h</code>).
        </p>

        <!-- debug.maxstack -->
        <hr/><h3><a name="debug.maxstack"><code>debug.maxstack</code></a></h3>
        <p>
        Maximum size of C stack (a number, not a function).
        <br/>
        This is installation dependant
        (see <code>TOKUI_MAXCCALLS</code> in <code>tokudaelimits.h</code>).
        </p>




        <h1>7 &ndash; <a name="7">Tokudae Standalone</a></h1>
        <p>
        An interpreter for Tokudae as a standalone language,
        called simply <code>tokudae</code>,
        is provided with the standard distribution.
        The standalone interpreter includes
        all standard libraries.
        Its usage is:

        <pre>
    tokudae [options] [script [args]]</pre>

        The options are:
        <ul>
            <li>
                <b><code>-e <em>stat</em></code></b>:
                execute string <em>stat</em>;
            </li>
            <li>
                <b><code>-i</code></b>:
                enter interactive mode after running <em>script</em>;
            </li>
            <li>
                <b><code>-l <em>mod</em></code></b>:
                "require" <em>mod</em> and assign the result to
                global <em>mod</em>;
            </li>
            <li>
                <b><code>-l <em>g=mod</em></code></b>:
                "require" <em>mod</em> and assign the result to
                global <em>g</em>;
            </li>
            <li><b><code>-v</code></b>: print version information;</li>
            <li><b><code>-W</code></b>: turn warnings on;</li>
            <li><b><code>-E</code></b>: ignore environment variables;</li>
            <li><b><code>-h</code></b>: show help;</li>
            <li><b><code>--</code></b>: stop handling options;</li>
            <li>
                <b><code>-</code></b>:
                execute <code>stdin</code> as a file and stop handling options.
            </li>
        </ul>
        After handling its options, <code>tokudae</code> runs the
        given <em>script</em>.
        (Unless option '<code>h</code>' was provided, in which case it
        displays help and returns without running anything else).
        When called without arguments,
        <code>tokudae</code> behaves as <code>tokudae -v -i</code>
        when the standard input (<code>stdin</code>) is a terminal,
        and as <code>tokudae -</code> otherwise.
        <br/><br/>
        When called without the option <code>-E</code>,
        the interpreter checks for an environment variable
        <a name="TOKU_INIT_1_0"><code>TOKU_INIT_1_0</code></a>
        (or <a name="TOKU_INIT"><code>TOKU_INIT</code></a> if the versioned
        name is not defined) before running any argument.
        If the variable content has the format
        <code>@<em>filename</em></code>,
        then <code>tokudae</code> executes the file.
        Otherwise, <code>tokudae</code> executes the string itself.
        <br/><br/>
        When called with the option <code>-E</code>,
        Tokudae does not consult any environment variables.
        In particular,
        the values of <a href="#package.path"><code>package.path</code></a>
        and <a href="#package.cpath"><code>package.cpath</code></a>
        are set with the default paths defined in <code>tokudaeconf.h</code>.
        To signal to the libraries that this option is on,
        the stand-alone interpreter sets the field
        <code>"TOKU_NOENV"</code> in the C table
        (see <a href="#4.3">&sect;4.3</a>) to a true value.
        Other libraries may consult this field for the same purpose.
        <br/><br/>
        The options <code>-e</code>, <code>-l</code>, and <code>-W</code>
        are handled in the order they appear.
        For instance, an invocation like

        <pre>
    $ tokudae -e 'a=1;' -llib1 script.toku</pre>

        will first set <code>a</code> to 1, then import the library
        <code>lib1</code>, and finally run the file <code>script.toku</code>
        with no arguments.
        (Here <code>$</code> is the shell prompt. Your prompt may be different.)
        <br/><br/>
        Before running any code,
        <code>tokudae</code> collects all command-line arguments
        in two different global lists called <code>cliargs</code>
        and <code>args</code>.
        The script name goes to index 0 in the <code>args</code> list,
        the first argument after the script name goes to index 1,
        and so on.
        Any arguments before the script name
        (that is, the interpreter name plus its options)
        go to the <code>cliargs</code> list.
        For instance, in the call

        <pre>
    $ tokudae -la b.toku t1 t2</pre>

        the lists are like this:

        <pre>
    cliargs = ["tokudae", "-la"];
    args = ["b.toku", "t1", "t2"];</pre>

        If there is no script in the call,
        the <code>args</code> is empty.
        For instance, the call

        <pre>
     $ tokudae -e "print(args[0]);"</pre>

        will print "<code>nil</code>".
        If there is a script,
        the script is called with arguments
        <code>args[0]</code>, &middot;&middot;&middot;,
        <code>args[args.len - 1]</code> (or <code>args.last</code>).
        Like all chunks in Tokudae,
        the script is compiled as a variadic function.
        <br/><br/>
        In interactive mode,
        Tokudae repeatedly prompts and waits for a line.
        After reading a line,
        Tokudae first tries to interpret the line as an expression.
        If it succeeds, it prints its value.
        Otherwise, it interprets the line as a chunk.
        If you write an incomplete chunk,
        the interpreter waits for its completion
        by issuing a different prompt.
        <br/><br/>
        Note that, as each complete line is read as a new chunk,
        local variables do not outlive lines.
        To steer clear of confusion,
        the interpreter gives a warning if a line starts with the
        reserved word <b>local</b>:

        <pre>
    &gt; x = 20;     /// global 'x'
    &gt; local x = 10; print(x)
       --&gt; warning: locals do not survive across lines in interactive mode
       --&gt; 10
    &gt; print(x);    /// back to global 'x'
       --&gt; 20
    &gt; {        /// incomplete chunk
    &gt;&gt; local x = 10; print(x);   /// '&gt;&gt;' prompts for line completion
    &gt;&gt; print(x);
    &gt;&gt; }       /// chunk completed
       --&gt; 10
       --&gt; 10</pre>

        <p>
        If the global variable <a name="__PROMPT"><code>__PROMPT</code></a>
        contains a string, then its value is used as the prompt.
        Similarly, if the global variable
        <a name="__PROMPT2"><code>__PROMPT2</code></a> contains a string,
        its value is used as the secondary prompt
        (issued during incomplete statements).
        <br/><br/>
        In case of unprotected errors in the script,
        the interpreter reports the error to the standard error stream.
        If the error object is not a string but
        has a metamethod <code>__tostring</code>,
        the interpreter calls this metamethod to produce the final message.
        Otherwise, the interpreter converts the error object to a string
        and adds a stack traceback to it.
        When warnings are on,
        they are simply printed in the standard error output.
        <br/><br/>
        When finishing normally,
        the interpreter closes its main Tokudae state
        (see <a href="#toku_close"><code>toku_close</code></a>).
        The script can avoid this step by
        calling <a href="#os.exit"><code>os.exit</code></a> to terminate.
        <br/><br/>
        As lines starting with <code>#</code> are interpreted as comment
        lines (are ignored), Tokudae scripts can be made into executable
        programs on Unix systems by using <code>chmod +x</code> and
        the&nbsp;<code>#!</code> form, as in

        <pre>
    #!/usr/local/bin/tokudae</pre>

        Of course,
        the location of the Tokudae interpreter may be different in your machine.
        <br/>
        If <code>tokudae</code> is in your <code>PATH</code>, then

        <pre>
    #!/usr/bin/env tokudae</pre>

        is a more portable solution.
        </p>




        <h1>8 &ndash; <a name="8">The Complete Syntax of Tokudae</a></h1>
        <p>
        Here is the complete syntax of Tokudae in extended BNF.
        As usual in extended BNF, {A} means 0 or more As, and [A] means an
        optional A.
        (For operator precedences, see <a href="#3.4.7">&sect;3.4.7</a>;
        for a description of the comments and the terminals Name, Numeral,
        and LiteralString, see <a href="#3.1">&sect;3.1</a>.)
        see <a href="#3.1">&sect;3.1</a>.)
        <br/><br/>

        <pre>
        chunk ::= block
        
        assignop ::= &lsquo;<b>=</b>&rsquo; | &lsquo;<b>+=</b>&rsquo; | &lsquo;<b>-=</b>&rsquo;
                   | &lsquo;<b>*=</b>&rsquo; | &lsquo;<b>/=</b>&rsquo; | &lsquo;<b>//=</b>&rsquo;
                   | &lsquo;<b>**=</b>&rsquo; | &lsquo;<b>%=</b>&rsquo; | &lsquo;<b>&amp;=</b>&rsquo;
                   | &lsquo;<b>|=</b>&rsquo; | &lsquo;<b>^=</b>&rsquo; | &lsquo;<b>&gt;&gt;=</b>&rsquo;
                   | &lsquo;<b>&lt;&lt;=</b>&rsquo; | &lsquo;<b>..=</b>&rsquo;
        
        expstm ::= varlist assignop explist | var &lsquo;<b>++</b>&rsquo; | var &lsquo;<b>--</b>&rsquo;
        
        varlist ::= var {&lsquo;<b>,</b>&rsquo; var}
        
        var ::= Name | prefixexp &lsquo;<b>[</b>&rsquo; exp &lsquo;<b>]</b>&rsquo; | prefiexp &lsquo;<b>.</b>&rsquo; Name
        
        breakstm ::= <b>break</b> &lsquo;<b>;</b>&rsquo;
        
        continuestm ::= <b>continue</b> &lsquo;<b>;</b>&rsquo;
        
        fnstm ::= <b>fn</b> dottedname parenparams funcbody
        
        classstm ::= <b>class</b> dottedname [inherit] [classbodystm]
        
        dottedname ::= Name {&lsquo;<b>.</b>&rsquo; Name}
        
        loopstm ::= <b>loop</b> stm
        
        whilestm ::= <b>while</b> exp stm
        
        dowhilestm ::= <b>do</b> stm <b>while</b> exp &lsquo;<b>;</b>&rsquo;
        
        forinit ::= localstm | expstm
        
        forinfix ::= [forinit] &lsquo;<b>;</b>&rsquo; [exp] &lsquo;<b>;</b>&rsquo; [expstm]
        
        forclauses ::= &lsquo;<b>(</b>&rsquo; forinfix &lsquo;<b>)</b>&rsquo; | forinfix &lsquo;<b>;</b>&rsquo;
        
        forstm ::= <b>for</b> forclauses stm
        
        forexplist ::= exp [&lsquo;<b>,</b>&rsquo; exp]
                     | exp &lsquo;<b>,</b>&rsquo; exp [&lsquo;<b>,</b>&rsquo; exp]
                     | exp &lsquo;<b>,</b>&rsquo; exp &lsquo;<b>,</b>&rsquo; exp [&lsquo;<b>,</b>&rsquo; exp]
        
        foreachstm ::= <b>foreach</b> namelist <b>in</b> forexplist stm
        
        ifstm ::= <b>if</b> exp stm [<b>else</b> stm]
        
        switchbody ::= &lsquo;<b>{</b>&rsquo; {<b>case</b> exp &lsquo;<b>:</b>&rsquo; {stm}} [<b>default</b> &lsquo;<b>:</b>&rsquo; {stm}] &lsquo;<b>}</b>&rsquo;
        
        switchstm ::= <b>switch</b> exp switchbody
        
        switchblock ::= {decl} [breakstm] | block
        
        loopblock ::= {decl} [continuestm] | switchblock
        
        blockstm ::= &lsquo;<b>{</b>&rsquo; loopblock &lsquo;<b>}</b>&rsquo;
        
        returnstm ::= <b>return</b> [explist] [&lsquo;<b>;</b>&rsquo;]
        
        functiondef ::= <b>fn</b> parenparams funcbody | pipeparams funcbody
        
        sep ::= &lsquo;<b>,</b>&rsquo; | &lsquo;<b>;</b>&rsquo;
        
        elementlist ::= exp {sep exp} [sep]
        
        listdef ::= &lsquo;<b>[</b>&rsquo; [elementlist] &lsquo;<b>]</b>&rsquo;
        
        field ::= &lsquo;<b>[</b>&rsquo; exp &lsquo;<b>]</b>&rsquo; &lsquo;<b>=</b>&rsquo; exp | Name &lsquo;<b>=</b>&rsquo; exp
        
        fieldlist ::= field {sep field} [sep]
        
        tabledef ::= &lsquo;<b>{</b>&rsquo; [fieldlist] &lsquo;<b>}</b>&rsquo;
        
        pipeparams ::= &lsquo;<b>|</b>&rsquo; [parameters] &lsquo;<b>|</b>&rsquo;
        
        classbody ::= &lsquo;<b>{</b>&rsquo; {classvalue} &lsquo;<b>}</b>&rsquo;
        
        method ::= <b>fn</b> Name parenparams funcbody
        
        localfn ::= <b>local</b> <b>fn</b> Name parenparams funcbody
        
        parenparams ::= &lsquo;<b>(</b>&rsquo; [parameters] &lsquo;<b>)</b>&rsquo;
        
        parameters ::= namelist [&lsquo;<b>,</b>&rsquo; &lsquo;<b>...</b>&rsquo;] | &lsquo;<b>...</b>&rsquo;
        
        namelist ::= Name {&lsquo;<b>,</b>&rsquo; Name}
        
        funcbody ::= [&lsquo;<b>::</b>&rsquo;] funcblock
        
        funcblock ::= &lsquo;<b>{</b>&rsquo; block &lsquo;<b>}</b>&rsquo; | stm
        
        block ::= {decl} [returnstm]
        
        decl ::= localstm &lsquo;<b>;</b>&rsquo; | localfn | localclass | stm
        
        localstm ::= <b>local</b> attnamelist [&lsquo;<b>=</b>&rsquo; explist]
        
        attnamelist ::= Name [attrib] {&lsquo;<b>,</b>&rsquo; Name [attrib]}
        
        attrib ::= &lsquo;<b>&lt;</b>&rsquo; Name &lsquo;<b>&gt;</b>&rsquo;
        
        localclass ::= <b>local</b> <b>class</b> Name [inherit] [classbodystm]
        
        stm ::= &lsquo;<b>;</b>&rsquo; | expstm &lsquo;<b>;</b>&rsquo; | call &lsquo;<b>;</b>&rsquo; | breakstm | continuestm | fnstm
              | classstm | loopstm | whilestm | dowhilestm | forstm | foreachstm
              | ifstm | switchstm | blockstm | returnstm
        
        classdef ::= <b>class</b> [inherit] [classbodystm]
        
        inherit ::= <b>inherits</b> exp
        
        classbodystm ::= &lsquo;<b>{</b>&rsquo; {classvaluestm} &lsquo;<b>}</b>&rsquo;
        
        classvaluestm ::= classvalue | localstm &lsquo;<b>;</b>&rsquo;
        
        classvalue ::= method | metafield
        
        metafield ::= Name &lsquo;<b>=</b>&rsquo; exp &lsquo;<b>;</b>&rsquo;
        
        prefixexp ::= var | call [&lsquo;<b>?</b>&rsquo;] | &lsquo;<b>(</b>&rsquo; exp &lsquo;<b>)</b>&rsquo; | <b>super</b>
        
        call ::= prefixexp &lsquo;<b>(</b>&rsquo; [explist] &lsquo;<b>)</b>&rsquo;
        
        explist ::= exp {&lsquo;<b>,</b>&rsquo; exp}
        
        binop ::= &lsquo;<b>+</b>&rsquo; | &lsquo;<b>-</b>&rsquo; | &lsquo;<b>*</b>&rsquo; | &lsquo;<b>/</b>&rsquo; | &lsquo;<b>//</b>&rsquo; | &lsquo;<b>**</b>&rsquo; | &lsquo;<b>%</b>&rsquo;
                | &lsquo;<b>&amp;</b>&rsquo; | &lsquo;<b>~</b>&rsquo; | &lsquo;<b>|</b>&rsquo; | &lsquo;<b>^</b>&rsquo; | &lsquo;<b>&gt;&gt;</b>&rsquo; | &lsquo;<b>&lt;&lt;</b>&rsquo; | &lsquo;<b>..</b>&rsquo;
                | &lsquo;<b>&lt;</b>&rsquo; | &lsquo;<b>&lt;=</b>&rsquo; | &lsquo;<b>&gt;</b>&rsquo; | &lsquo;<b>&gt;=</b>&rsquo; | &lsquo;<b>==</b>&rsquo;| &lsquo;<b>!=</b>&rsquo;
                | and | or
        
        unop ::= &lsquo;<b>-</b>&rsquo; | &lsquo;<b>!</b>&rsquo; | &lsquo;<b>~</b>&rsquo;
        
        exp ::= <b>true</b> | <b>false</b> | <b>nil</b> | &lsquo;<b>...</b>&rsquo; | Numeral | LiteralString
              | listdef | tabledef | functiondef | classdef | prefixexp
              | exp binop exp | unop exp</pre>
        </p>


        <p class="footer">
        <br/><br/>
        Last update:
        Sun Sep 14 01:48:14 UTC 2025
        </p>
    </body>
</html>
