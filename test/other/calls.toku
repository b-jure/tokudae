local debug = import("debug");

assert(typeof(1<2) == "boolean");
assert(typeof(true) == "boolean" and typeof(false) == "boolean");
assert(typeof(nil) == "nil"
   and typeof(-3) == "number"
   and typeof(inf) == "number"
   and typeof(infinity) == "number"
   and typeof("x") == "string"
   and typeof({}) == "table"
   and typeof([]) == "list"
   and typeof(class{}) == "class"
   and typeof((class{})()) == "instance"
   and typeof(typeof) == "function");

assert(typeof(assert) == typeof(print));
local fn f(x) { return a.x(a, x); }
assert(typeof(f) == "function");
assert(!pcall(typeof));


/// testing local-function recursion
fact = false;
{
  local res = 1;
  local fn fact(n) {
    if (n==0) return res;
    else return n*fact(n-1);
  }
  assert(fact(5) == 120);
}
assert(fact == false);
fact = nil;

{ /// testing declarations
    local class X {
        fn x(x) { return x + self.i; }
    };
    local b = X(); b.i = 10;
    local a = {i = 10};
    local self = 20;
    fn a.y(x) { return x+self; }

    assert(b.x(1)+10 == a.y(1));

    {
        local a;
        local class Y {
            fn add(x) {
                self.x, a.y = self.x+x, 20;
                return self;
            }
        }
        a = Y(); a.x = 0;
        assert(a.add(10).add(20).add(30).x == 60 and a.y == 20);
    }

    {
        local a = {b={}};
        fn a.b.f1(x) { return x+1; }
        class a.b.c {
            fn f2(x,y) { self[x] = y; }
        }
        a.b.c = a.b.c();
        assert(a.b.f1(4) == 5);
        a.b.c.f2("k", 12);
        assert(a.b.c.k == 12);
    }
}

t = nil; /// 'declare' t
fn f(a,b,c) {
    local d = "a";
    t=[a,b,c,d];
}

f(      /// this line change must be valid
  1,2);
assert(t[0] == 1 and t[1] == 2 and t[2] == nil and t[3] == nil);
f(1,2,   /// this one too
      3,4);
assert(t[0] == 1 and t[1] == 2 and t[2] == 3 and t[3] == "a");

t = nil; /// delete 't'

fn fat(x) {
    if (x <= 1)
        return 1;
    else
        return x*load("return fat(" .. tostr(x-1) .. ");", "")();
}

assert(load("load(\"assert(fat(6)==720);\")();"))();
local a = load("return fat(5), 3;");
{
    local a,b = a();
    assert(a == 120 and b == 3);
}
fat = nil;

local fn err_on_n(n) {
    if (n==0) { error(); exit(1); }
    else { err_on_n(n-1); exit(1); }
}

{
    local fn dummy(n) {
        if (n > 0) {
            assert(!pcall(err_on_n, n));
            dummy(n-1);
        }
    }
    dummy(10);
}

__G.deep = nil;

fn deep(n) {
    if (n>0) deep(n-1);
}
deep(10);
deep(180);


print("testing tail calls");

fn deep(n) {
    if (n>0) return deep(n-1);
    else return 101;
}
assert(deep(30000) == 101);
a = (class {
    fn deep(n) {
        if (n>0) return self.deep(n-1);
        else return 101;
    }
})();
assert(a.deep(30000) == 101);

{ /// tail calls x varargs
    local fn foo(x, ...) { local a = [...]; return x, a[0], a[1]; }

    local fn foo1(x) { return foo(10, x, x + 1); }

    local a, b, c = foo1(-2);
    assert(a == 10 and b == -2 and c == -1);

    /// tail calls x metamethods
    local z = setmetatable(class {}, { __call = foo })();
    local fn foo2(x) { return z(10, x); };
    a, b, c = foo2(100);
    assert(a == z and b == 10 and c == 100);

    a, b = (fn () { return foo(); })();
    assert(a == nil and b == nil);

    local X, Y, A;
    foo = fn(x, y, ...) { X = x; Y = y; A = [...]; };
    foo1 = fn(...) { return foo(...); };

    a, b, c = foo1();
    assert(X == nil and Y == nil and len(A) == 0);

    a, b, c = foo1(10);
    assert(X == 10 and Y == nil and len(A) == 0);

    a, b, c = foo1(10, 20);
    assert(X == 10 and Y == 20 and len(A) == 0);

    a, b, c = foo1(10, 20, 30);
    assert(X == 10 and Y == 20 and len(A) == 1 and A[0] == 30);
}


{ /// C-stack overflow while handling C-stack overflow
    local fn infloop() {
        assert(pcall(infloop));
    }
    local err, msg = xpcall(infloop, infloop);
    assert(!err and string.find(msg, "error"));
}



{ /// tail calls x chain of __call
    local n = 10000; /// depth

    local fn foo() {
        if (n == 0)
            return 1023;
        else {
            n = n - 1;
            return foo();
        }
    }

    /// build a chain of __call metamethods ending in function 'foo'
    foreach i in range(15)
        foo = setmetatable(class {}, { __call = foo })();

    assert((fn() { return foo(); })() == 1023);
}


{  
    print("testing chains of '__call'");
    local N = 15;
    local u = (class { __call = fn(...) { return [...]; }; })();
    foreach i in range(N) {
        u = setmetatable(class {}, { __call = u })();
        u[0] = i;
    }
    local Res = u("a", "b", "c");
    assert(len(Res) == N + 3);
    foreach i in range(N)
        assert(Res[i][0] == i);
    assert(Res[N] == "a" and Res[N+1] == "b" and Res[N+2] == "c");
}


{
    print("testing chains of '__init'");
    local N = 15;
    local u = (class { __init = fn(...) { return [...]; }; });
    foreach i in range(N)
        u = setmetatable(class {}, { __init = u });
    local Res = u("a", "b", "c");
    assert(len(Res) == N + 3);
    foreach i in range(N)
        assert(typeof(Res[i]) == "instance");
    assert(Res[N] == "a" and Res[N+1] == "b" and Res[N+2] == "c");
}


a = nil;
(fn(x) { a=x; })(23);
assert(a == 23 and (fn (x) { return x*2; })(20) == 40);


/// testing closures

/// fixed-point operator
local Z = fn(le) {
    local fn a(f) {
        return le(fn(x) { return f(f)(x); });
    };
    return a(a);
};


/// non-recursive factorial
local F = fn(f) {
    return fn(n) {
        if (n == 0) return 1;
        else return n*f(n-1);
    };
};

local fat = Z(F);

assert(fat(0) == 1 and fat(4) == 24 and Z(F)(5)==5*Z(F)(4));

local fn g(z) {
    local fn f(a,b,c,d) {
        return fn(x,y) { return a+b+c+d+a+x+y+z; };
    }
    return f(z,z+1,z+2,z+3);
}

f = g(10);
assert(f(9, 16) == 10+11+12+13+10+9+16+10);



/// testing multiple returns

local fn unlpack(l, i) {
    i = i or 0;
    if (i < len(l))
        return l[i], unlpack(l, i+1);
}

local fn equallst(l1, l2) {
  assert(len(l1) == len(l2));
  foreach i in range(0, len(l1))
      assert(l1[i] == l2[i]);
}

local pack = |...| :: { return [...] };

f = fn() { return 1,2,30,4; };
local fn ret2(a,b) { return a,b; }

local b,c,d;
a,b,c,d = unlpack([1,2,3]);
assert(a==1 and b==2 and c==3 and d==nil);
a = [1,2,3,4,false,10,"alo",false,assert];
equallst(pack(unlpack(a)), a);
equallst(pack(unlpack(a), -1), [1,-1]);
a,b,c,d = ret2(f()), ret2(f());
assert(a==1 and b==1 and c==2 and d==nil);
a,b,c,d = unlpack(pack(ret2(f()), ret2(f())));
assert(a==1 and b==1 and c==2 and d==nil);
a,b,c,d = unlpack(pack(ret2(f()), (ret2(f()))));
assert(a==1 and b==1 and c==nil and d==nil);

a = ret2([unlpack([1,2,3]), unlpack([3,2,1]), unlpack(["a", "b"])]);
assert(a[0] == 1 and a[1] == 3 and a[2] == "a" and a[3] == "b");


/// testing calls with 'incorrect' arguments
rawget((class {})(), "x", 1);
rawset((class {})(), "x", 1, 2);
assert(math.sin(1,2) == math.sin(1));


/// test for generic load
local x = "/// a comment\0\0\0\n  x = 10 + \n23; \
           local a = fn() { x = \"hi\"; }; \
           return \"\0\";";
local fn read1(x) {
    local i = -1;
    return fn() {
        gc();
        i++;
        return string.substr(x, i, i);
    };
}

local fn cannotload(msg, a,b) {
    assert(!a and string.find(b, msg));
}

a = assert(load(read1(x), "modname", "t", __G));
assert(a() == "\0" and __G.x == 33);

a = assert(load(fn() { return nil; }));
a(); /// empty chunk

assert(!load(fn() { return true; }));


{
    local l = [nil, "return ", "3;"];
    local f, msg = load(|| :: return list.remove(l, 0));
    assert(f() == nil); /// should read the empty chunk
}


{ /// loading a binary long string interrupted by GC cycles
    local f = string.dump(|| {
        return "01234567890123456789012345678901234567890123456789"
    });
    f = load(read1(f));
    assert(f() == "01234567890123456789012345678901234567890123456789");
}


cannotload("unexpected symbol", load(read1("*a = 123")));
cannotload("unexpected symbol", load("*a = 123"));
cannotload("hhi", load(fn() { error("hhi"); }));


{ /// any value is valid for __ENV
    assert(load("return __ENV;", nil, nil, 123)() == 123);
}


{ /// load when __ENV is not first upvalue
    local x;
    XX = 123;
    local fn h() {
        local y=x; /// use 'x', so that it becomes 1st upvalue
        return XX; /// global name
    };
    local d = string.dump(h);
    x = load(d, "", "b");
    assert(debug.getupvalue(x, 1) == "__ENV");
    debug.setupvalue(x, 1, __G);
    assert(x() == 123);
    assert(assert(load("return XX + ...;", nil, nil, {XX = 13}))(4) == 17);
    XX = nil;
}


{ /// test generic load with nested functions
    local x = [=[
        return fn(x) {
            return fn(y) {
                return fn(z) {
                    return x+y+z;
                };
            };
        };
    ]=];
    local a = assert(load(read1(x), "read"));
    assert(a()(2)(3)(10) == 15);
}


{ /// test for long method names
    local t = {x = 1};
    fn t._012345678901234567890123456789012345678901234567890123456789(self) {
        return self.x;
    }
    assert(t._012345678901234567890123456789012345678901234567890123456789(t) == 1);
    t = class {
        __init = fn() {
            self.x = 1;
            return self;
        };
        fn _012345678901234567890123456789012345678901234567890123456789() {
            return self.x;
        }
    };
    assert(t()._012345678901234567890123456789012345678901234567890123456789() == 1);
}


{ /// test for dump/undump with upvalues
    local a, b = 20, 30;
    x = load(string.dump(|x| {
        if x == "set" {
            a = 10+b;
            b++;
        } else
            return a;
    }), "", "b", nil);
    assert(x() == nil);
    assert(debug.setupvalue(x, 0, "hi") == "a");
    assert(x() == "hi");
    assert(debug.setupvalue(x, 1, 13) == "b");
    assert(!debug.setupvalue(x, 2, 10)); /// only 2 upvalues
    x("set");
    assert(x() == 23);
    x("set");
    assert(x() == 24);
}


{ /// test for dump/undump with many upvalues
    local nup = 5000;
    local prog = ["local a0"];
    local i;
    for (i = 1; i < nup; i++) prog[prog.len] = ", a" .. tostr(i);
    prog[prog.len] = " = 0";
    for (i = 1; i < nup; i++) prog[prog.len] = ", " .. tostr(i);
    local sum = 0;
    prog[prog.len] = "; return fn() { return a0";
    for (i = 1; i < nup; i++) { prog[prog.len] = " + a" .. tostr(i); sum+=i; }
    prog[prog.len] = " };";
    prog = list.concat(prog);
    local f = assert(load(prog))();
    assert(f() == sum);

    f = load(string.dump(f)); /// main chunk now has many upvalues
    local a = 10;
    local h = || { return a };
    for (i = 0; i < nup; i++)
        debug.upvaluejoin(f, i, h, 0);
    assert(f() == 10 * nup);
}


{ /// test binary chunks
    print("testing binary chunks");
    local headformat = "c8BBc6BiBI1BjBn";
    local header = [ /// header components
        "\eTokudae",            # signature
        0x10,                   # version 1.0 (0x10)
        0,                      # format
        "\x19\x93\r\n\x1a\n",   # a binary string
        string.packsize("i"),   # size of an int
        -69,                    # an int
        1,                      # size of an opcode
        0xf1,                   # an opcode (1 byte)
        string.packsize("j"),   # size of a Tokudae integer
        -69,                    # a Tokudae integer
        string.packsize("n"),   # size of a Tokudae float
        -69.5,                  # a Tokudae float
    ];

    local c = string.dump(fn() {
        local a = 1; local b = 3;
        local f = || { return a + b + __ENV.c }; /// upvalues
        local s1 = "a constant";
        local s2 = "another constant";
        return a + b * 3;
    });

    assert(assert(load(c))() == 10);

    /// check header
    local l = [string.unpack(headformat, c)];
    foreach i in range(header.len)
        assert(l[i] == header[i]);

    /// Testing corrupted header.
    /// A single wrong byte in the head invalidates the chunk,
    /// except for the Tokudae float check. (If numbers are long double,
    /// the representation may need padding, and changing that padding
    /// will not invalidate the chunk.)
    local headlen = string.packsize(headformat);
    headlen = headlen - string.packsize("n"); /// remove float check
    for (local i = 0; i < headlen; i++) {
        local s = (i > 0 and string.substr(c, 0, i - 1) or "") ..
            string.char((string.byte(string.substr(c, i, i)) + 1) & 0xFF) ..
            string.substr(c, i + 1, -1);
        assert(len(s) == len(c) and s != c);
        assert(!load(s));
    }

    /// loading truncated binary chunks
    foreach i in range(len(c) - 1) {
        local st, msg = load(string.substr(c, 0, i));
        assert(!st and string.find(msg, "truncated"));
    }
}


{ /// check reuse of strings in dumps
    print("testing reuse of strings in dumps");
    local str = "|" .. string.repeat("X", 50) .. "|";
    local foo = load(string.fmt([=[
        local str <final> = "%s";
        return [
            || :: return str,
            || :: return str,
            || :: return str
        ];
    ]=], str));
    /// count occurrences of 'str' inside the dump
    local dump = string.dump(foo);
    local _, count = reg.gsub(dump, str, {});
    /// there should be only two occurrences:
    /// one inside the source, other the string itself.
    assert(count == 2);
}

/// test parameter adjustment
assert((fn() { return nil; })(4) == nil);
assert((fn() { local a; return a; })(4) == nil);
assert((fn(a) { return a; })() == nil);


{ /// function as function argument with 'return' as body
    local fn a(x,y) :: assert(y == 5);
    a(|| :: return, 5);
    a = |x,y| { assert(x == 5); };
    a(5, || return);
}

if __heavy { /// test stack/bytecode limit
    print("testing stack/bytecode limit");
    local blim <final> = 16_777_215;
    local inuse = debug.stackinuse();
    if (debug.maxstack - inuse - 10 > blim) { /// test bytecode limit 
        local code = "return 10" .. string.repeat(",10", blim - 2);
        local res, msg = load(code .. ";");
        assert(res and !msg);
        res = [assert(res())];
        assert(res.len == blim-1 and res.last == 10);
        code = code .. ",10;";
        res, msg = load(code);
        assert(!res and string.find(msg, "too much stack space"));
    } else { /// test stack size limit
        local fn foverflow(func) { return [func()]; }
        local code = "return 10" .. string.repeat(",10", debug.maxstack);
        local res, msg = load(code .. ";");
        assert(res and !msg);
        res, msg = pcall(foverflow, res);
        assert(!res and string.find(msg, "stack overflow"));
    }
} else
    (Message or print)("skipped stack/bytecode limit test");

__G.a = nil;
