#!../tokudae

/* Quick version check, keep this first! */
local version = "Tokudae 1.0";
if __VERSION != version { /* test script and core version mismatch? */
    io.stderr.write("This test script is for ", version, ", not for ",
                     __VERSION, "\nExiting...");
    return; /* done */
}

/*
** Default options.
** For usage string, grep (without double-quotes) "local usage".
*/
__opts = {
    termcodes = true, /* -c (true) | -C (false) */
    warnings = false, /* -w (true) | -W (false) */
    noprint = true, /* -o (true) | -O (false) */
    memory = false, /* -m (true) | -M (false) */
    errors = true, /* -r (true) | -R (false) */
    timed = true, /* -z (true) | -Z (false) */
    reprint_failed = true, /* -f (true) | -F (false) */
    abort_on_fail = true, /* -a (true) | -A (false) */
    run_isolated = false, /* -i (true) | -I (false) */
    enter_debug = false, /* -d (true) | -D (false) */
    rebuild = true, /* -b (true) | -B (false) */
    testsuites_to_skip = [], /* -e testsuite */
    testsuites_to_run = [], /* non-flag arguments */
    cli_tests = [], /* -t test_file */
    tests_script = "testsuites.toku", /* -s tests_script */
};


/*
** {=====================================================================
** Additional (environment specific) settings
** ======================================================================
*/

/* false if not running heavy tests */
__heavy = __G.__heavy or true; /* default is true */
/* false if runnning non-portable tests or assuming posix/windows environment */
__port = __G.__port or false; /* default is false on windows and posix */
/* false if not reporting messages of (parts of) tests not performed */
__skipmsg = __G.__skipmsg or true; /* default is true */

/*
** Specific programs/devices/files used when rebuilding the
** standalone executable or running non-portable options.
*/

local script_name = "test_linux.toku";

local make_target = "linux-readline";
local make_threads = 6;

local dev_null = "/dev/null";
local dev_null1 = " > " .. dev_null;
local dev_null2 = " 2> " .. dev_null;
local dev_null12 = dev_null1 .. " 2>&1";

local cp = "cp";

/* }===================================================================== */


/*
** {=====================================================================
** Test driver and internals
** ======================================================================
*/

/* save program name */
local prog =  "../tokudae";
local oldprog = prog .. ".old";


local script = string.substr(debug.getinfo(1, "s").source, 1); /* skip '@' */
if (string.startswith(args[0], "./") and !string.startswith(script, "./"))
    script = "./" .. script;


if script != "./" .. script_name {
    io.stderr.write("Test script must be run as a command.\nExiting...");
    return; /* done */
}


/* save command-line arguments and program name */
__cliargs = cliargs;
__args = args;
__prog = prog;


/* copy over command-line arguments */
local args = list.new(__args.len);
foreach i,arg in indices(__args)
    args[i] = arg;



/* global table for caching tests table */
__tests = nil;


/*
** Expected fields in '__opts' and their value types.
** For verification in case user modifies the '__opts' table.
*/
local expected_opts = {
    termcodes = "boolean",
    warnings = "boolean",
    noprint = "boolean",
    memory = "boolean",
    errors = "boolean",
    timed = "boolean",
    reprint_failed = "boolean",
    abort_on_fail = "boolean",
    run_isolated = "boolean",
    enter_debug = "boolean",
    rebuild = "boolean",
    testsuites_to_skip = "list",
    testsuites_to_run = "list",
    cli_tests = "list",
    tests_script = "string",
};


/*
** Short description of each option.
** Kept in a list to preserve ordering.
*/
local opts_desc = [
    ["termcodes", "output ANSI escape codes"],
    ["warnings", "enable output of warnings"],
    ["noprint", "replace 'print' and 'printf'"],
    ["memory", "print memory usage"],
    ["errors", "print error messages"],
    ["timed", "time the test execution"],
    ["reprint_failed", "re-print failed tests"],
    ["abort_on_fail", "abort test script on failed test"],
    ["run_isolated", "run each test in isolation"],
    ["enter_debug", "enter interactive mode"],
    ["rebuild", "rebuild standalone interpreter"],
];


/* command-line character (including '-') of each option */
local opts_flags = {
    termcodes = "-c",
    warnings = "-w",
    noprint = "-o",
    memory = "-m",
    errors = "-r",
    timed = "-z",
    reprint_failed = "-f",
    abort_on_fail = "-a",
    run_isolated = "-i",
    enter_debug = "-d",
    rebuild = "-b",
};


/*
** List for storing failed tests (in order of failure).
** Each list element is a table, in that table each key is
** the name of the test (a string) with value being the
** error message (a string).
*/
local failed_tests = [];

/* list for storing messages about (parts of) skipped tests */
local skip_msgs = [];

/* save standard files */
local stdout, stderr, stdin = io.stdout, io.stderr, io.stdin;

/* store these as locals as tests might change them if they are not ran in isolation */
local traceback,print,printf,execute = debug.traceback,print,printf,os.execute;
local fmt,assert,popen,flush = string.fmt,assert,io.popen,io.flush;
local find,runfile,typeof,error,indices = reg.find,runfile,typeof,error,indices;
local output,sfind,substr,tostr = io.output,string.find,string.substr,tostr;
local len,remove,byte,clock = len,list.remove,string.byte,os.clock;
local tmpname,fields,gc,rm,flatten = os.tmpname,fields,gc,os.remove,list.flatten;
local exit,getinfo,enumerate = os.exit,debug.getinfo,indices;
local char,dbg,gmatch,repeat = string.char,debug.debug,reg.gmatch,string.repeat;
local startswith,ostime = string.startswith,os.time;


/* upvalues for timing execution */
local initclock, lastclock;
local fn initialize_clock() {
    initclock = clock();
    lastclock = initclock;
}


/* tests should import debug library when needed */
debug = nil;


/* storage for print functions and temporary file (otherwise empty) */
__c = {};


local fn isatty() :: return execute("[ -t 1 ]");


/*
** Apply escape code 'c' if options are enabled and 'stdout' is terminal.
** @c - string
** @s - ?string
** @ismode - ?boolean
*/
local fn tcode(c, s, ismode) {
    s = s or "";
    if !__port and __opts.termcodes and isatty()
        return (c .. s .. (ismode and "\e[0m" or ""));
    return s;
}

local fn ESC(seq) :: return "\e" .. seq;

/* colors */
local fn RED(s)     :: return tcode(ESC("[31m"), s, true);
local fn GREEN(s)   :: return tcode(ESC("[32m"), s, true);
local fn YELLOW(s)  :: return tcode(ESC("[33m"), s, true);
local fn BLUE(s)    :: return tcode(ESC("[34m"), s, true);
local fn MAGENTA(s) :: return tcode(ESC("[35m"), s, true);
local fn CYAN(s)    :: return tcode(ESC("[36m"), s, true);

/* modes */
local fn STRIKE(s) :: return tcode(ESC("[9m"), s, true);

/* editing */
local fn ERASELINE() :: return tcode(ESC("[2K"));


if __skipmsg { /* store skipped (parts of) tests? */
    /*
    ** Stores the message 'msg' into 'skip_msgs'.
    ** @msg - string
    */
    fn Message(msg) {
        local t = getinfo(2, "sl");
        local where = fmt("%s:%s: ", YELLOW(t.source), YELLOW(tostr(t.currline)));
        skip_msgs[skip_msgs.len] = where .. msg;
    }
}


/*
** Generate test string that depends on test result 'stat'.
** @test - string
** @stat - any
*/
local fn testfmt(test, stat) {
    local C = stat and GREEN or RED;
    local res = stat and "PASS" or "FAIL";
    return fmt("%s %-55s", C("[  " .. res .. "  ]"), test);
}


/*
** Builds a shell command line from the function arguments.
*/
local fn buildcmd(...) {
    local cmd = "";
    local args = [...];
    foreach i,arg in indices(args) {
        cmd ..= tostr(arg);
        if i != args.len - 1
            cmd ..= " ";
    }
    return cmd;
}


/*
** Builds command string for listing files/directories.
** @what - string
** @path - ?string
*/
local fn lscmd(what, path) {
    local cmd;
    if (what == "d") { /* list directories? */
	cmd = "ls -p"; /* use 'ls' */
	if (path) cmd = buildcmd(cmd, path);
	cmd = buildcmd(cmd, "| grep /"); /* and 'grep' */
    } else { /* otherwise list non-hidden files */
        assert(what == "f");
        cmd = "ls -p ";
        if (path) cmd = buildcmd(cmd, path);
        cmd = buildcmd(cmd, "| grep -v /"); /* and 'grep' */
    }
    return cmd;
}


/*
** Verifies validity of tests table.
** @tests - table
*/
local fn verify_tests_table(tests) {
    foreach tsuite,tlist in fields(tests) {
        assert(typeof(tsuite) == "string",
               fmt("testsuite name should be a string, instead got '%s'",
                    typeof(tsuite)));
        foreach _,test in indices(tlist)
            assert(typeof(test) == "string",
                   fmt("test name should be a string, instead got '%s'",
                        typeof(test)));
    }
}


/* combination of 'error' and 'string.fmt' */
local fn errorfmt(fmt, ...) :: error(fmt(fmt, ...));


/*
** Finds all testsuites and their tests in the current directory.
** First, the current directory is listed, each directory listed is
** considered to be a testsuite, and each file ending with '.toku'
** in that directory is considered as a test belonging to that testsuite.
** If we are not running in posix or windows environment, use hard-coded
** testsuites defined in '__opts.tests_script' file. Returned table contains
** testsuite names as keys and values are lists containing test filepaths.
** @filename - ?string
*/
local fn get_tests(filename) {
    if __tests return __tests; /* have one already */
    local tests = {};
    if (!filename and !__port) { /* discover directories and tests? */
        local f = assert(popen(lscmd("d")), "can't list directories");
        foreach dir in f.lines() {
            if byte(dir, 0) == '_' /* file starts with '_'? */
                continue; /* ignore it */
            local tsuite = substr(dir, 0, -2); /* no '/' or '\\' */
            local ltests = []; /* list of testsuite tests */
            local n = 0; /* number of tests */
            f = assert(popen(lscmd("f", dir)), "can't list files");
            foreach file in f.lines() {
                if (!find(file, "%.toku$"))
                    continue; /* skip files without '.toku' suffix */
                ltests[n] = dir .. file; /* store test path */
                n = n + 1; /* inc. test count */
            }
            tests[tsuite] = ltests; /* store the testsuite */
        }
    } else { /* otherwise try get 'tests' table from a file */
        if !filename /* no filename? */
            error("can't generate tests on this system or missing filename");
        tests = runfile(filename);
        if typeof(tests) != "table"
            errorfmt("'%s' script must return a table, instead got %s",
                      filename, typeof(tests));
    }
    verify_tests_table(tests);
    __tests = tests; /* cache it */
    return tests;
}


/*
** Output test table to 'stdout'.
** It first checks for already generated tests table in '__tests', otherwise
** it tries to generate from 'tests_script', finally if 'tests_script' is
** not provided, the script will try to auto-generate tests table from the
** current directory (not portable).
** @tests_script - ?string
*/
local fn output_tests_table(tests_script) {
    local tests = get_tests(tests_script);
    stdout.setvbuf("full");
    stdout.write("return " .. "{\n");
    foreach tsuite, tlist in fields(tests) {
        stdout.write("  " .. tsuite .. " = [\n");
        foreach _,test in indices(tlist)
            stdout.write("    \"" .. test .. "\",\n");
        stdout.write("  ],\n");
    }
    stdout.write("}" .. ";" .. "\n");
    stdout.flush();
    stdout.setvbuf("line");
}


/*
** Returns formatted elapsed time depending on the time 'c'.
** @c - number
*/
local time_in_dbg = 0;
local prevtest_time = math.maxint;
local fn gettime(c) {
    local elapsed = c - lastclock;
    local total_time = fmt("%-8g", c - initclock);
    local test_time = fmt("+%-8g", elapsed);
    if (prevtest_time < elapsed)
        test_time = RED(test_time);
    else if (elapsed < prevtest_time)
        test_time = CYAN(test_time);
    else
        test_time = YELLOW(test_time);
    local s = fmt("%s (%s)", BLUE(total_time), test_time);
    prevtest_time = elapsed;
    lastclock = c - time_in_dbg; /* compensate for time in interactive mode */
    time_in_dbg = 0; /* reset */
    return s;
}


/*
** Formats memory usage in bytes to use K for 1000 and M for 1000000
** (not 2^10 -- 2^20).
** @m - number
*/
local fn memfmt(m) {
    local fn round(m) {
        m = m + 0.04999;
        return fmt("%.1f", m); /// keep one decimal digit
    }
    if m < 1000
        return m;
    else {
        m = m / 1000;
        if m < 1000
            return tostr(round(m)).."K";
        else
            return tostr(round(m/1000)).."M";
    }
}


/*
** Displays current memory usage and the last maximum memory usage.
** Formatting is done according to 'memfmt'.
*/
local max = 0;
local mprev = 0;
local fn showmem() {
    local currfmt;
    local m = gc("count") * 1024;
    max = (m > max) and m or max;
    local mcurr = memfmt(m);
    local mmax = memfmt(max);
    if (m < mprev) /* less memory than previous test? */
        mcurrfmt = CYAN;
    else if (m == max) /* new maximum or equal to previous maximum? */
        mcurrfmt = RED;
    else /* otherwise allocated more memory */
        mcurrfmt = YELLOW;
    printf("           %|%", mcurrfmt(mcurr), RED(mmax));
    mprev = m;
};


local fn loginfo(msg)  :: stdout.write(fmt("[%s]: %s\n", YELLOW("INFO"), msg));
local fn loginput(msg) :: stdout.write(fmt("[%s]: %s\n", MAGENTA("INPUT"), msg));
local fn logcmd(msg)   :: stdout.write(fmt("[%s]: %s\n", RED("CMD"), msg));


/* temporary output file */
local tempfile = (class {
    __gc = || {
        assert(typeof(self) == "instance");
        if self.file {
            loginfo(fmt("removing temporary output file '%s'...", self.file));
            rm(self.file);
        }
    };
})();


local fn print_test_result(stat, filepath, c) {
    local s = testfmt(filepath, stat);
    if !__opts.run_isolated and __opts.timed
        s ..= "  " .. gettime(c);
    print(s);
}


/* function (assigned later) */
local prompt_run_failed_test;


/*
** Runs individual test and outputs the result to 'stdout'.
** @filepath - string
*/
local fn run_test(filepath) {
    if (__opts.memory) showmem();
    local oktc = __opts.termcodes and __opts.noprint and !__opts.warning;
    if oktc and isatty() {
        stdout.write(fmt("Currently running '%s'...", YELLOW(filepath)));
        stdout.flush();
    }
    local stat, msg, code, c;
    if __opts.run_isolated
        stat, msg, code = execute(prog .. " " .. filepath .. dev_null12);
    else { /* otherwise run in the same global environment */
        stat, msg = xpcall(runfile, traceback, filepath);
        c = clock();
    }
    if oktc and isatty() {
        stdout.write("\r" .. ERASELINE());
        stdout.flush();
    }
    print_test_result(stat, filepath, c);
    if __opts.enter_debug {
        local c = clock();
        dbg(); /* enter interactive mode */
        time_in_dbg = clock() - c;
    }
    if !stat { /* test failed? */
        if __opts.run_isolated and msg and code
            msg = msg .. " (code " .. tostr(code) .. ")";
        failed_tests[failed_tests.len] = { /* add it to failed tests list */
            testname = filepath,
            errormsg = msg,
        };
        if __opts.errors /* print errors of failed tests? */
            print(msg);
        if __opts.abort_on_fail { /* abort on first failed test? */
            prompt_run_failed_test();
            exit(1, true);
        }
    }
}


/*
** @tsuite - string
** @isend - ?any
*/
local fn testsuite_headerfmt(tsuite, isend) {
    local txt, mode, cl = "BEGIN", fn(x) {return x}, MAGENTA;
    if isend {
        mode = STRIKE;
        cl = CYAN;
        txt = "END";
    }
    txt = cl("> " .. txt .. "(") .. mode(tsuite) .. cl(")");
    if (isend and !__opts.run_isolated and __opts.timed)
        txt = txt .. BLUE(fmt(" %-8g", lastclock - initclock));
    print(txt);
}


/*
** Runs all the tests located in 'tlist' for testsuite 'tsuite'.
** @tsuite - string
** @tlist - list
*/
local fn run_tests(tsuite, tlist) {
    if (tlist.len > 0) {
        testsuite_headerfmt(tsuite);
        if !__opts.run_isolated and __opts.timed
            initialize_clock();
        foreach _, filepath in indices(tlist)
            run_test(filepath);
        testsuite_headerfmt(tsuite, true);
    }
}


prompt_run_failed_test = || {
    /* re-run only if they were run in isolation and input is terminal */
    if failed_tests.len == 1 and __opts.run_isolated and isatty() {
        loginput("Would you like to run the failed test directly " ..
                 "before exiting [yYnN] (default 'y'): ");
        loop { /* repeat until valid option */
            local opt = stdin.read("l");
            opt = (opt == "") and "y" or opt;
            switch opt {
                case "y": case "Y": { /* re-run failed tests */
                    local testname = failed_tests[0].testname;
                    failed_tests[0] = nil; /* reset 'failed_tests' list */
                    __opts.run_isolated = false; /* run tests directly */
                    __opts.reprint_failed = false; /* do not re-print error */
                    run_tests("failed_test", [testname]); /* run the failed test */
                    /* fall through */
                }
                case "n": case "N": return; /* do not run; done */
                default: loginput("Unrecognized option try one of [yYnN] (default 'y'): ");
            }
        }
    }
};


/*
** Checks if testsuite should be skipped.
** @testsuite - string
*/
local fn shouldskip(testsuite) {
    if __opts.testsuites_to_skip {
        foreach i,name in indices(__opts.testsuites_to_skip) {
            if name == testsuite
                return true;
        }
    }
    return false;
}


/*
** Runs specific testsuites provided as extra arguments.
** These must map to testsuites located in table returned from 'tests_script'.
** If 'tests_script' is not provided, the script will try to auto-generate
** tests table from the current directory (not portable).
** @tests_script - ?string
** @varags - string
*/
local fn run_testsuites(tests_script, ...) {
    local filter = [...];
    if (filter.len == 0) return; /* done; nothing to run */
    tests = get_tests(tests_script);
    foreach i,name in indices(filter) {
        if shouldskip(name) continue; /* skip */
        local tlist = tests[name];
        if tlist
            run_tests(name, tlist);
        else
            error("invalid testsuite '" .. name .. "'");
    }
}


/*
** Runs all testsuites located in the table returned from 'tests_script'.
** If 'tests_script' is not provided, the script will try to auto-generate
** tests table from the current directory (not portable).
** @tests_script - ?string
*/
local fn run_all_testsuites(tests_script) {
    local tests = get_tests(tests_script);
    foreach name,tlist in fields(tests) {
        assert(typeof(name) == "string"); /* must be testsuite name */
        if shouldskip(name) continue; /* skip */
        run_tests(name, tlist);
    }
}

/* }===================================================================== */


/*
** {====================================================================
** Command-line-interface
** =====================================================================
*/

/*
** Usage string.
*/
local usage = [=[
usage: ./test_{platform}.toku [-h] [-cCwWoOmMrRzZfFaAiIdDbB[t|e|s arg] ...] [arg_testsuite ...]
                                   [-ttest_file | -t test_file]
                                   [-etestsuite_name | -e testsuite_name]
                                   [-stests_script | -s tests_script]
                                   [--minimal-flags]
                                   [--port-flags]
                                   [--verbose-flags]
                                   [--standard-flags]
                                   [--info]
                                   [--out-tests]
                                   [--gen-dir-tests]
                                   [--gen-script-tests]

Available options are:
    -h      Show usage (this), this must be the first option and argument.
            All of the other arguments are ignored and after usage is shown,
            script returns.

    -c      Output ANSI escape codes in order to color and set different
            modes to to text in terminal. This also enables showing the current
            test that is executing (this is disabled if '-w' or '-o').
            This option is not portable and is ignored if 'stdout' is not a terminal.

    -w      Enable output of warnings while running tests.

    -o      Replace 'print' and 'printf' with Tokudae functions that print to
            temporary file instead of 'stdout' (not portable).

    -m      Print memory usage before running the test.

    -r      Print the error message in case test fails.

    -z      Print CPU time of the test execution (not portable). If the tests
            are running in isolation ('-i') then this option is ignored.

    -f      After all tests are finished, re-print failed test names
            (and their error message if '-r').

    -a      Abort the test script after the first failed test.

    -i      Run each test in isolation as a separate process by executing standalone
            interpreter with test as its only argument. All warnings and errors
            won't be reachable as they are redirected to nul(l) device/file,
            only the exit code can be displayed in error messages (not portable).

    -d      After each test is finished, enter interactive mode.
            In order to leave this mode, enter a line containing only "cont".

    -b      Rebuild standalone interpreter before executing new tests.
            The test script is executed in a new process with the newly built
            interpreter executable. All of the original arguments are also passed
            and additionally the '-B' is appended to prevent recursive rebuilds.
            This option is not portable.
            (This flag is ignored on Windows.)

    All of the options above have the uppercase version which does the opposite
    (-C, -W, -O, -M, -R, -Z, -F, -A, -I, -D and -B).

    -t test_file        Add a test file {test_file} into the 'cli_tests' testsuite.
                        This testsuite will be the first to run.

    -e testsuite_name   Exclude testsuite {testsuite_name}, preventing the script
                        from running it.

    -s tests_script     Run Tokudae script {tests_script} to generate the tests table.
                        This script should return a table with testsuite names as
                        keys and lists of filenames as values which represent the
                        tests of that testsuite. Test filepaths inside the list
                        should be absolute or relative to the script file.
                        This is ignored if '--gen-dir-tests'.

    --minimal-flags     Equivalent to '-CWoMRZfaIDB'.
    --port-flags        Equivalent to '-CwOmrZfaIdB'.
    --verbose-flags     Equivalent to '-cWOmrzfAIDb'.
    --standard-flags    Equivalent to '-cWoMRzfAiDB'.

    --info              Show enabled/disabled flags information and their short
                        description. After the information is shown, script
                        returns and no tests are executed.

    --out-tests         Outputs tests table to 'stdout', it first checks for the
                        already present tests table (if it was generated), if
                        missing, it tries to generate tests table from the
                        {tests_script} (default script is 'testsuites.toku').
                        After outputting, script returns and no tests are executed.
                        The default {tests_script} can be changed in '__opts' table.

    --gen-dir-tests     Generates tests table from the current directory structure.
                        After generation is complete, script outputs the tests
                        table if '--out-tests' and returns without executing any
                        tests (not portable). Additionally when outputting the table,
                        it prepends 'return' before the table and appends ';' after
                        the table to terminate the 'return'.

    --gen-script-tests  Equivalent to '--gen-dir-tests', but it instead uses {tests_script}
                        provided with '-s' or as fallback from '__opts.tests_script', to
                        generate tests table. This is ignored if '--gen-dir-tests'.

Other:
    All the other non-option arguments {arg_testsuite} are names of testsuites
    to run, this can act as a filter, in order to run only specific set of
    testsuites. In cases where no specific test is provided (using '-t') and
    no tests script (using '-s'), then the filename in the global table '__opts' 
    is used (see test script). Global table '__opts' sets some default options,
    refer to the test script for more information on what the values of these
    options are.

    If you get error "can't open file...", and you haven't specified '-s' option
    and you are running only with portable options, it usually means the field
    '__opts.tests_script' in the script is set to non-existing file.
    By default this is set to 'testsuites.toku' which comes with the
    distribution, make sure you didn't delete this script, or if you moved
    it to another directory, adjust the filepath of '__opts.tests_script'.
    If that doesn't solve it, then the script '__opts.tests_script' contains
    invalid test filepath. You could always try to re-generate the tests script
    from the current directory with:
    './test_{platform}.toku --out-tests --gen-dir-tests > {tests_script}'.

    Note: If your system does not have access to 'system', you should use the
    default testsuites script that comes with the distribution or re-build it
    manually, by writting out the test table structure yourself, or modify the
    test script itself.
]=];


/* current argument index */
local argi = 0;


/*
** Raise error for missing option argument.
** @opt - string
*/
local fn option_missing_arg_error(opt, what) {
    print(usage);
    error("option '" .. opt .. "' requires argument (" .. what .. ")");
}


/*
** Gets the next argument, which is either part of the current argument
** string, or is the next argument in the 'args' list.
** @nbyte - integer
*/
local fn get_arg(nbyte) {
    local arg = substr(args[argi], nbyte+1);
    if (0 < len(arg)) /* no space between option and argument? */
        return arg; /* skip option char */
    else if (argi + 1 < args.len) { /* have next argument? */
        argi = argi + 1; /* go to next argument */
        return args[argi]; /* and return it */
    } else 
        return nil; /* missing argument */
}


/*
** Get required argument to current option.
** @args - list
** @what - string
*/
local fn get_req_arg(nbyte, opt, what) {
    return get_arg(nbyte) or option_missing_arg_error(opt, what);
}


/*
** Handles flag options starting with '--', these options set
** multiple flag options at once.
*/
local showinfo = false; /* '--info' option */
local out_tests = false; /* '--out-tests' option */
local gen_dir_tests = false; /* '--gen-dir-tests' option */
local gen_script_tests = false; /* '--gen-script-tests' option */
local fn handle_multi_option(opt) {
    switch (opt) {
        case "minimal-flags": {
            __opts.termcodes = false;
            __opts.warnings = false;
            __opts.noprint = true;
            __opts.memory = false;
            __opts.errors = false;
            __opts.timed = false;
            __opts.reprint_failed = true;
            __opts.abort_on_fail = true;
            __opts.run_isolated = false;
            __opts.enter_debug = false;
            __opts.rebuild = false;
            break;
        }
        case "port-flags": {
            __opts.termcodes = false;
            __opts.warnings = true;
            __opts.noprint = false;
            __opts.memory = true;
            __opts.errors = true;
            __opts.timed = false;
            __opts.reprint_failed = true;
            __opts.abort_on_fail = true;
            __opts.run_isolated = false;
            __opts.enter_debug = true;
            __opts.rebuild = false;
            break;
        }
        case "verbose-flags": {
            __opts.termcodes = true;
            __opts.warnings = false;
            __opts.noprint = false;
            __opts.memory = true;
            __opts.errors = true;
            __opts.timed = true;
            __opts.reprint_failed = true;
            __opts.abort_on_fail = true;
            __opts.run_isolated = false;
            __opts.enter_debug = false;
            __opts.rebuild = true;
            break;
        }
        case "standard-flags": {
            __opts.termcodes = true;
            __opts.warnings = false;
            __opts.noprint = true;
            __opts.memory = false;
            __opts.errors = true;
            __opts.timed = true;
            __opts.reprint_failed = true;
            __opts.abort_on_fail = false;
            __opts.run_isolated = true;
            __opts.enter_debug = false;
            __opts.rebuild = false;
            break;
        }
        case "info":
            showinfo = true;
            break;
        case "out-tests":
            out_tests = true;
            break;
        case "gen-script-tests":
            gen_script_tests = true;
            break;
        case "gen-dir-tests":
            gen_dir_tests = true;
            break;
        default: {
            print(usage);
            error("unknown option '" .. opt .. "'");
        }
    }
}


/*
** Handles flag option, lowercase flag options always turn on the
** options in '__opts', while uppercase are considered as false.
** @f - integer
*/
local fn handle_flag_option(f) {
    assert(typeof(f) == "number" and 0 <= f and f <= 255);
    local val = (f & 0x20) != 0;
    switch (f & ~0x20) {
        case 'C': __opts.termcodes = val; break;
        case 'W': __opts.warnings = val; break;
        case 'O': __opts.noprint = val; break;
        case 'M': __opts.memory = val; break;
        case 'R': __opts.errors = val; break;
        case 'Z': __opts.timed = val; break;
        case 'F': __opts.reprint_failed = val; break;
        case 'A': __opts.abort_on_fail = val; break;
        case 'I': __opts.run_isolated = val; break;
        case 'D': __opts.enter_debug = val; break;
        case 'B': __opts.rebuild = val; break;
        default: {
            print(usage);
            error("unknown option '" .. char(f) .. "'");
        }
    }
}


/*
** Handles command-line option.
** Flag options can be aggregated by a single '-', such as '-cWOz', and
** can end with a non-flag option such as '-cWOzt example.toku'.
** Non-flag options require additional argument, this argument can be
** provided as separate argument or part of the same argument such as
** '-texample.toku'.
** @opt - string
*/
local fn handle_option(opt) {
    local lim = len(opt);
    local nbyte = 1; /* start at byte after '-' */
    loop {
        local o = byte(opt, nbyte);
        switch (o) {
            case 't': { /* test file */
                local tests = __opts.cli_tests;
                tests[tests.len] = get_req_arg(nbyte, o, "test file");
                return;
            }
            case 'e': { /* exclude */
                local tsuites = __opts.testsuites_to_skip;
                tsuites[tsuites.len] = get_req_arg(nbyte, o, "testsuite");
                return;
            }
            case 's': { /* tests script */
                __opts.tests_script = get_req_arg(nbyte, o, "tests script");
                return;
            }
            default: {
                if (nbyte == 1 and o == '-') { /* multi-set option? */
                    handle_multi_option(substr(opt, 2));
                    return;
                } else /* otherwise regular flag option */
                    handle_flag_option(o);
            }
        }
        nbyte = nbyte + 1;
        if (lim <= nbyte) break; /* no more options */
    }
}


/*
** Raises error if option value is not of expected type.
** @option - string
** @expected_type - string
** @value_type - string
*/
local fn expect_option(option, expected_type, value_type) {
    assert(typeof(option) == "string", "option is not a string");
    if expected_type != value_type
        errorfmt("invalid value for option '%s', expected %s, instead got %s",
                  option, expected_type, value_type);
}


/*
** Verifies validity of '__opts' table.
** @options - table
*/
local fn verify_opts() {
    assert(__opts, "missing '__opts' table");
    foreach k,_ in fields(expected_opts)
        assert(__opts[k] != nil, fmt("missing option '%s' in '__opts'", k));
    foreach k,v in fields(__opts) {
        local expected_type = expected_opts[k];
        assert(expected_type != nil, fmt("invalid option '%s' in '__opts'", k));
        expect_option(k, expected_type, typeof(v));
    }
}


/*
** Handles all command-line options and arguments.
** @args - list
*/
local fn handle_cli_args() {
    verify_opts();
    for (argi = 1; argi < args.len; argi = argi + 1) {
        local arg = args[argi];
        if (byte(arg, 0) == '-' and 1 < len(arg)) { /* option? */
            if (argi == 1 and byte(arg, 1) == 'h') { /* help option? */
                print(usage);
                exit(0, true);
            }
            handle_option(arg);
        } else { /* otherwise treat it as a testsuite name */
            local l = __opts.testsuites_to_run;
            l[l.len] = arg;
        }
    }
}


/*
** Displays messages of (parts of) skipped tests.
*/
local fn display_skipped() {
    if __skipmsg {
        if __opts.run_isolated {
            loginfo("no information on (parts of) skipped tests (if any), " ..
                    "as tests were ran in isolation ('-i')");
        } else if 0 < skip_msgs.len {
            print("\nSkip messages:");
            foreach _,msg in indices(skip_msgs)
                print(YELLOW("> ") .. msg);
        }
    }
}


/* auxiliary to 'display_run_information' */
local fn get_maximum_line_length_in_information() {
    local max = 0;
    local base_len = len("-  (-x): |\n");
    foreach _,lst in indices(opts_desc) {
        local k = lst[0];
        local v = lst[1];
        local l = base_len + (v and 4 or 5) + len(v);
        max = max < l and l or max;
    }
    return max + 1;
}


/*
** Before running tests/testsuites, displays information on enabled/disabled
** options which affect how tests will be run.
*/
local fn display_run_information() {
    local info = "";
    local max = get_maximum_line_length_in_information();
    local offset = len("|\n");
    foreach _,lst in indices(opts_desc) {
        local s = "";
        local k = lst[0];
        local v = lst[1];
        local res = __opts[k] and GREEN("true") or RED("false");
        s = s .. YELLOW("- ").."("..opts_flags[k]..") "..v..": "..res;
        local l = len(s);
        if !__port and __opts.termcodes {
            l = l - 18; /* length without ANSI escape codes */
            assert(0 < l, "termcodes not written but options enable it");
        }
        l = l + offset; /* do not include 'offset' bytes */
        s = s .. repeat(" ", max - l); /* add padding */
        s = s .. YELLOW(" ~\n");
        info = info .. s; /* add current information to 'info' */
    }
    /* output information to 'stdout' */
    stdout.setvbuf("full");
    stdout.write("\n", YELLOW("> INFO ") .. YELLOW(repeat("=", max-7) .. "\n"));
    stdout.write(info);
    stdout.write(YELLOW("< INFO ") .. YELLOW(repeat("=", max-7) .. "\n\n"));
    stdout.setvbuf("line");
    stdout.flush();
}


/*
** Runs the test script with all the arguments provided by CLI.
*/
local fn run_args() {
    verify_opts();
    display_run_information();
    run_tests("cli_tests", __opts.cli_tests);
    if (__opts.testsuites_to_run.len > 0) /* explicit testsuites? */
        run_testsuites(__opts.tests_script, flatten(__opts.testsuites_to_run));
    else if (__opts.cli_tests.len == 0) /* no explicit testsuites and tests? */
        run_all_testsuites(__opts.tests_script); /* run all from tests script */
    prompt_run_failed_test();
    display_skipped(); /* display skip messages (if any) */
    if __opts.reprint_failed { /* reprint failed tests? */
        local n = failed_tests.len;
        if (n > 0) {
            printf("% failed test(s):", RED(tostr(n)));
            foreach _,entry in indices(failed_tests) {
                local test = entry.testname;
                local err = entry.errormsg;
                print(RED(test) .. (__opts.errors and ":\n"..err or ""));
            }
        }
    }
}


/*
** Set specific options in '__opts'.
** Should be called after all cli options and arguments were parsed.
*/
local fn set_output_options() {
    if __opts.noprint and !__port {
        __c = { /* store old functions */
            print = __G.print,
            printf = __G.printf,
        };

        /* file for redirecting 'stdout' and 'stderr' when running a test */
        local out = assert(tmpname());
        tempfile.file = out;

        /* replace 'print' while testing */
        __G.print = fn(...) {
            local args = [...];
            local oldout = output();
            output(out);
            foreach i,arg in indices(args) {
                if i > 0
                    io.write("\t");
                io.write(tostr(arg));
            }
            io.write("\n");
            output().flush();
            output().close();
            output(oldout);
        };

        /* replace 'printf' while testing */
        __G.printf = fn(fmt, ...) {
            local str = "";
            local args = [...];
            local oldout = output();
            local i = 0;
            local j = sfind(fmt, "%");
            output(out);
            while (j and j < len(fmt)) {
                str = str .. substr(fmt, i, j - 1);
                if byte(fmt, j+1) == '%' {
                    str = str .. "%";
                    i = j + 1;
                } else {
                    if args.len <= 0
                        error("missing format value");
                    local arg = tostr(remove(args, 0));
                    str = str .. arg;
                    i = j + 1 + len(arg);
                }
                fmt = substr(fmt, j+1);
                j = sfind(fmt, "%");
            }
            str = str .. "\n";
            io.write(str);
            output().flush();
            output().close();
            output(oldout);
        };
    }
    if !__opts.warnings { /* no warnings? */
        __c.warn = __G.warn;
        __G.warn = fn(...) { return; };
    }
}

local fn report(fatal, msg, st, what, code) {
    if !st {
        loginfo(fmt("fail, %s (%s -> %d)", msg, what, code));
        if (fatal) exit(1, true);
    }
    return st;
}


/*
** Removes backup executable.
*/
local have_oldprog = false;
local fn rmoldprog(restore) {
    if have_oldprog {
        if restore { /* restore before removing? */
            loginfo(fmt("%s backup executable...", GREEN("restoring")));
            report(true, "can't restore executable", execute(buildcmd(cp, oldprog, prog)));
        }
        loginfo(fmt("%s backup executable...", RED("removing")));
        rm(oldprog);
        have_oldprog = false;
    } else
        error("can't restore/remove backup executable (no such file)");
}

/* }==================================================================== */


/* ============ MAIN ============= */

handle_cli_args();

if showinfo /* only show enabled/disabled options? */
    display_run_information();
else if !out_tests and __opts.rebuild { /* rebuild standalone interpreter? */
    loginfo("rebuilding Takudae standalone interpreter...");
    report(true, "can't create executable backup",
           execute(buildcmd(cp, prog, oldprog, dev_null1)));
    loginfo(fmt("%s backup executable '%s'", GREEN("created"), oldprog));
    have_oldprog = true;
    local cmd = buildcmd("make -j",  make_threads);
    local dir = startswith(prog, "./") and "." or "..";
    cmd = buildcmd("cd", dir, "&&", cmd, "clean", dev_null1, "&&", cmd, make_target);
    cmd = buildcmd(cmd, dev_null1); /* redirect 'stdout' to null */
    logcmd(cmd);
    if !report(false, msg, execute(cmd)) { /* rebuild failed? */
        loginfo("rebuild failed, exiting...");
        rmoldprog(true);
        exit(1, true);
    }
    rmoldprog(false);
    cmd = buildcmd(flatten(__args)); /* pass all the args to the new executable */
    cmd = buildcmd(cmd, "-B"); /* (do not rebuild the second time) */
    loginfo("rebuild successful, executing...");
    assert(startswith(cmd, script),
           fmt("arguments must start with '%s' ('%s')", script, cmd));
    logcmd(cmd);
    exit(execute(cmd), true); /* execute script with newly built executable */
} else { /* otherwise execute arguments without rebuilding */
    set_output_options();
    if gen_dir_tests
        get_tests();
    else if gen_script_tests
        get_tests(__opts.tests_script);
    if out_tests
        output_tests_table(__opts.tests_script);
    else if !gen_dir_tests and !gen_script_tests
        run_args();
}
